lpTag.callback({"taglets":[{"name":"lpSecureStorage","type":0},{"name":"sdeInfoScraper","type":0,"parameters":[{"id":"6","value":"{\"def\":{\"retry\":2,\"when\":\"asap\",\"delay\":1000,\"sendIncomplete\":true,\"sendRetry\":false},\"lookup\":{\"116\":{\"jVar\":\"document.location.hostname\"}},\"sde\":{\"type\":\"mrktInfo\",\"info\":{\"affiliate\":\"{{116}}\"}}}"},{"id":"7","value":"{\"def\":{\"retry\":2,\"when\":\"asap\",\"delay\":1000,\"sendIncomplete\":true,\"sendRetry\":false},\"lookup\":{\"151\":{\"jVar\":\"document.location.hostname\"}},\"sde\":{\"type\":\"ctmrinfo\",\"info\":{\"storeNumber\":\"{{151}}\"}}}"}]},{"name":"lp_sdes","type":0},{"name":"scraper","type":0},{"name":"lpActivityMonitor","type":0},{"name":"rendererStub","type":0},{"name":"lp_version_detector","type":0},{"name":"lp_monitoringSDK","type":0},{"name":"lpTransporter","type":0},{"name":"lpUnifiedWindow","type":0},{"name":"SMT","type":0},{"name":"lp_css_customization","type":0,"parameters":[{"id":"lp_css_customization","value":"{\"customWindowCSS\":[\"svg{display: inline !important}\"]}"}]},{"name":"hooks","type":0},{"name":"lp_SMT","type":0},{"name":"authenticator","type":0},{"name":"lp_global_utils","type":0},{"name":"unAuthMessaging","type":0},{"name":"jsLoader","type":0}],"site":"75931016","features":{"Common.LiveEngage_2_CrossDomainStorage":false,"Messaging.Auto_Messages":true,"Common.Multiple_Consumer_IDP":false},"serviceMap":[{"account":"75931016","baseURI":"lo.routingbot.ext.liveperson.net","service":"routingBot"},{"account":"75931016","baseURI":"lo.bc-nlu.liveperson.net","service":"cbNluDomain"},{"account":"75931016","baseURI":"lo.socialoperations.liveperson.net","service":"socialOperationsDomain"},{"account":"75931016","baseURI":"lo.lp-connector2instagram.liveperson.net","service":"instagramConnector"},{"account":"75931016","baseURI":"lo.medalliaadaptor.liveperson.net","service":"ihubMedalliaAdaptor"},{"account":"75931016","baseURI":"lo.convep.liveperson.net","service":"conversationVep"},{"account":"75931016","baseURI":"server.lon.liveperson.net","service":"openPlatform"},{"account":"75931016","baseURI":"z2.liveper.sn","service":"redirect"},{"account":"75931016","baseURI":"z2.batchelor.liveperson.net","service":"batchelor"},{"account":"75931016","baseURI":"lo.botplatform.liveperson.net","service":"cbWebPlatform"},{"account":"75931016","baseURI":"z2.etool.liveperson.net","service":"etool"},{"account":"75931016","baseURI":"lo.apple-gw.liveperson.net","service":"appleConnector"},{"account":"75931016","baseURI":"lo.le1.liveperson.net","service":"liveEngageUI"},{"account":"75931016","baseURI":"lo.ac.liveperson.net","service":"accountConfigReadWrite"},{"account":"75931016","baseURI":"lo.v-feed.liveperson.net","service":"visitorFeed"},{"account":"75931016","baseURI":"lo.conversationinsights.liveperson.net","service":"bellaInsights"},{"account":"75931016","baseURI":"lo.whatsapp-gw.liveperson.net","service":"whatsappConnector"},{"account":"75931016","baseURI":"lo.intentid.liveperson.net","service":"coreAIFeedback"},{"account":"75931016","baseURI":"dispatch.look.io","service":"mobileChat"},{"account":"75931016","baseURI":"lo.intent.liveperson.net","service":"intentAnalyzer"},{"account":"75931016","baseURI":"lo.nls.liveperson.net","service":"nls"},{"account":"75931016","baseURI":"lo.register.liveperson.net","service":"provisionGW"},{"account":"75931016","baseURI":"lo.shiftstatus.liveperson.net","service":"shiftstatus"},{"account":"75931016","baseURI":"lo.feedbackchute.int.liveperson.net","service":"coreAIFeedbackChuteDomain"},{"account":"75931016","baseURI":"lo.sentinel.liveperson.net","service":"sentinel"},{"account":"75931016","baseURI":"lo.cbllmgateway.int.liveperson.net","service":"cbLlmGatewayInt"},{"account":"75931016","baseURI":"z2.maven.liveperson.net","service":"coreAIMavenHubDomain"},{"account":"75931016","baseURI":"lo.cbnluibc.liveperson.net","service":"cbIbc"},{"account":"75931016","baseURI":"lo.msg-gw.liveperson.net","service":"facebookConnector"},{"account":"75931016","baseURI":"accdn.lpsnmedia.net","service":"acCdnDomain"},{"account":"75931016","baseURI":"lo.cqm-msg.liveperson.net","service":"cqmMsg"},{"account":"75931016","baseURI":"server.lon.liveperson.net","service":"adminArea"},{"account":"75931016","baseURI":"lo.handoff.liveperson.net","service":"outboundConfiguration"},{"account":"75931016","baseURI":"lo0.v.liveperson.net","service":"visitManager"},{"account":"75931016","baseURI":"dispatch.look.io","service":"mobileVisit"},{"account":"75931016","baseURI":"lo.nlp.liveperson.net","service":"nlp"},{"account":"75931016","baseURI":"accdn.lpsnmedia.net","service":"acCdnDomainConsumerSdk"},{"account":"75931016","baseURI":"lo.cbleanalytics.liveperson.net","service":"cbMacsAnalytics"},{"account":"75931016","baseURI":"lo.odin.liveperson.net","service":"odinDomain"},{"account":"75931016","baseURI":"lo.auditlog.liveperson.net","service":"auditLog"},{"account":"75931016","baseURI":"lo.ptscoring.int.liveperson.net","service":"predictiveIntelligentTargeting"},{"account":"75931016","baseURI":"lo0.v.liveperson.net","service":"msdkgw"},{"account":"75931016","baseURI":"lo.orchestratorext.liveperson.net","service":"orchestratorext"},{"account":"75931016","baseURI":"lo-ges-usmsgw.liveperson.net","service":"usmsgwDomain"},{"account":"75931016","baseURI":"z2.acr.liveperson.net","service":"accountConfigReadOnly"},{"account":"75931016","baseURI":"lo.botauthmigration.int.liveperson.net","service":"botAuthMigration"},{"account":"75931016","baseURI":"z2.coapp.liveperson.net","service":"coApp"},{"account":"75931016","baseURI":"lo.automationlookup.int.liveperson.net","service":"coreAIAutomation"},{"account":"75931016","baseURI":"lo.push.liveperson.net","service":"pusher"},{"account":"75931016","baseURI":"z2.bot-connectors.liveperson.net","service":"botConnectorsDomain"},{"account":"75931016","baseURI":"z2.houston.int.liveperson.net","service":"leBackofficeInt"},{"account":"75931016","baseURI":"lo.octopus.liveperson.net","service":"leIntegration"},{"account":"75931016","baseURI":"lo.encryptionmgmt.liveperson.net","service":"encryptionMgmtExtDomain"},{"account":"75931016","baseURI":"lo.pd.liveperson.net","service":"predictiveDialer"},{"account":"75931016","baseURI":"lo.act.liveperson.net","service":"act"},{"account":"75931016","baseURI":"z2.le.liveperson.net","service":"liveEngage"},{"account":"75931016","baseURI":"z2.acc-create.liveperson.net","service":"accountCreation"},{"account":"75931016","baseURI":"lo.fms.liveperson.net","service":"fms"},{"account":"75931016","baseURI":"lo.keyservice.liveperson.net","service":"keyService"},{"account":"75931016","baseURI":"lo.promptlibrary.liveperson.net/lp-promptlibrary-app","service":"promptlibrary"},{"account":"75931016","baseURI":"z2.objectstorage.liveperson.net","service":"swift"},{"account":"75931016","baseURI":"lpcdn.lpsnmedia.net","service":"leCdnDomain"},{"account":"75931016","baseURI":"lo.pcicompliance.liveperson.net","service":"pciCompliance"},{"account":"75931016","baseURI":"lo.bc-intg.liveperson.net/r","service":"cbShortenedUrl"},{"account":"75931016","baseURI":"lo.grcs-gw.liveperson.net","service":"googleRcsConnector"},{"account":"75931016","baseURI":"lo.lp-leadgenerator-web.liveperson.net","service":"leadGenerator"},{"account":"75931016","baseURI":"lo.orchestrator.int.liveperson.net","service":"orchestrator"},{"account":"75931016","baseURI":"z2.loggos.liveperson.net","service":"loggos"},{"account":"75931016","baseURI":"lo.bc-msg.liveperson.net","service":"cbChatService"},{"account":"75931016","baseURI":"lo.msg.liveperson.net","service":"asyncMessagingEnt"},{"account":"75931016","baseURI":"lo0.v.liveperson.net","service":"smt"},{"account":"75931016","baseURI":"z2.visitorfeedv2.liveperson.net","service":"visitorFeedV2"},{"account":"75931016","baseURI":"lo.bc-bot.liveperson.net/botservice-0.1","service":"cbBotService"},{"account":"75931016","baseURI":"lo.connectorscfg.liveperson.net","service":"connectorsConfig"},{"account":"75931016","baseURI":"lo.msg-gw.liveperson.net","service":"smsConnector"},{"account":"75931016","baseURI":"lo.faasui.liveperson.net","service":"faasUI"},{"account":"75931016","baseURI":"lo.data.liveperson.net","service":"leDataReporting"},{"account":"75931016","baseURI":"z2.lpEng.liveperson.net","service":"lpEng"},{"account":"75931016","baseURI":"mcs.liveperson.net","service":"mcs"},{"account":"75931016","baseURI":"lo.faasgw.liveperson.net","service":"faasGW"},{"account":"75931016","baseURI":"lo.data-mng.liveperson.net","service":"rtbf"},{"account":"75931016","baseURI":"lo.msg.liveperson.net","service":"messagingRestApiDomain"},{"account":"75931016","baseURI":"lo.accountinfo.int.liveperson.net","service":"accountInfo"},{"account":"75931016","baseURI":"lo.batchelor.liveperson.net","service":"liveEngageVep"},{"account":"75931016","baseURI":"lo.i.liveperson.net","service":"interactionPlatform"},{"account":"75931016","baseURI":"lo.facade-msg.liveperson.net","service":"facadeMsg"},{"account":"75931016","baseURI":"lo.providersubscription.liveperson.net","service":"subscription"},{"account":"75931016","baseURI":"lo.cobrowse.liveperson.net","service":"coBrowse"},{"account":"75931016","baseURI":"lo.cbnlufacade.liveperson.net","service":"cbNluFacade"},{"account":"75931016","baseURI":"lo.ihubcrmwconfig.liveperson.net","service":"ihubCrmwConfig"},{"account":"75931016","baseURI":"lo.cbfeedback.liveperson.net/lp-cbfeedback-app","service":"cbFeedback"},{"account":"75931016","baseURI":"va.marketplace.liveperson.net","service":"marketplaceDomain"},{"account":"75931016","baseURI":"lo.appmgmtsvc.liveperson.net","service":"appMgmtSvcDomain"},{"account":"75931016","baseURI":"lo.ihubshell.liveperson.net","service":"ihubShell"},{"account":"75931016","baseURI":"lo.idp.liveperson.net","service":"idp"},{"account":"75931016","baseURI":"hub.liveperson.net","service":"launchpadDomain"},{"account":"75931016","baseURI":"lo.realtime.liveperson.net","service":"rtDashboard"},{"account":"75931016","baseURI":"lo.ihubcrmwdata.liveperson.net","service":"ihubCrmwData"},{"account":"75931016","baseURI":"lo.lp-rollover.liveperson.net","service":"rollover"},{"account":"75931016","baseURI":"lo.bc-sso.liveperson.net/le-auth","service":"cbLeIntegrations"},{"account":"75931016","baseURI":"lo.oauthclientmgr.liveperson.net","service":"oauthclientmgr"},{"account":"75931016","baseURI":"lo.messagerouting.liveperson.net","service":"messageRoutingServiceDomain"},{"account":"75931016","baseURI":"bot-platform-api.emea.fs.liveperson.com","service":"thirdPartyBots"},{"account":"75931016","baseURI":"lo.ggl-gw.liveperson.net","service":"googleConnector"},{"account":"75931016","baseURI":"lo.leproxy.liveperson.net","service":"leProxyDomain"},{"account":"75931016","baseURI":"lo.agentvep.liveperson.net","service":"agentVep"},{"account":"75931016","baseURI":"lo.cbllmgateway.liveperson.net","service":"cbLlmGatewayExt"},{"account":"75931016","baseURI":"lo.rfl.liveperson.net","service":"runtimeFormLogic"},{"account":"75931016","baseURI":"lo.lp-msgewt.liveperson.net","service":"msgEwtAPI"},{"account":"75931016","baseURI":"lo.bc-li.liveperson.net/lp-cb-cms","service":"cbPcsManager"},{"account":"75931016","baseURI":"lo-ges-uconn.liveperson.net","service":"uconnDomain"},{"account":"75931016","baseURI":"lo.connect-to-messaging.liveperson.net","service":"connectToMessagingDomain"},{"account":"75931016","baseURI":"lo.cbknowledge.liveperson.net/knowledge-0.1","service":"cbKb"},{"account":"75931016","baseURI":"lo.bc-intg.liveperson.net","service":"cbExternalIntegrations"},{"account":"75931016","baseURI":"lo.ams.liveperson.net","service":"asyncMessaging"},{"account":"75931016","baseURI":"lo.pushsrv.int.liveperson.net","service":"pusherInt"},{"account":"75931016","baseURI":"lo1.agent4matching.liveperson.net","service":"routingMsg"},{"account":"75931016","baseURI":"lo.smmsghistproxy.liveperson.net","service":"socialMsgHistDomain"},{"account":"75931016","baseURI":"lo.agent-activity.liveperson.net","service":"agentActivityDomain"},{"account":"75931016","baseURI":"lo.logingateway.liveperson.net","service":"logingateway"},{"account":"75931016","baseURI":"lo.mtls.liveperson.net","service":"mtlsGateway"},{"account":"75931016","baseURI":"lo.aifeedback.int.liveperson.net","service":"coreAIFeedbackOnlyDomain"},{"account":"75931016","baseURI":"lo.userjoin.liveperson.net","service":"coreAIUserjoin"},{"account":"75931016","baseURI":"lo.bc-mgmt.liveperson.net/service-monitoring-0.1","service":"cbMonitoring"},{"account":"75931016","baseURI":"lo.event-manager.liveperson.net","service":"eventManager"},{"account":"75931016","baseURI":"lo.encryptionmgmt.int.liveperson.net","service":"encryptionMgmtDomain"},{"account":"75931016","baseURI":"server.lon.liveperson.net","service":"mTag"},{"account":"75931016","baseURI":"lo.ihubcrmwexplorer.liveperson.net","service":"ihubCrmwExplorer"},{"account":"75931016","baseURI":"lo.tokenizer.liveperson.net","service":"tokenizer"},{"account":"75931016","baseURI":"server.lon.liveperson.net","service":"ALL"},{"account":"75931016","baseURI":"z2.appkey-mgmnt.liveperson.net","service":"appKeyManagement"},{"account":"75931016","baseURI":"lo.msghist.liveperson.net","service":"msgHist"},{"account":"75931016","baseURI":"lo.content.lpsnmedia.net","service":"staticContent"},{"account":"75931016","baseURI":"lo.pd.int.liveperson.net","service":"predictiveDialerInternal"},{"account":"75931016","baseURI":"lo.viber-gw.liveperson.net","service":"viberConnector"},{"account":"75931016","baseURI":"lo.ootb.liveperson.net","service":"ootb"},{"account":"75931016","baseURI":"lo.le-billing.liveperson.net","service":"leBilling"},{"account":"75931016","baseURI":"lo.line-gw.liveperson.net","service":"lineConnector"},{"account":"75931016","baseURI":"server.lon.liveperson.net","service":"agent"},{"account":"75931016","baseURI":"z2.bi.liveperson.net","service":"leRBMstr"},{"account":"75931016","baseURI":"lo.enghist.liveperson.net","service":"engHistDomain"},{"account":"75931016","baseURI":"lo.lp-marketplacemgmt.liveperson.net","service":"maps"},{"account":"75931016","baseURI":"empty.liveperson.net","service":"otelDomainConsumerSdk"},{"account":"75931016","baseURI":"lo.agentsmartassist.liveperson.net","service":"agentSmartAssist"},{"account":"75931016","baseURI":"z2.connection-panel.liveperson.net","service":"connectionPanel"},{"account":"75931016","baseURI":"lo.smmsgproxy.liveperson.net","service":"socialMsgDomain"},{"account":"75931016","baseURI":"lo.intentid.liveperson.net","service":"coreAIIntent"},{"account":"75931016","baseURI":"lo.codaext.liveperson.net","service":"coda"},{"account":"75931016","baseURI":"lo.workato.liveperson.net","service":"ihubWorkatoIntegration"},{"account":"75931016","baseURI":"lo.agentmng.liveperson.net","service":"agentManagerWorkspace"},{"account":"75931016","baseURI":"lo.bc-platform.liveperson.net/bot-platform-manager-0.1","service":"cbBotPlatform"},{"account":"75931016","baseURI":"z2.bi.liveperson.net","service":"leBiMstr"},{"account":"75931016","baseURI":"auth-z2.liveperson.net","service":"authenticationServiceDomain"},{"account":"75931016","baseURI":"lo.transporter.liveperson.net","service":"transporter"},{"account":"75931016","baseURI":"lo.cbanalytics.liveperson.net","service":"cbAnalytics"},{"account":"75931016","baseURI":"lo.secureformconfig.liveperson.net","service":"secureformconfig"}]});try{window.lpTag=window.lpTag||{};window.lpTag.taglets=window.lpTag.taglets||{};lpTag.taglets.lpSecureStorage=lpTag.taglets.lpSecureStorage||function(e){function t(e){r(e);e&&e.length&&n(e,Kt);var t="function"==typeof lpTag.getEnv&&lpTag.getEnv();Xt=void 0!==Kt.isFetchEnabled?JSON.parse(Kt.isFetchEnabled):"alpha"===t;it=Kt.fetchCacheMode;at=Xt?lpTag.taglets.fetch:lpTag.taglets.jsonp;Zt=Kt.isPartitionCookieEnabled;zt=Kt.browserWhitelist;a();i();rt=qt.getDomain(_t.ACCDN)||null;jt=f(qt.getDomain("leCdnDomain"))}function n(e,t){var n;lpTag.taglets.lpUtil.convertConfig(e,t);(t.periodToDisableFallbackRequestsInDays||"0"===t.periodToDisableFallbackRequestsInDays)&&(n=parseInt(t.periodToDisableFallbackRequestsInDays,10));n>=0&&(Lt=24*n*60*60*1e3)}function r(e){e&&0!==e.length&&e.forEach(function(e){"legacyGetPath"===e.id&&"true"===e.value?Ht=!0:"legacyIframe"===e.id&&"true"===e.value&&(Bt=!0)})}function i(){Jt.bind({eventName:"firstPartyMessage",appName:ot,func:ie})}function a(){var e=lpTag.protocol+"//"+lpTag.csds.getDomain(_t.ACCDN)+"/api/account/"+lpTag.site+"/configuration/setting/accountproperties"+(Xt?"":"/"),t=s();We("_loadSiteSettings called with url: "+e);if($e||t){if(!$e&&t){We("_loadSiteSettings - Account settings network call already in progress"+e);o()}}else{c();at.issueCall({url:e,timeout:5e3,retries:0,callbackName:"accountSettingsCB",allowDuplicateCallbackNames:"true",credentials:Xt?"omit":void 0,cache:Xt&&it?it:void 0,success:function(e){var t=Xt?e&&e.body:e;l(t,!0)},error:function(){p(!0)}})}}function o(){var e=lpTag.events.hasFired("*","receivedAccountSettings"),t=lpTag.events.hasFired("*","receivedAccountSettingsFailed");e.length<1?Jt.once({appName:"*",eventName:"receivedAccountSettings",func:function(e){l(e,!1)}}):l(e[0].data,!1);t.length<1?Jt.once({appName:"*",eventName:"receivedAccountSettingsFailed",func:function(e){p(e,!1)}}):p(t[0].data,!1)}function s(){return Jt.hasFired("*","requestedAccountSettings").length>0}function c(){Jt.trigger({appName:"*",eventName:"requestedAccountSettings",data:{}})}function u(){if(Je())Ke("_enableFirstParty: cross-domain feature is on - continue with the defaults");else{Ke("_enableFirstParty: cross-domain feature is off - force first party storage");et=!0}}function l(e,t){if(e&&Array.isArray(e)&&!e.error){We("_loadSiteSettings - got configuration: "+JSON.stringify(e));$e=e;et=d(Ut.FIRST_PARTY_STORAGE,"true");var n=lpTag.device&&lpTag.device.browserName()&&lpTag.device.browserName().toLowerCase();if(et)if(Je()||zt&&zt.length&&zt.indexOf(n)<0){Ke(Je()?"_receivedAccountsSettings: cross-domain activated - disabling first party storage":"_receivedAccountsSettings: firstPartyStorageFeature disabled for current browser");et=!1}else{Ke(zt?"_receivedAccountsSettings: firstPartyStorageFeature enabled for current browser":"_receivedAccountsSettings: firstPartyStorageFeature enabled for all browsers");tt=T(Ut.FIRST_PARTY_STORAGE);nt=g(Ut.FIRST_PARTY_STORAGE)}else u()}else{We("_loadSiteSettings - NO CONFIGURATION FOUND");$e=[];u()}O();t&&Jt.trigger({appName:"*",eventName:"receivedAccountSettings",data:e})}function p(e){Be("Loading siteSettings: "+lpTag.site+" failed.");$e=[];u();O();e&&Jt.trigger({appName:"*",eventName:"receivedAccountSettingsFailed",data:{}})}function f(e){return e.indexOf("dev.lprnd.net")>0?location.hostname===e?!0:e.indexOf("qtvr")>0||e.indexOf("lp-cdn-qa")>0?!1:!1:"lpcdn-a.lpsnmedia.net"===e?!1:"lpcdn.lpsnmedia.net"===e?!1:!0}function d(e,t){var n=$e.filter(function(t){return t.id===e}),r=n&&n.length>0&&n[0].propertyValue&&n[0].propertyValue.value;return r&&r===t}function g(e){var t=$e.filter(function(t){return t.id===e});return t.length&&t[0].modifiedDate&&new Date(t[0].modifiedDate)}function T(e){var t=$e.filter(function(t){return t.id===e});return t.length&&t[0].createdDate&&new Date(t[0].createdDate)}function S(e){e=De(e);return e&&It[e]?It[e]:It}function y(e){I(e);e.type=Ct.GET;P(e)}function m(e){I(e);e.type=Ct.MULTIGET;P(e)}function v(e){if(!e||-1!==e.expires&&-1!==e.ttl){e.type=Ct.SET;P(e)}else h(e)}function E(e){I(e);e.type=Ct.TOUCH;P(e)}function h(e){if(e){e.ttl=-1;e.expires=-1}e.type=Ct.REMOVE;P(e)}function R(e){var t,n;if(xt){e&&e.debug===!0&&(vt=!0);for(var r in e)if("object"==typeof e[r]&&e.hasOwnProperty(r)&&e[r].site){e[r].app||(e[r].app=Pt);Wt[e[r].app]||(Wt[e[r].app]=e[r]);if(e[r].url&&0===e[r].url.indexOf("http")){var i=k(e[r]);We("Configuring url "+e[r].url);t=De(e[r].url);i&&(t=Nt.FIRSTPARTYSTORAGE);if(ft[t])if(It[t]&&It[t][e[r].app])Se(e[r].chosenStorageHandler,It[t][e[r].app]);else{he(t,e[r].app,e[r].chosenStorageHandler);b(e[r],t)}else{he(t,e[r].app,e[r].chosenStorageHandler);n=N(e[r],t);ve(e[r],n,t)}}else e[r].url===ct&&me(e[r])}}else $t.push(R.bind(this,e))}function O(){if(Je())A(function(){xt=!0;C($t);C(tn);C(en)});else{xt=!0;C($t);C(tn);C(en)}}function A(e){if(document.querySelector("#lp-origin-trial-loader"))e();else{var t=document.createElement("script");t.id="lp-origin-trial-loader";t.src="https://"+qt.getDomain("leCdnDomain")+"/le_secure_storage/"+st+"/lp-origin-trial.min.js";document.head.appendChild(t);t.onload=function(){e()};t.onerror=function(){e()}}}function C(e){for(;e&&e.length;)e.shift()()}function N(e,t){var n=Qt&&et&&Qe()?Nt.LOCALSTORAGE:e.initialStorageType;return{type:Ct.SELECT_STORAGE,app:e.app,domain:t,site:e.site,initialStorageType:n,force:e.force,duplicate:e.duplicate,firstParty:e.firstParty,error:e.error}}function b(e,t){P(N(e,t))}function I(e){if(e&&e.value){e.value=null;delete e.value}return e}function k(e){return!e.duplicate&&(et||e.force)&&e.firstParty}function F(e){var t=e.firstParty;if("undefined"==typeof t){var n=Wt[e.app];n&&!n.disableFirstPartyGlobalConfig&&(t=n.firstParty)}return!e.duplicate&&(et||e.force)&&t}function G(e){We("DUPLICATED REQUEST: "+e)}function P(e){var t=De(e.domain),n=F(e),r=lpTag.taglets.lpUtil&&lpTag.taglets.lpUtil.clone(e)||{};e.success&&(r.success=G.bind(this,"SUCCESS"));e.error&&(r.error=G.bind(this,"ERROR"));if(xt){if(n&&t!==Nt.FIRSTPARTYSTORAGE&&e.domain!==ct){var i=t;t=Nt.FIRSTPARTYSTORAGE;if(Ct.SET===e.type||Ct.TOUCH===e.type||Ct.REMOVE===e.type)_()&&w(e,r);else if(Ct.GET===e.type||Ct.MULTIGET===e.type){r.success=e.success;r.error=e.error;if(!e.bound){e.bound=!0;e.success=U.bind(this,r.success,r,i,!1);e.error=U.bind(this,r.error,r,i,!0)}}}else et||Ct.GET!==e.type&&Ct.MULTIGET!==e.type||e.domain===ct||jt||!e.firstParty&&!e.clearFirst||_()&&D(e,r);e.app||(e.app=Pt);if(M(e,t))e.alreadyConfigured&&e.error?Se(e.error,"Could not configure storage",e.keys||e.key):R(V(e));else{L(e,t)&&(e.alreadyConfigured=!0);q(e,t)}}else en.push(P.bind(this,e))}function w(e,t){t.firstParty=!1;t.duplicate=!0;if(e.expires&&-1!==e.expires&&e.expires>60*Vt){e.expires=Vt;t.expires=Vt}if(e.ttl&&-1!==e.ttl&&e.ttl>60*Vt*1e3){e.ttl=1e3*Vt;t.ttl=1e3*Vt}Ct.SET===e.type?v(t):Ct.TOUCH===e.type?E(t):Ct.REMOVE!==e.type||e.forceFirst||h(t)}function D(e,t){t.firstParty=!0;t.force=!0;t.forceFirst=!0;if(Ct.MULTIGET===e.type)for(var n=0;n<e.keys.length;n++){t.type=Ct.REMOVE;t.key=e.keys[n];h(t)}else{t.type=Ct.REMOVE;h(t)}}function _(){var e=nt||tt,t=lpTag.taglets.lpSecureStorage.isStepUpEnabled;return t||!e||Math.abs(Mt-e.getTime())<Lt}function U(e,t,n,r,i){var a=!1;t.type===Ct.MULTIGET&&"object"==typeof i&&(a=x(i));if(i&&!a)Se(e,i);else if(_()){var o=t.error;t.firstParty=!1;t.domain=n;t.url=n;t.error=function(t){r?Se(o,t):Se(e,i)};y(t)}else Se(e,i)}function x(e){for(var t in e)if(null!==e[t])return!1;return!0}function L(e,t){var n=dt[t]&&dt[t].filter(function(t){return t.type===Ct.SELECT_STORAGE&&t.app===e.app}.bind(this)),r=Y(e,t),i=e.type===Ct.SELECT_STORAGE||r||n&&n.length>0;return i}function M(e,t){var n=L(e,t),r=!(!It[t]||!It[t][e.app]);return!n&&!r}function Y(e,t){if(gt)for(var n in gt)if(gt.hasOwnProperty(n)&&gt[n].type===Ct.SELECT_STORAGE&&gt[n].domain===t&&gt[n].app===e.app)return!0;return!1}function V(e){var t={};t[e.app]={site:e.site,app:e.app,url:e.domain,initialStorageType:e.initialStorageType,chosenStorageHandler:P.bind(this,e),firstParty:e.firstParty,force:e.force,duplicate:e.duplicate,env:je()};"function"==typeof e.error&&(t[e.app].error=e.error);return t}function q(e,t){var n=e.domain===ct,r=F(e);if(r){e.url=e.domain||t;t=Nt.FIRSTPARTYSTORAGE;e.domain=Nt.FIRSTPARTYSTORAGE}n?j(e):Dt.get(t)?z(e,t):X(e,t)}function J(){lpTag.storageMethods&&!Ze&&(Ze=lpTag.storageMethods);return Ze?Ze.isSessionStorageEnabled():!1}function j(e){var t,n;if(J())switch(e.type){case Ct.GET:case Ct.MULTIGET:n=W(e);Se(e.success,n,e.keys||e.key);break;case Ct.SET:t=""+e.site+e.key;K(t,e);Se(e.success,e.value,e.key);break;case Ct.TOUCH:n=B(""+e.site+e.key,e);Se(n?e.success:e.error,n?n:{error:"No data to touch"},e.key);break;case Ct.REMOVE:t=""+e.site+e.key;n={error:"Object not found."};Q(t,e)&&(n=void 0);Se(n&&n.error&&e.error?e.error:e.success,n&&n.error||n,e.key)}else Se(e.error||e.success,{error:"SessionStorage is not active",code:500},e.key)}function H(e){var t=Ze.getSessionData(e);try{t=""===t?"":JSON.parse(t)}catch(n){}return""!==t?t:null}function B(e,t){var n=H(e);t.appName&&null!==n&&"object"==typeof n&&(n=n[t.appName]);return""!==n?n:null}function W(e){var t,n,r=!1,i=!1,a={};if(e.keys&&Array.isArray(e.keys)){r=!0;t=e.keys}else t=[e.key];t.forEach(function(t){n=B(""+e.site+t,e);if(n){a[t]=n;i=!0}});a=i?r?a:a[t[0]]:null;return a}function K(e,t){var n=H(e);null===n&&(n={});if("object"==typeof n){n[t.appName]=t.value;return Ze.setSessionData(e,Te(n))}return!1}function Q(e,t){var n=!1,r=!1,i=H(e);if(null!==i&&"object"==typeof i&&i.hasOwnProperty(t.appName)){i[t.appName]=null;delete i[t.appName];for(var a in i)if(i.hasOwnProperty(a)){r=!0;break}n=!0}return n&&r?Ze.setSessionData(e,Te(i)):n?Ze.removeSessionData(e):!1}function X(e,t){var n;if(e&&((e.success||e.error)&&(e.key||e.keys)&&e.appName||e.type===Ct.SELECT_STORAGE)&&e.domain&&e.site)if(ut)if(ft[t]){n=e.app&&It[t]&&It[t][e.app];if(n&&e.type===Ct.SELECT_STORAGE){ue(e.domain,e.app,n);pe(e.domain)}else if(!n||n&&!n.error){qe(e);xe(e);We("Made request for key: "+e.key+" appName: "+e.appName)}else{Se(e.error||e.success,null,e.key);We("No Storage Selected, Blocked request for key: "+e.key+" appName: "+e.appName)}}else ve(e,e,t);else lt.push(function(){P(e)})}function z(e,t){yt[t]="undefined"==typeof yt[t]?[]:yt[t];yt[t].push(e)}function Z(){var e,t=(new Date).getTime(),n=!1;if(ze){clearTimeout(ze);ze=null}for(var r in gt)if(gt.hasOwnProperty(r)){e=0;e=t-gt[r].startTime;if(e>=ht){Be("iFrame not responding in time to requests, domain: "+gt[r].domain);le(r,gt[r].key,null,!0)}else n=!0}$(n)}function $(e){e&&!ze&&(ze=setTimeout(Z,Rt))}function ee(e,t){Tt[e]=t?"undefined"==typeof Tt[e]?1:Tt[e]+1:0;We("Domain "+e+" error count: "+Tt[e],"_manageErrorState");Tt[e]>Ot&&Ce(yt[e],e,"iFrame not responding in time to requests")}function te(e){if(ft[e]&&ft[e].parentNode){ft[e].parentNode.removeChild(ft[e]);ft[e]=null;delete ft[e];Tt[e]=0;Be("Removed iFrame for domain","_removeIFrame")}}function ne(){document.body?Ye():setTimeout(ne,0)}function re(e){e&&e.data&&St[e.origin]&&oe(e.data,e.origin)}function ie(e){We("firstParty message triggered from client");e&&e.data&&oe(e.data,Nt.FIRSTPARTYSTORAGE)}function ae(e){gt[e]=null;delete gt[e]}function oe(e,t){var n,r,i,a,o;if("string"==typeof e){a=ge(e);if(a){n=a.id;r=a.key||a.keys;i="undefined"!=typeof a.value?a.value:a.error;if(Ft===r){se(a,t);o=De(t);le(n,r,i,!!a.error,o)}else{le(n,r,i,!!a.error);We("Got result for key: "+r+" appName: "+a.appName)}}}}function se(e,t){var n,r;if(!e.app){if(gt){for(var i in gt)if(gt.hasOwnProperty(i)&&ce(t,gt[i])){n=gt[i].app;r=i;break}r&&ae(r)}if(dt&&!r)for(var a in dt){dt.hasOwnProperty(a)&&a===t&&Array.isArray(dt[a])&&dt[a].every(function(e,i){if(ce(t,e)){n=e.app;r=i;return!1}return!0});if("undefined"!=typeof r){dt[a].splice(r,1);break}}e.app=n||Pt}It[t]=It[t]||{};It[t][e.app]=e.value;We("Got storage type: "+e.value+" for origin: "+t+" appName: "+e.appName);ue(t,e.app,e.value)}function ce(e,t){return t.type!==Ct.SELECT_STORAGE||t.domain!==e||t.app!==Pt&&t.app!==wt?!1:!0}function ue(e,t,n){if(kt[e]&&kt[e][t]&&kt[e][t].length>0){kt[e][t].forEach(function(e){Se(e,n)});kt[e][t]=[]}}function le(e,t,n,r,i){var a=fe(e),o=i||a&&De(a.domain);a&&de(a,n,t,r);e&&ae(e);Dt.set(!1,o);ee(o,r);pe(o)}function pe(e){yt[e]&&yt[e].length>0&&P(yt[e].shift())}function fe(e){return e&&gt[e]?gt[e]:void 0}function de(e,t,n,r){r?Se(e.error||e.success,t,n):Se(e.success,t,n)}function ge(e){try{e=decodeURIComponent(e);e=JSON.parse(e)}catch(t){}return e}function Te(e){var t,n;if("function"==typeof Array.prototype.toJSON){n=Array.prototype.toJSON;delete Array.prototype.toJSON;try{t=JSON.stringify(e)}catch(r){Array.prototype.toJSON=n;throw r}Array.prototype.toJSON=n}else t=JSON.stringify(e);return t}function Se(e,t,n){if("function"==typeof e)try{e(t,n)}catch(r){}}function ye(t,n,r){e.addEventListener?t.addEventListener(n,r,!1):t.attachEvent("on"+n,r)}function me(e){var t={app:e.app,value:"NONE"};he(ct,e.app,e.chosenStorageHandler);if(J()){ft[ct]=!0;t.value=Nt.STATICSESSIONSTORAGE}se(t,ct)}function ve(e,t,n){var r,i=e.url||e.domain,a=e.site,o=k(e);n=n||De(i);if(xt){if(!ft[n])if(dt[n])Ee(n,t);else if(o){We("Attaching first party methods: "+i+" domain: "+n);r=Oe();St[Nt.FIRSTPARTYSTORAGE]=!0;r.setAttribute("src",Fe(i,a,e));dt[Nt.FIRSTPARTYSTORAGE]=[];Ee(Nt.FIRSTPARTYSTORAGE,t);ut?Ae(Nt.FIRSTPARTYSTORAGE,r)():pt.push(Ae(Nt.FIRSTPARTYSTORAGE,r))}else{We("Attaching iFrame: "+i+" domain: "+n);r=Re();St[n]=!0;r.setAttribute("src",ke(i,a,e));dt[n]=[];Ee(n,t);ut?Ae(n,r)():pt.push(Ae(n,r))}return r}tn.push(ve.bind(this,e,t,n))}function Ee(e,t){t&&dt[e].push(t)}function he(e,t,n){if(n){kt[e]=kt[e]||{};kt[e][t]=kt[e][t]||[];kt[e][t].push(n)}}function Re(){var e=document.createElement("iframe"),t=e.style,n="lpSS_"+Math.floor(9e10*Math.random()),r={tabIndex:"-1","aria-hidden":"true",role:"presentation",title:"Intentionally blank",name:Kt&&Kt.useStaticID?"lpSS_iframe":n,id:Kt&&Kt.useStaticID?"lpSS_iframe":n};t.width="0px";t.height="0px";t.position="absolute";t.top="-1000px";t.left="-1000px";t.display="none";for(var i in r)r.hasOwnProperty(i)&&e.setAttribute(i,r[i]);return e}function Oe(){var e=document.createElement("script");e.id="lpSS_"+Math.floor(9e10*Math.random());return e}function Ae(e,t){return function(){var n=setTimeout(function(){Ce(dt[e],e,"unable to load iFrame for key")},Et);ye(t,"load",function(){be(t,e,n)});document.body.appendChild(t)}}function Ce(e,t,n){for(;e.length>0;){var r=e.shift();r.error&&setTimeout(Ne(r.error,n||{error:n,key:r.key},r.key),0)}te(t)}function Ne(e,t,n){return function(){Se(e,t,n)}}function be(t,n,r){r&&clearTimeout(r);ft[n]=t.tagName&&"script"===t.tagName.toLowerCase()?{contentWindow:e}:t;We("Loaded frame "+n);Ie(n)}function Ie(e){We("Running pending request for frame "+e);if(dt[e]){for(;dt[e].length>0;)P(dt[e].shift());dt[e]=null;delete dt[e]}}function ke(e,t,n){var r,i,a,o;if(e&&"string"==typeof e){i=je();a=Pe(n);e=Ge(e,n);r=0<location.port.length?":"+location.port:"";o=e+"/"+a+"?loc="+encodeURIComponent(location.protocol+"//"+location.hostname+r)+"&site="+encodeURIComponent(t)+(n.initialStorageType?"&ist="+encodeURIComponent(n.initialStorageType):"")+(n.force?"&force=1":"")+(i?"&env="+encodeURIComponent(i):"")+(Je()?"&isCrossDomain=true":"")+(rt?"&accdn="+encodeURIComponent(rt):"")+(Xt?"&isFetchEnabled=true":"")+(it?"&fetchCacheMode="+encodeURIComponent(it):"")+(Zt?"&isPartitionCookieEnabled=true":"")}return o}function Fe(e,t,n){var r,i,a,o;if(e&&"string"==typeof e){i=je();a=we(n);e=Ge(e,n);r=0<location.port.length?":"+location.port:"";o=e+"/"+a+"?loc="+encodeURIComponent(location.protocol+"//"+location.hostname+r)+"&site="+encodeURIComponent(t)+(n.initialStorageType?"&ist="+encodeURIComponent(n.initialStorageType):"")+(n.force?"&force=1":"")+(i?"&env="+encodeURIComponent(i):"")+(Je()?"&isCrossDomain=true":"")+(rt?"&accdn="+encodeURIComponent(rt):"")+(Xt?"&isFetchEnabled=true":"")+(it?"&fetchCacheMode="+encodeURIComponent(it):"")+(Zt?"&isPartitionCookieEnabled=true":"")}return o}function Ge(e){var t,n,r=e.lastIndexOf("/");if(r>8)n=e.substr(0,r);else{t=e.indexOf("?");t>0&&(n=e.substr(0,t))}n||Ht||(n=e);(!n||""===n||n.indexOf(st)<0&&n.indexOf("/base/test/resources")<0)&&(n="https://"+qt.getDomain("leCdnDomain")+"/le_secure_storage/"+st);return n}function Pe(){var e="storage.secure.min.html";vt?e="storage.html":Bt&&(e="storage.min.html");return e}function we(){var e;e=vt?"storage.secure.js":"storage.secure.min.js";return e}function De(e){var t,n,r=null;if(e===Nt.STATICSESSIONSTORAGE)r=e;else{if(e===Nt.FIRSTPARTYSTORAGE)return e;t=new RegExp(/(http{1}s{0,1}?:\/\/){0,1}([^\/\?]+)(\/?)/gi);n=t.exec(e);n&&n.length>=3&&""!==n[2]&&(r=n[1]+n[2].toLowerCase())}return r}function _e(e){var t={};t.id=e.id;e.key?t.key=e.key:e.keys&&(t.keys=e.keys);t.site=e.site;t.appName=e.appName||"*";t.type=e.type;if(e.type===Ct.SELECT_STORAGE){t.initialStorageType=e.initialStorageType;t.force=e.force}isNaN(e.ttl)||(t.ttl=e.ttl);isNaN(e.expires)||(t.expires=e.expires);e.app&&(t.app=e.app);if("undefined"!=typeof e.value){t.value=e.value;t.locations=Ue(e.locations)}return t}function Ue(e){e=e?e.constructor===Array?e:[e]:[];e.push(document.location.hostname);return e}function xe(e){var t,n=De(e.domain);if(ft[n]){e.startTime=(new Date).getTime();t=_e(e);Dt.set(!0,n);Le(t,n);$(!0)}}function Le(e,t){ft[t]&&(t===Nt.FIRSTPARTYSTORAGE?lpTag.isUnauthExternalWindow||Jt.trigger({appName:Yt,eventName:"firstPartyMessage",data:{data:Me(e)}}):ft[t].contentWindow.postMessage(Me(e),t))}function Me(e){try{e=Te(e);e=encodeURIComponent(e)}catch(t){}return e}function Ye(){ut=!0;for(;pt.length>0;)try{pt.shift()()}catch(e){}for(;lt.length>0;)try{lt.shift()()}catch(e){}}function Ve(){mt++;mt>2e4&&(mt=0);return"k"+mt+(new Date).getTime()+parseInt(100*Math.random(),10)}function qe(e,t){e.id=t?t:Ve();"undefined"!=typeof e.value&&(e.type=Ct.SET);gt[e.id]=e}function Je(){return lpTag.features&&"function"==typeof lpTag.features.getFeature&&lpTag.features.getFeature(Gt)}function je(){return"function"==typeof lpTag.getEnv&&lpTag.getEnv()}function He(t,n){e.lpTag&&lpTag.log&&lpTag.log(t,n,ot)}function Be(e){He(e,At.ERROR)}function We(e){He(e,At.DEBUG)}function Ke(e){He(e,At.INFO)}function Qe(){var e=lpTag.device&&lpTag.device.osName(),t=lpTag.device&&lpTag.device.browserName(),n="iOS"===e,r="Safari"===t;return n&&r}function Xe(){return!!et}var ze,Ze,$e,et,tt,nt,rt,it,at,ot="lpSecureStorage",st="3.30.1-release_1430893787",ct="STATICSESSIONSTORAGE",ut=!1,lt=[],pt=[],ft={},dt={},gt={},Tt={},St={},yt={},mt=0,vt=!1,Et=7e3,ht=5e3,Rt=1e3,Ot=10,At={ERROR:"ERROR",DEBUG:"DEBUG",INFO:"INFO"},Ct={SET:"set",GET:"get",MULTIGET:"multiget",REMOVE:"remove",TOUCH:"touch",SELECT_STORAGE:"selectStorage"},Nt={LOCALSTORAGE:"localStorage",SESSIONSTORAGE:"sessionStorage",INDEXEDDB:"indexedDB",COOKIE:"secureSessionCookie",STATICSESSIONSTORAGE:ct,FIRSTPARTYSTORAGE:"firstPartyStorage"},bt={STORAGE:"storage_error"},It={},kt={},Ft="SecureStorageClient/storageType",Gt="Common.LiveEngage_2_CrossDomainStorage",Pt="default",wt="cobrowse",Dt={set:function(e,t){t&&(this[t]=e)},get:function(e){return e?this[e]:void 0}},_t={ACCDN:"acCdnDomainConsumerSdk"},Ut={FIRST_PARTY_STORAGE:"unified.window.allow.first.party.storage"},xt=!1,Lt=12096e5,Mt=(new Date).getTime(),Yt="SecureStorageClient",Vt=31536e3,qt=lpTag.csds,Jt=lpTag.events,jt=!1,Ht=!1,Bt=!1,Wt={},Kt={},Qt=!1,Xt=!1,zt=[],Zt=!1,$t=[],en=[],tn=[];ye(e,"message",re);ne();if(lpTag.isUnauthExternalWindow){et=!1;O()}return{storageTypes:Nt,getStorageType:S,getValue:y,getValues:m,setValue:v,touchValue:E,removeValue:h,configure:R,sessionStorageStaticDomain:ct,errorTypes:bt,v:st,name:ot,init:t,inspect:function(){var e={};for(var t in ft)ft.hasOwnProperty(t)&&(e[t]={url:t,storageType:It[t]});return{name:ot,version:st,configuredFrames:e,config:Kt}},isFirstPartyStorageFeatureEnabled:Xe}}(window);}catch(e){lpTag.handleGeneralError("lpSecureStorage",e);}try{window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.sdeInfoScraper=lpTag.taglets.sdeInfoScraper||function(){function e(e){G=[];if(e)for(var t=0;t<e.length;t++){var n=e[t].value;if("string"==typeof n&&""!==n){n=JSON.parse(n);n&&G.push(n)}}0===G.length&&L("Structure error: config object is invalid",_.ERROR)}function t(){"object"==typeof G&&G.length>0&&s()}function n(){c();d()}function o(t){n();e(t)}function r(e){var t=A(e.sde);for(var n in e.scrapedInfo)t=null===e.scrapedInfo[n]?t.replace(new RegExp('"(\\\\"|[^"])*{\\{'+n+'\\}}(\\\\"|[^"])*"',"gi"),null):t.replace(new RegExp("\\{\\{"+n+"\\}\\}","gi"),e.scrapedInfo[n]);return JSON.parse(t)}function a(){return{_v:U,_name:V,scrapersConfigArr:G}}function i(){P=!0}function d(){for(;$.length>0;){var e=$.pop();clearTimeout(e)}}function c(){u(window,"load","onload",y);u(document,"DOMContentLoaded","onreadystatechange",S)}function f(e,t,n,o){e.addEventListener?e.addEventListener(t,o,!1):e.attachEvent&&e.attachEvent(n,o)}function u(e,t,n,o){e.removeEventListener?e.removeEventListener(t,o,!1):e.detachEvent(n,o)}function l(e){if("object"==typeof e){for(var t in B)B.hasOwnProperty(t)&&!e.hasOwnProperty(t)&&(e[t]=B[t]);return e}L("Structure error: def object is invalid",_.ERROR)}function s(){p("asap");h();v();g()}function p(e){for(var t=0;t<G.length;t++)try{if(G[t].def.when===e||"undefined"==typeof G[t].def.when&&e===B.when){G[t].def=l(G[t].def);G[t].dataChanged=!1;G[t].scrapedInfo={};m(G[t])}}catch(n){L("Failed to scrape data for configuration id: "+t+". Error: "+n,_.ERROR)}}function g(){"complete"===document.readyState?p("load"):f(window,"load","onload",y)}function y(){p("load")}function h(){if(document.body)p("body");else{var e=setTimeout(h,5);$.push(e)}}function v(){P?p("domContent"):f(document,"DOMContentLoaded","onreadystatechange",S)}function S(){p("domContent")}function m(e){e=w(e);e.def.retry-=1;N(e);if(!J(e.lookup)&&e.def.retry>0){var t=setTimeout(R(e),e.def.delay);$.push(t)}}function R(e){return function(){m(e)}}function w(e){if(e.lookup){for(var t in e.lookup)if(!e.lookup[t].scraped)if(e.lookup[t].length&&e.lookup[t].constructor===Array)for(var n=0;n<e.lookup[t].length&&!e.lookup[t].scraped;n++)E(e,e.lookup[t][n],t);else E(e,e.lookup[t],t);return e}L("Structure error: lookup object is invalid",_.ERROR)}function E(e,t,n){e.scrapedInfo[n]=O(t);if("undefined"!=typeof e.scrapedInfo[n]&&""!==e.scrapedInfo[n]){e.dataChanged=!0;e.lookup[n].scraped=!0;e.scrapedInfo[n]=D(t.onFound,e.scrapedInfo[n])}else e.scrapedInfo[n]="undefined"!=typeof t.defaultVal?t.defaultVal:null}function O(e){if(e){var t;e.query?t=k(e.query,e.attrValue):e.id?t=k("#"+e.id,e.attrValue):e.classN?t=k("."+e.classN,e.attrValue):e.meta?t=b(e):e.jVar?t=j(window,e.jVar):e.sessStg?M.isSessionStorageEnabled()&&(t=M.getSessionData(e.sessStg)||null):e.lclStg?M.isLocalStorageEnabled()&&(t=M.getPersistentData(e.lclStg)||null):e.cookieStg?t=F.readCookie(e.cookieStg):e.search&&(t=q[e.search]);t=C(t,e.cleanup);return t}}function I(){var e,t,n=window.location.search,o={};e=n.substr(1).split("&");for(var r=0;r<e.length;r++)if(e[r].indexOf("=")>-0){t=e[r].split("=");2==t.length&&(o[decodeURIComponent(t[0])]=decodeURIComponent(t[1]))}return o}function k(e,t){var n,o=document.querySelector(T(e));if(o){n=t?o.getAttribute(t):o.innerText||o.textContent;n&&(n=n.replace(/^\s+|\s+$/g,""))}return n}function T(e){e=e.replace(/\.(\d\w+)(?![^[]*\])/g,'[class="$1"]');e=e.replace(/#(\d\w+)(?![^[]*\])/g,'[id="$1"]');return e}function b(e){var t,n=e.meta;t=e[n]&&""!==e[n]?"meta["+n+'="'+e[n]+'"]':"meta["+n+"]";return k(t,e.attrValue)}function C(e,t){if(e)try{return e.replace(new RegExp(t,"g"),"")}catch(n){L("Invalid cleanup regex object",_.ERROR);return e}}function N(e){if(x(e)){var t=r(e);t=D(e.def.beforeSend,t);lpTag.sdes.send(t,function(){L("infoScraper::send::lpSMT.send success for: "+t.toString(),_.DEBUG)});e.dataChanged=!1;L("scraperInfo: "+A(t),_.DEBUG)}}function x(e){var t=!1;if(e.dataChanged){var n=J(e.lookup);n?t=!0:e.def.sendRetry?t=!0:e.def.sendIncomplete&&!n&&e.def.retry<=0&&(t=!0)}return t}function D(e,t){e=e||{};var n=j(window,e.path),o=window,r=t;e.context&&(o=j(window,e.context));if("function"==typeof n&&t)try{r=n.call(o,t);L("Called: "+e.path+" _externalTransform",_.DEBUG)}catch(a){L("Error when calling "+e.path+" _externalTransform",_.ERROR)}else L("Method not found "+e.path+" _externalTransform",_.DEBUG);return r}function j(e,t,n){var o,r=e;if("string"==typeof t){o=t.split(".");for(var a=0;a<o.length;a++){if("undefined"==typeof r||null===r||"undefined"==typeof r[o[a]]||null===r[o[a]]){r="undefined"!=typeof n?n:void 0;break}r=r[o[a]]}}else L("Empty path sent to lookup _getPropertyFromObject",_.INFO);return r}function A(e){var t;if("function"==typeof Array.prototype.toJSON){var n=Array.prototype.toJSON;delete Array.prototype.toJSON;try{t=JSON.stringify(e)}catch(o){Array.prototype.toJSON=n;throw o}Array.prototype.toJSON=n}else t=JSON.stringify(e);return t}function J(e){for(var t in e)if(!e[t].scraped)return!1;return!0}function L(e,t){lpTag.log(e,t,"INFO_SCRAPER")}var U="1.6.1",V="sdeInfoScraper",F=lpTag.cookieMethods,M=lpTag.storageMethods,_={ERROR:"ERROR",INFO:"INFO",DEBUG:"DEBUG"},B={retry:5,delay:1e3,when:"asap"},G=[],P=!1,q=I(),$=[];"complete"===document.readyState||"loaded"===document.readyState||"interactive"===document.readyState?i():f(document,"DOMContentLoaded","onreadystatechange",i);return{version:U,name:V,init:e,start:t,stop:n,reinit:o,restart:t,getSdeObj:r,inspect:a}}();}catch(e){lpTag.handleGeneralError("sdeInfoScraper",e);}try{window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.lp_sdes=lpTag.taglets.lp_sdes||function(){function e(){var e=lpTag.sdes;lpTag.sdes=lpTag.taglets.lp_sdes;if("undefined"!=typeof e&&e.length)for(var n=0;n<e.length;n++)t(e[n])}function t(e){if("undefined"!=typeof e){"undefined"==typeof e.length&&(e=[e]);for(var t=0;t<e.length;t++)if("object"==typeof e[t]&&e[t].type){var n=s(e[t].type);if("undefined"!=typeof n){n.push(e[t]);f[e[t].type]=n}else f[e[t].type]=[e[t]];d("Added sde type: "+e[t].type);lpTag.events.trigger(o,"VAR_ADDED",e[t])}else g("sde: "+JSON.stringify(e[t])+" is not an Object");lpTag.taglets.lp_monitoringSDK.sdes.push(e)}else g("Called push with no sde")}function n(e,n,s){"undefined"!=typeof e&&t(e);p("called send with sdes: "+JSON.stringify(e),"DEBUG");return lpTag.taglets.lp_monitoringSDK.send(n,s)}function s(e){return e?f[e]:f}function l(){f={};d("sdes store was reset")}function i(){l()}function p(e,t){window.lpTag&&lpTag.log&&lpTag.log(e,t,o)}function g(e){p(e,"ERROR")}function d(e){p(e,"INFO")}var o="lp_sdes",a="3.4.0",f={};return{v:a,name:o,init:e,get:s,push:t,send:n,reset:l,reinit:i,inspect:function(){return{store:s()}}}}();}catch(e){lpTag.handleGeneralError("lp_sdes",e);}try{window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.scraper=lpTag.taglets.scraper||function(){function e(e){if(e)for(var a=0;a<e.length;a++)"object"==typeof e[a]&&(h[e[a].id]=e[a].value);S=h&&("true"===h.isFetchEnabled||h.isFetchEnabled===!0);T=h&&h.fetchCacheMode;f=S?lpTag.taglets.fetch:lpTag.taglets.jsonp}function a(){f.issueCall({url:lpTag.protocol+"//"+lpTag.csds.getDomain(v.ACCDN)+"/api/account/"+lpTag.site+"/configuration/le-campaigns/zones?fields=id&fields=zoneValue",callbackName:"lpZonesStaticCB",credentials:S?"omit":void 0,cache:S&&T?T:void 0,success:function(e){var a=S?e&&e.body:e;z=a;lpTag.events.trigger("SCRAPER","ZONES_LOADED",z);s()},error:function(){lpTag.log("Loading elements list for scraper failed","ERROR","SCRAPER")}})}function n(){i()}function t(){s()}function c(e){for(var a=0;a<z.length;a++)if(z[a].id===e)return z[a].zoneValue;return null}function r(e,a,n){for(var t=0;t<z.length;t++)if(z[t].id===e){z[t].queuedSpecializedScrapes||(z[t].queuedSpecializedScrapes=[]);z[t].queuedSpecializedScrapes.push({specialization:a,callback:n})}}function l(){return{config:h,zones:z}}function i(){for(var e=0;e<z.length;e++)z[e].scraped=!1}function s(){var e=u();o(e);lpTag.isDom||setTimeout(s,h.scrapeInterval)}function u(){for(var e=[],a=0;a<z.length;a++){var n=!1;if(z[a].queuedSpecializedScrapes&&z[a].queuedSpecializedScrapes.length>0){for(var t=0;t<z[a].queuedSpecializedScrapes.length;t++){var c=z[a].queuedSpecializedScrapes[t],r=p(c.specialization,z[a]);r&&r.length>0&&(n=!0);c.callback&&c.callback(r,c.specialization,z[a])}z[a].queuedSpecializedScrapes=[]}if(!z[a].scraped){var l=document.getElementById(z[a].zoneValue);if(null!=l||n&&z[a].zoneType===D.EMBEDDED){z[a].scraped=!0;e.push({type:"pagediv",divId:z[a].zoneValue})}}}return e}function o(e){if(e.length>0){lpTag.log("zones: "+JSON.stringify(e),"DEBUG","SCRAPER");lpTag.sdes.send(e,function(){lpTag.log("scraper::_send::lpTag.sdes.send success for: "+e.toString(),"DEBUG","SCRAPER")})}}function p(e,a){var n=d(e,a),t=[];n&&(t=g(e.scrapeType,n));return t}function d(e,a){return e.scrapeValueType==C.ZONEVALUE?a.zoneValue:e.scrapeValue}function g(e,a){switch(e){case A.CLASS:return document.getElementsByClassName(a);case A.ATTRIBUTE:var n="["+a+"]";return document.querySelectorAll(n);case A.ID:return document.getElementById(a);case A.NAME:return document.getElementsByName(a);case A.TAG:return document.getElementsByTagName(a)}return[]}var f,S,T,E="3.59.0",m="scraper",v={ACCDN:"acCdnDomainConsumerSdk"},z=[],h={scrapeInterval:50},A={CLASS:"class",ATTRIBUTE:"attribute",ID:"id",TAG:"tag",NAME:"name"},C={ZONEVALUE:"zoneValue",CUSTOM:"custom"},D={EMBEDDED:0};return{v:E,name:m,init:e,start:a,reinit:n,restart:t,getElmId:c,queueSpecializedScrape:r,inspect:l}}();}catch(e){lpTag.handleGeneralError("scraper",e);}try{window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.lpActivityMonitor=lpTag.taglets.lpActivityMonitor||function(){function t(t){lpTag.sdes=lpTag.sdes||[];f(t);s(v)}function e(){c("Starting activity tracking");S=!0;O=setTimeout(E,A.timeout)}function n(){c("Called Stop");if(O){clearTimeout(O);S=!1;p("Stopped activity tracking")}T()}function i(t){c("Called push with type="+t);t&&"number"==typeof t?lpTag.sdes.push({type:A.sdeType,input:t}):r("Did not push sde since type is not a number type="+t,"ERROR")}function o(t){c("Called Reinit");u();f(t);v()}function u(){D=0;U=N.UNDEFINED}function a(){return S}function r(t,e){window.lpTag&&lpTag.log&&lpTag.log(t,e,h)}function c(t){r(t,"DEBUG")}function p(t){r(t,"INFO")}function l(t){try{return JSON.parse(JSON.stringify(t))}catch(e){return t}}function s(t){return setTimeout(t,0)}function f(t){if(t)for(var e=0;e<t.length;e++){var n=t[e].value;"string"==typeof n&&""!==n&&("["===n.charAt(0)||"{"===n.charAt(0))&&("undefined"!=typeof JSON&&JSON.parse?n=JSON.parse(n):r("unable to parse JSON, no JSON object on page ","ERROR"));A[t[e].id]=n}else p("No cfg were given on init")}function m(t,e,n){t.addEventListener?t.addEventListener(e,n,!1):t.attachEvent&&t.attachEvent("on"+e,n)}function d(t,e,n){t.removeEventListener?t.removeEventListener(e,n,!1):t.detachEvent&&t.detachEvent("on"+e,n)}function g(t){y&&clearTimeout(y);var e=t.type;y=s(function(){if(I[e]){U=I[e].input;D=(new Date).getTime()}})}function v(){if(!R)for(var t in I)I.hasOwnProperty(t)&&m(I[t].elem,t,g);R=!0}function T(){if(R)for(var t in I)I.hasOwnProperty(t)&&d(I[t].elem,t,g);R=!1}function E(){var t=(new Date).getTime()-D;if(0!==D&&t<=A.timeout){lpTag.events.trigger(h,"ACTIVITY_MONITORED",{inputType:U,time:D});i(U)}O&&clearTimeout(O);O=setTimeout(E,A.timeout)}var O,y,w="3.4.0",h="lpActivityMonitor",S=!1,N={UNDEFINED:0,MOUSE:1,KEYBOARD:2,TOUCH:3,FOCUS:4},D=0,U=N.UNDEFINED,A={timeout:6e4,sdeType:"tabActive"},R=!1,I={click:{elem:document,input:N.MOUSE},mousemove:{elem:document,input:N.MOUSE},wheel:{elem:document,input:N.MOUSE},scroll:{elem:window,input:N.MOUSE},keydown:{elem:document,input:N.KEYBOARD},touchmove:{elem:document,input:N.TOUCH},focus:{elem:window,input:N.FOCUS}};return{v:w,name:h,init:t,start:e,reinit:o,restart:e,stop:n,push:i,reset:u,isActive:a,inputType:N,inspect:function(){return{conf:l(A),lastActivityTime:D,lastInputType:U,intervalId:O}}}}();}catch(e){lpTag.handleGeneralError("lpActivityMonitor",e);}try{window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.rendererStub=lpTag.taglets.rendererStub||function(){function e(e){lpTag.log("rendererStub init called","DEBUG","LP_OFFER");se=lpTag.taglets.lpUtil;oe(e);V()&&t();var n="function"==typeof lpTag.getEnv&&lpTag.getEnv();fe=Be&&void 0!==Be.isFetchEnabled?JSON.parse(Be.isFetchEnabled):"alpha"===n;de=Be&&Be.fetchCacheMode;ce=fe?lpTag.taglets.fetch:lpTag.taglets.jsonp}function t(){lpTag.events.bind("LE_ENGAGER","SHOW",d);lpTag.events.bind("lpUnifiedWindow","state",v);lpTag.events.bind("LE_ENGAGER","CHAT",m);lpTag.events.bind("LE_ENGAGER","MESSAGING",T);lpTag.events.bind("LE_ENGAGER","SURVEY",E);lpTag.events.bind("LE_ENGAGER","OPEN",p);lpTag.events.bind("LP_OFFERS","OFFER_REMOVE",f);lpTag.events.bind("lpUnifiedWindow","STORAGE_SELECTED",ee)}function n(e){e=e||{};c(e)}function a(e){var t={};if(Ne.ids[e]&&Ne.ids[e].engData){t=JSON.parse(z(Ne.ids[e].engData));t.engagementId=e}return t}function i(e){var t={engagementId:e,state:0,desc:"NA"};if(Ne.ids[e]&&Ne.ids[e].engData&&"undefined"!=typeof Ne.ids[e].engData.state&&"undefined"!=typeof me[Ne.ids[e].engData.state]){t.state=Ne.ids[e].engData.state;t.desc=me[t.state]}return t}function o(e,t,n){var a={},i=e.engagementWindowId||e.windowId||t.windowId;a.site=lpTag.site;a.scid=e.contextId;a.cid=e.campaignId;a.eid=e.engagementId;a.ename=e.engagementName;a.target=n&&n.target||(we+lpTag.site).replace(/[^a-z0-9]/gi,"_");a.params=n&&n.params||Ce;a.svid=lpTag.taglets.lp_monitoringSDK.getVid();a.ssid=lpTag.taglets.lp_monitoringSDK.getSid();a.ssuid=lpTag.taglets.lp_monitoringSDK.getSidPrefix();a.isPopOut="boolean"==typeof t.isPopOut||"true"===t.isPopOut?!!t.isPopOut:!1;a.env=n&&n.env||"function"==typeof lpTag.getEnv&&lpTag.getEnv();a.offlineSurveyId=e.offlineSurveyId;a.async=e.conversationType===Ae.MESSAGING||t.conversationType===Ae.MESSAGING;a.allowUnauthMsg=t.allowUnauthMsg;a.identityData=ge=t.identityData;(e.connector||t.connector)&&(a.connector=lpTag.taglets.lpUtil.cloneExtend(e.connector||{},t.connector||{}));t.skillName&&(a.skill=t.skillName);t.skillId&&(a.skillId=t.skillId);i&&(a.lewid=i);t.language&&(a.lang=t.language);(e.forceOffline===!0||e.state===he.OFFLINE||e.state===he.BUSY&&t.availabilityPolicy===be.OFFLINE)&&(a.isOffline=!0);if(e.redirect){a.redirect=e.redirect;a.isPopOut=!0}e.ssoKey&&(a.ssoKey=e.ssoKey);e.minimiseOnStart&&(a.minimiseOnStart=!0);e.preChatLines&&(a.preChatLines=e.preChatLines);e.queuePriority&&(a.queuePriority=e.queuePriority);(t.availabilityPolicy===be.OFFLINE||t.availabilityPolicy===be.CHAT)&&(a.availabilityPolicy=t.availabilityPolicy);e[Fe]&&(a[Fe]=e[Fe]);e.windowConf&&(a.windowConf=e.windowConf);ae()&&(a.accountSettings=re);if(t.externalTargets&&t.externalTargets.length){a.externalTargets={};t.externalTargets.forEach(function(e){a.externalTargets[e.deflectionTarget]={brandIdentifier:e.brandIdentifier};a.externalTargets[e.deflectionTarget].deflectionTargetProperties=r(e.deflectionTargetProperties)})}e.multiChannelEngagementSelection&&j(e.multiChannelEngagementSelection,a);lpTag.events.trigger("RENDERER_STUB","ENGAGEMENT_CONFIGURATION_CREATED",{engConf:a,data:e,config:t,channel:n});return a}function g(e,t){var n=!1;if(Ne.ids[e]&&"function"==typeof Ne.ids[e].offerClick){n=!0;t=t||{};l(t)&&(Ne.ids[e].engData.preChatLines=t.preChatLines);Ne.ids[e].offerClick()}return n}function r(e){var t={};"string"==typeof e&&e.split(",").forEach(function(e){if(e){var n=e.split(":");2===n.length&&n[0]&&n[1]&&(t[n[0]]="true"===n[1]||"false"===n[1]?"true"===n[1]:isNaN(n[1])?n[1]:Number(n[1]))}});return t}function l(e){function t(e){return"string"==typeof e}return e&&e.preChatLines&&Array.isArray(e.preChatLines)&&e.preChatLines.every(t)}function s(e,t){var n;if(e&&t&&t.length)for(var a=0;a<t.length;a++){n=t[a];e[n]=null;delete e[n]}}function c(e){var t,n=[],a=e.idsToKeep||{},i=e.divIdsToKeep||{};for(var o in i)if(i.hasOwnProperty(o)&&Ne.divIds.hasOwnProperty(o)){t=Ne.divIds[o];a[t]=!0}for(var g in Ne.ids)if(Ne.ids.hasOwnProperty(g)&&!a[g]){try{Ne.ids[g].cleanupOffer({silent:!0})}catch(r){lpTag.log("Failed to remove engagement, might have been removed already. ex="+r.message,"DEBUG","LP_OFFER")}n.push(g)}s(Ne.ids,n);Oe={};Ue={}}function f(e){var t=e.engagementId;if(t&&Ne.ids[t]){Ne.ids[t]=null;delete Ne.ids[t]}}function d(e){if(X(e)){lpTag.log("rendererStub received new smt msg. {id:"+e.engagementId+" ,type:"+e.engagementType+",revision:"+e.engagementRevision+",campaignId "+e.campaignId+"}","DEBUG","LP_OFFER");e[Fe]=Ie.SHOW;if("undefined"!=typeof e.controlGroup&&e.controlGroup)y(e);else{J(e);e.customTaglet&&N(e);O(e,G(e).files);F(e);R(e)}}}function p(e){if("object"==typeof e){e[Fe]=Ie.OPEN;e.conversationType=ye.MESSAGING;e.minimiseOnStart=!0;R(e);X(e)?F(e,function(t){k(t);t.confKey=Q(e);e.confKey=Q(e);Oe[e.confKey]=t;M(t)?B(e):u(t)}):u(e)}}function u(e){e.tglName="conversationInitiator";R(e);if(X(e))F(e,O(e,e.tglName));else{if(!e.windowConf)if(e.windowId){e.confKey=e.confKey||e.windowId;te(e,U)}else{e.confKey=e.tglName;Ue[e.confKey]={}}O(e,e.tglName)}}function T(e){X(e)&&e.state===he.OFFLINE&&"offsite"===Te[e.engagementType]?b(e,"messaging"):u(e)}function m(e){X(e)&&e.state===he.OFFLINE&&"offsite"===Te[e.engagementType]?b(e,"chat"):u(e)}function E(e){e.forceOffline=!0;u(e)}function v(e){lpTag.log("rendererStub received hide engagements event.","DEBUG","LP_OFFER");e&&"chatting"===e.state&&lpTag.events.trigger("LP_OFFERS","HIDE")}function y(e){lpTag.log("rendererStub::controlGroup is true for campaignID: "+e.campaignId+" - engagementId: "+e.engagementId,"DEBUG","LP_OFFER");var t=[{type:"impDisplay",campaign:e.campaignId,engId:e.engagementId,revision:e.engagementRevision,eContext:[{type:"engagementContext",id:e.contextId}]}];lpTag.sdes.send(t,function(){lpTag.log("rendererStub:::impression event send for "+e.campaignId+" - engagementId: "+e.engagementId,"DEBUG","LP_OFFER")});lpTag.events.trigger("LP_OFFERS","CONTROL_GROUP",e)}function O(e,t){lpTag.log("_loadTaglet called with url: "+JSON.stringify(e),"DEBUG","LP_OFFER");var n=!1,a={},i=lpTag.protocol+"//"+lpTag.csds.getDomain(Ee.LPCDN)+"/le_re/";pe&&(i+=pe+"/");i+="jsv2/";if(t){t=Array.isArray(t)?t:[t];for(var o=0;o<t.length;o++)if("string"==typeof t[o]&&!lpTag.taglets[t[o]]){a[t[o]]=i+t[o]+".js?_v="+pe;n=!0}}n?lpTag.taglets.jsLoader.loadJS({loadObj:a,success:S(e),error:I(e)}):U(e)}function N(e){lpTag.log("_loadCustomTaglet called with url: "+JSON.stringify(e),"DEBUG","LP_OFFER");lpTag.taglets[e.tglName]?U(e):"function"==typeof lpTag.loadTaglet&&lpTag.loadTaglet({name:e.tglName,success:S(e),error:I(e)})}function S(e){return function(){lpTag.log("_loadTagletSuccess taglet not exist, isReady: "+L(e),"DEBUG","LP_OFFER");U(e)}}function I(e){return function(t){lpTag.log("Loading taglet: "+e.tglName+" failed. Error: "+JSON.stringify(t),"ERROR","LP_OFFER")}}function F(e,t){var n=lpTag.protocol+"//"+lpTag.csds.getDomain(Ee.ACCDN)+"/api/account/"+lpTag.site+"/configuration/le-campaigns/campaigns/"+e.campaignId+"/engagements/"+e.engagementId+"/revision/"+e.engagementRevision+"?v="+Le;lpTag.log("_loadEngagementConfig called with url: "+n+" msg: "+JSON.stringify(e),"DEBUG","LP_OFFER");e.confKey=e.confKey?e.confKey:Q(e);Oe[e.confKey]?U(e):ce.issueCall({url:n,data:{flavor:"dependency"},callbackName:"lp"+e.engagementId,credentials:fe?"omit":void 0,cache:fe&&de?de:void 0,success:function(n){var a=fe?n&&n.body:n;if(Z(a)&&$(a)){lpTag.log("Engagement "+e.engagementId+" loaded","DEBUG","LP_OFFER");a.identityData=e.identityData;Oe[e.confKey]=a;if("function"==typeof t){a.confKey=e.confKey?e.confKey:Q(e);te(a,t)}else{e.windowId=a.windowId;te(e,U);lpTag.log("_loadEngagementConfig conf not exist, isReady: "+L(e),"DEBUG","LP_OFFER")}}},error:function(){lpTag.log("Loading engagement: "+e.engagementId+"   failed.  id : ","ERROR","LP_OFFER")}})}function R(e){var t=lpTag.protocol+"//"+lpTag.csds.getDomain(Ee.ACCDN)+"/api/account/"+lpTag.site+"/configuration/setting/accountproperties"+(fe?"":"/"),n=A(),a=function(t){var n=fe?t&&t.body:t;_(n,!1,e)},i=function(){h(!1,e)};lpTag.log("_loadSiteSettings called with url: "+t,"DEBUG","LP_OFFER");ae||(re=[]);if(re||n)if(!re&&n){lpTag.log("_loadSiteSettings - Account settings network call already in progress"+t,"DEBUG","LP_OFFER");C(e)}else U(e);else{w();ce.issueCall({url:t,timeout:5e3,retries:0,callbackName:"accountSettingsCB",credentials:fe?"omit":void 0,cache:fe&&de?de:void 0,success:a,error:i})}}function w(){lpTag.events.trigger({appName:"*",eventName:"requestedAccountSettings",data:{}})}function C(e){var t=lpTag.events.hasFired("*","receivedAccountSettings"),n=lpTag.events.hasFired("*","receivedAccountSettingsFailed"),a=function(t){_(t,!1,e)},i=function(){h(!1,e)};a.bind(this);i.bind(this);t.length<1?lpTag.events.once({appName:"*",eventName:"receivedAccountSettings",func:a}):_(t[0].data,!1,e);n.length<1?lpTag.events.once({appName:"*",eventName:"receivedAccountSettingsFailed",func:i}):h(!1,e)}function _(e,t,n){if(e&&Array.isArray(e)&&!e.error){lpTag.log("_loadSiteSettings - got configuration: "+JSON.stringify(e),"DEBUG","LP_OFFER");re=e}else{lpTag.log("_loadSiteSettings - NO CONFIGURATION FOUND","DEBUG","LP_OFFER");re=[]}t&&lpTag.events.trigger({appName:"*",eventName:"receivedAccountSettings",data:e});U(n)}function h(e,t){lpTag.log("Loading siteSettings: "+lpTag.site+"   failed.  id : ","ERROR","LP_OFFER");re=[];U(t);e&&lpTag.events.trigger({appName:"*",eventName:"receivedAccountSettingsFailed",data:{}})}function A(){return lpTag.events.hasFired("*","requestedAccountSettings").length>0}function b(e,t){var n=lpTag.protocol+"//"+lpTag.csds.getDomain(Ee.ACCDN)+"/api/account/"+lpTag.site+"/configuration/setting/accountproperties"+(fe?"":"/");if(!le){le=[];lpTag.log("_loadSiteSettingsForOffsite called with url: "+n,"DEBUG","LP_OFFER");ce.issueCall({url:n,timeout:5e3,retries:0,credentials:fe?"omit":void 0,cache:fe&&de?de:void 0,success:function(n){var a=fe?n&&n.body:n,i="le.campaign.offsite.campaignNotApplicable.redirectURL",o="le.campaign.offsite.messaging.campaignNotApplicable.redirectURL";if(a&&Array.isArray(a)&&!a.error){lpTag.log("_loadSiteSettingsForOffsite - offsite engagement got configuration: "+JSON.stringify(a),"DEBUG","LP_OFFER");le=a;var g="chat"===t?i:o,r=ie(g,le);r?window.location.href=r:"chat"===t&&u(e)}else lpTag.log("_loadSiteSettingsForOffsite - NO CONFIGURATION FOUND","DEBUG","LP_OFFER")},error:function(){lpTag.log("Loading siteSettings for offsite: "+lpTag.site+"   failed.  id : ","ERROR","LP_OFFER");le=null}})}}function L(e){return!(!lpTag.taglets[e.tglName]||!D(e)||e.instantiated||!Oe[e.confKey]&&"conversationInitiator"!==e.tglName||!Ue[e.confKey])&&re}function D(e){for(var t=G(e).taglets||[],n=!0,a=0;a<t.length;a++)if(!lpTag.taglets[t[a]]){n=!1;break}return n}function G(e){var t=e.customTaglet?"customTaglet":e.tglName;return Se[t]&&Se[t]||{}}function U(e){if(!lpTag.taglets.lpUnifiedWindow||De){lpTag.log("_execTaglet, is ready:"+L(e)+" msg: "+JSON.stringify(e),"DEBUG","LP_OFFER");var t;if(L(e)){lpTag.log("taglet "+e.tglName+" executed by rendererStub at: "+(new Date).getTime()+"(number of milliseconds since 1970/01/01)","DEBUG","LP_OFFER");e.instantiated=!0;t=P(e);t&&x(e)}}else Ge.push(e)}function P(e){var t=!0;e.engagementId&&Ne.ids[e.engagementId]&&(t=K(e,e.engagementId,Ne.ids));return t}function K(e,t,n){var a,i=!0;if(e.confKey!==n[t].engData.confKey||e.state!==n[t].activeState.type){a=n[t]||{};e.prevState=a.engData&&a.engData.state;a.cleanupOffer({silent:!0});s(n,[t])}else{n[t].setContextId(e.contextId);i=!1}return i}function B(e){var t=Y(Oe[e.confKey]),n=Y(e),a={configuration:t.windowConf.json.externalConfiguration,args:o(n,t),errorCallback:function(){lpTag.log("Error while opening an external channel")}};try{lpTag.taglets.lpUtil.runCallbackByObject(a.configuration,a.args,a.errorCallback)}catch(i){lpTag.log("Exception while opening an external channel: "+i.message)}}function x(e,t){var n,a,i=Y(Oe[e.confKey]);if(e.customTaglet){a=new lpTag.taglets.baseOffer;a.init(Y(e),i)}try{if(t&&t.ssoKey){e.ssoKey=t.ssoKey;e.redirect_uri=t.redirect_uri||_e}var o=Y(e);lpTag.events.trigger("RENDERER_STUB","BEFORE_CREATE_ENGAGEMENT_INSTANCE",{msg:o,conf:i,api:a});o.skipRendererStubInstantiation||(n=lpTag.taglets[e.tglName].createInstance(o,i,a));lpTag.events.trigger("RENDERER_STUB","AFTER_CREATE_ENGAGEMENT_INSTANCE",{msg:o,conf:i,api:a,eng:n})}catch(g){lpTag.log("Failed to create engagement instance. ex="+g.message,"ERROR","LP_OFFER")}if(n&&"function"==typeof n.cleanupOffer){Ne.ids[e.engagementId]=n;n.parentContainer&&(Ne.divIds[n.parentContainer]=e.engagementId)}}function M(e){return e.windowConf&&e.windowConf.type===Re&&e.windowConf.json.externalConfiguration?!0:!1}function J(e){e.confKey=Q(e);e.customTaglet=W(e);var t="";Te[e.engagementType]&&(t=Te[e.engagementType]);e.tglName=e.customTaglet?e.tglName:t}function k(e){e&&"undefined"==typeof e.engagementId&&(e.engagementId=e.id)}function W(e){return e.renderingType===ve.TAGLET}function j(e,t){switch(e){case Ke.WEB_TO_SMS:H(t);break;case Ke.WEB:case Ke.MESSAGING:q(t)}}function H(e){e.async=!0}function q(e){delete e.externalTargets[Pe.SMS];e.async=!0}function V(){var e=navigator.userAgent;e=e.toLowerCase();var t=/(msie) ([\w.]+)/,n=t.exec(e);if(null!=n){var a=parseInt(n[2],10);if(10>=a)return!1}return!0}function Y(e){return e&&JSON.parse(z(e))}function z(e){var t;if("function"==typeof Array.prototype.toJSON){var n=Array.prototype.toJSON;delete Array.prototype.toJSON;try{t=JSON.stringify(e)}catch(a){Array.prototype.toJSON=n;throw a}Array.prototype.toJSON=n}else t=JSON.stringify(e);return t}function Q(e){return e&&e.campaignId+"_"+e.engagementId+"_"+e.engagementRevision}function X(e){if(e&&e.campaignId&&e.engagementId&&e.engagementRevision)return!0;lpTag.log("Missing engagement parameters: campaignId, engagementId, engagementRevision; "+JSON.stringify(e),"ERROR",ue);return void 0}function Z(e){if("object"==typeof e&&!e.error)return!0;lpTag.log("Error in engagement config: "+JSON.stringify(e),"ERROR",ue);return void 0}function $(e){return!e.allowUnauthMsg||e.allowUnauthMsg&&lpTag&&lpTag.taglets&&lpTag.taglets.unAuthMessaging}function ee(){De=!0;Ge.forEach(U);Ge=[]}function te(e,t){var n;lpTag.log("_getConfiguration",e.windowId);var a=Be.enableToRequestDefaultWinConfig,i="/"+e.windowId;!e.windowId&&a&&(i="-default");if(e.windowId||a){n="https://"+lpTag.csds.getDomain(Ee.ACCDN)+"/api/account/"+lpTag.site+"/configuration/engagement-window/window-confs"+i;ce.issueCall({url:n,timeout:5e3,retries:0,credentials:fe?"omit":void 0,cache:fe&&de?de:void 0,success:function(n){var i,o=fe?n&&n.body:n;if(!e.windowId&&a&&o&&o.length){i=o.filter(function(e){return!!e.isUserDefault});o=i.length>0?i[0]:o[0]}if(o&&o.json&&!o.error){lpTag.log("_getWindowConfiguration: got configuration: "+JSON.stringify(o.name),"INFO",ue);var g=o.json;g&&(g.isTemplate=!!o.templateId);e.windowConf=e.windowConf?lpTag.taglets.lpUtil.cloneExtend(e.windowConf,g):g;Ue[e.confKey]=g}else{lpTag.log("_getWindowConfiguration: NO CONFIGURATION FOUND","INFO",ue);Ue[e.confKey]={}}t(e)},error:function(n){lpTag.log("Error in getting window config: "+JSON.stringify(n),"ERROR",ue);Ue[e.confKey]={};t(e)}})}else{lpTag.log("_getWindowConfiguration: No windowId provided, fallback to default configuration","INFO",ue);Ue[e.confKey]={};t(e)}}function ne(){return ge}function ae(){return lpTag.unifiedWindow&&lpTag.unifiedWindow.staticConfig&&lpTag.unifiedWindow.staticConfig.passSiteSettings}function ie(e,t){for(var n=0;n<t.length;n++)if(t[n].id===e)return t[n].propertyValue.value;return null}function oe(e){if(e&&e.constructor===Array)try{se.convertConfig(e,Be)}catch(t){lpTag.log.error("Failed to parse taglet configuration",name)}else e&&(Be=se.cloneExtend(Be,e,!0))}var ge,re,le,se,ce,fe,de,pe="3.61.0-release_1396603402",ue="rendererStub",Te={0:"peeling",1:"overlay",2:"toaster",3:"slider",5:"overlay",6:"overlay",7:"offsite"},me={0:"na",1:"online",2:"offline"},Ee={CHAT:"CHAT",ACCDN:"acCdnDomainConsumerSdk",LPCDN:"leCdnDomain"},ve={INTERNAL:0,HTML:1,TAGLET:2},ye={LIVE_CHAT:0,MESSAGING:1},Oe={},Ne={ids:{},divIds:{}},Se={peeling:{files:["peeling","UISuite"],taglets:["peeling","baseOffer","baseUIOffer"]},overlay:{files:["overlay","UISuite"],taglets:["overlay","baseOffer","baseUIOffer"]},toaster:{files:["toaster","UISuite"],taglets:["toaster","baseOffer","baseUIOffer"]},slider:{files:["slider","UISuite"],taglets:["slider","baseOffer","baseUIOffer"]},customTaglet:{files:["baseOffer"],taglets:["baseOffer"]},conversationInitiator:{taglets:["baseOffer"]}},Ie={OPEN:"OPEN",SHOW:"SHOW"},Fe="eventName",Re="external app",we="LiveEngageChat_",Ce="height=650,width=330,menubar=no,resizable=no",_e="https://liveperson.net",he={BUSY:4,CONTENT:3,OFFLINE:2,ONLINE:1},Ae={CHAT:0,MESSAGING:1},be={OFFLINE:0,CHAT:1},Le="3.0",De=!1,Ge=[],Ue={},Pe={SMS:0},Ke={WEB:"web",MESSAGING:"messaging",WEB_TO_SMS:"sms"},Be={};return{_v:pe,_name:ue,init:e,onBeforeNavigation:n,getEngagementState:i,getEngagementInfo:a,getClickObject:o,click:g,getIdentity:ne}}();}catch(e){lpTag.handleGeneralError("rendererStub",e);}try{window.lpTag=lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.lp_version_detector=function(){function e(e,n){window.lpTag&&lpTag.log&&lpTag.log(e,n,p)}function n(n){e(n,"ERROR")}function a(n){e(n,"INFO")}function o(e,n){if("undefined"!=typeof n){if(e)for(var a=0;a<e.length;a++){var o=e[a].value;if("string"==typeof o&&""!==o)if("true"===o)o=!0;else if("false"===o)o=!1;else if("["==o.charAt(0)||"{"==o.charAt(0))try{"undefined"!=typeof JSON&&JSON.parse?o=JSON.parse(o):lpTag.log("unable to parse JSON, no JSON object on page ","ERROR",p)}catch(t){lpTag.log("unable to parse JSON:"+t,"ERROR",p)}n[e[a].id]=o}}else lpTag.log("_config is passed as undefined","ERROR",p)}function t(e){o(e,s)}function i(){s.sendUDE&&g({name:"lpTagVer",value:lpTag._v});s.sendSDE&&l({type:"lpTagVer",version:lpTag._v})}function l(e){window.lpTag.sdes=window.lpTag.sdes||[];lpTag.sdes.push(e)}function g(e){window.lpMTagConfig=window.lpMTagConfig||{};window.lpMTagConfig.pageVar=window.lpMTagConfig.pageVar||[];try{e.value=""+e.value;var o=encodeURIComponent(e.name)+"="+encodeURIComponent(e.value);lpMTagConfig.pageVar.push(o);a("Added variable scope:page name:"+e.name+" value:"+e.value)}catch(t){n("Exception in adding variable e="+t)}}var p="lp_version_detector",r="1.0.1",s={sendSDE:!1,sendUDE:!0};return{getVersion:function(){return r},getName:function(){return p},init:t,start:i,inspect:function(){return{conf:s}}}}();}catch(e){lpTag.handleGeneralError("lp_version_detector",e);}try{window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.lp_monitoringSDK=lpTag.taglets.lp_monitoringSDK||function(){function e(e){v();Ie=!0;if(e)for(var n=0;n<e.length;n++){var r=e[n].value;"string"==typeof r&&""!==r&&("["===r.charAt(0)||"{"===r.charAt(0))&&("undefined"!=typeof JSON&&JSON.parse?r=JSON.parse(r):b("unable to parse JSON, no JSON object on page "));Me[e[n].id]=r}else D("No cfg were given on init");Me.useStorage=Me.useStorage||!Ze.isCookieEnabled();Me.idpDomain=lpTag.getDomain("idp");Me.acCdnDomain=lpTag.getDomain("acCdnDomainConsumerSdk");var a="function"==typeof lpTag.getEnv&&lpTag.getEnv();Ye=void 0!==Me.isFetchEnabled?JSON.parse(Me.isFetchEnabled):"alpha"===a;Ue=Me.fetchCacheMode;xe=Ye?lpTag.taglets.fetch:lpTag.taglets.jsonp;Re=lpTag.taglets.postmessage;var o={frames:[{url:Me.protocol+Me.baseUrl+Me.frameName},{url:Me.protocol+Me.idpDomain+Me.frameName},{url:Me.protocol+Me.acCdnDomain+Me.frameName}]};Ye||Re.configure(o);Me.useSecureStorage=lpTag.features&&lpTag.features.getFeature(Qe);!ke&&Me.useSecureStorage?t():i()}function t(e){var t=lpTag.csds.getDomain("leCdnDomain"),i="function"==typeof lpTag.getEnv&&lpTag.getEnv(),r={debug:Me.debug};_e=lpTag.taglets.lpSecureStorage;Me.secureStorageLocation="https://"+t+"/le_secure_storage/"+(_e.v?_e.v+"/":"");r[Xe]={env:i,site:Me.accountId,app:Xe,asyncStorageMaxRetry:15,url:Me.secureStorageLocation,chosenStorageHandler:e||n,firstParty:!0};_e.configure(r);ke=!0}function n(e){e&&e.error&&(Me.secureStorageUnSupported=!0);i()}function i(){var e=r(window.location.href)||{},t=lpTag.taglets.lpUtil&&lpTag.taglets.lpUtil.getURLParams(window.location.search)||{},n=t.lpconnectorvid||e.lpvid||t.lpvid;if(n){F();A(n)}var i=e.lpsid||t.lpsid;if(i){j();J(i)}}function r(e){function t(e){return e.replace(/[^a-zA-Z0-9._-]/g,"")}try{var n=new URL(e),i=n.hash.substring(1),r=new URLSearchParams(i),a={};r.forEach(function(e,n){var i=t(n),r=t(e);a[i]=r});return a}catch(o){return{}}}function a(e,t){D("Called startPage onSuccess: "+e);var n={type:Ae.startPage,onSuccess:e,onError:t,isSync:!0};Me.useSecureStorage?M(o.bind(this,n)):o(n)}function o(e){var n=Se(e);tt.identities(function(i){var r=[];if(i&&i.length>0){n.data.identities=i;lpTag.identitiesObjects=i;r=lpTag.identitiesObjects.filter(function(e){return e.tkn})}if(Te){e.rid=n.rid;e.result={error:500,message:"startPage request was already sent once"};e.status=je.err;N(e)}else me(n);Te=!0;lpTag.events.trigger(Le,"SP_SENT");0===r.length&&(ke?ve("removeValue"):t(function(){ve("removeValue")}))})}function s(e,t){var n;O("Called pageLoaded onSucess is: "+e);var i={type:Ae.pageLoaded,onSuccess:e,onError:t,isSync:!0};n=Se(i);if(Te&&!Ce)se(n);else{i.rid=n.rid;i.result={error:500,message:"pageLoaded request was already sent once"};i.status=je.err;N(i)}Ce=!0}function c(e,t){O("Called inPage onSucess is: "+e);var n={type:Ae.inPage,onSuccess:e,onError:t,isSync:!0},i=Se(n);if(Te&&Ce)se(i);else{n.rid=i.rid;n.result={error:500,message:"Cannot issue inPage request when startPage and pageLoaded were not sent"};n.status=je.err;N(n)}}function u(e,t){O("Called send, onSuccess: "+e);var n={type:Ae.updateContext,onSuccess:e,onError:t,isSync:!0};if(qe.length>0){var i=Se(n);se(i);return!0}return!1}function l(e){O("Called push with sdes: "+JSON.stringify(e));if("undefined"!=typeof e&&e instanceof Array)for(var t=0;t<e.length;t++)"object"==typeof e[t]&&e[t].type?qe.push(e[t]):b("push: SDE when calling is not an Object")}function d(){var e=p();return e?e.substring(0,e.indexOf(".")):void 0}function p(){return Ee||(Me.useStorage?Je.getSessionData("LPSID-"+Me.accountId)||null:U("LPSID-"+Me.accountId))}function g(){return Pe||(Me.useStorage?Je.getSessionData("LPVID")||null:U("LPVID"))}function f(){return Me.thirdPartyEnabled}function m(e,t,n){-1===e.indexOf("?")?e+="?":"&"!==e[e.length-1]&&(e+="&");t||(t="SVID");n||(n="SSID");p()&&(e+=encodeURIComponent(n)+"="+encodeURIComponent(p()));g()&&(e+="&"+encodeURIComponent(t)+"="+encodeURIComponent(g()));return e}function S(e){var t;if("function"==typeof Array.prototype.toJSON){var n=Array.prototype.toJSON;delete Array.prototype.toJSON;try{t=JSON.stringify(e)}catch(i){Array.prototype.toJSON=n;throw i}Array.prototype.toJSON=n}else t=JSON.stringify(e);return t}function v(){O("Called reset");Me={thirdPartyEnabled:void 0,protocol:lpTag.protocol?lpTag.protocol+"//":0===document.location.toString().indexOf("https:")?"https://":"http://",baseUrl:lpTag.getDomain("smt"),apiPath:"/api/js",rdrPath:"/rdr",frameName:"/postmessage/postmessage.min.html",accountId:lpTag.site||{},rmSession:!1,timeout:5e4,debug:!1,shadow:!1};qe=qe||[];he=[];ye=void 0;Ke={};Te=!1;Ce=!1;be=!1;Oe=!1;De=!1;ke=!1;Pe=void 0;Ee=void 0;clearTimeout(Ne);Ne=void 0;we={count:0,max:6,timeout:10}}function h(){clearTimeout(Ne);Ne=void 0;Ie=!1}function y(t){O("reinit called");lpTag.taglets.lpUnifiedWindow&&(lpTag.taglets.lpUnifiedWindow.stepUpChecked=null);e(t);We=E()}function T(){return{conf:Me,retry:we}}function C(e,t){window.lpTag&&lpTag.log&&lpTag.log(e,t,"lp_monitoringSDK")}function b(e){C(e,"ERROR")}function O(e){C(e,"DEBUG")}function D(e){C(e,"INFO")}function P(){$e++;return $e}function E(){return Math.abs(Math.round(9999999999*Math.random()))}function I(e){Ie?lpTag.taglets.lpAjax.issueCall(e):b("Monitoring session not active, skipping request: "+JSON.stringify(e))}function k(){var e=Je.getSessionData("lpTabId");if(!e){e=E();Je.setSessionData("lpTabId",e)}return e}function N(e){var t,n=Ke[e.rid],i=e.result;i&&i.body&&(i=i.body);if(n){O("Called _monitoringCb with type= "+e.type+" ,result="+JSON.stringify(i));G(i);L();z();lpTag.events.trigger({appName:Le,eventName:"DEBUG_STATUS",data:{debug:Me.debug},aSync:!0});lpTag.events.trigger({appName:Le,eventName:"REQUEST_COMPLETE",data:{type:e.type,status:e.status},aSync:!0});var r=_(i,n.req);if(!r){delete i.sdkConf;we.count=0;Ke[e.rid]=null;delete Ke[e.rid];t=H(i,e.status);w({success:t,result:i,cbs:n,response:e})}}else b("Failed on _monitoringCb, request id does not exist in map, rid="+e.rid)}function w(e){if(e.success){R(e.result);if(e.cbs.cOnSuccess)try{e.cbs.cOnSuccess(e.result)}catch(t){b("Failed calling client onSuccess, _monitoringCb e="+JSON.stringify(t.message))}}else if(e.cbs.cOnError)try{e.cbs.cOnError(e.result)}catch(t){b("Failed calling client onError, _monitoringCb e="+JSON.stringify(t.message))}e.response.type===Ae.startPage?pe(e.success):e.response.isSync?de():fe()}function _(e,t){var n=e.sdkConf&&e.sdkConf.retry;if(n){Ne&&clearTimeout(Ne);isNaN(n.max)||(we.max=parseInt(n.max,10));isNaN(n.timeout)||(we.timeout=parseInt(n.timeout,10));if(we.count<we.max){D("retrying count="+we.count+" max="+we.max);we.count++;Ne=setTimeout(function(){t.data.rc=we.count;Q(t);I(t)},1e3*we.timeout);return!0}b("exceeded max retries: "+we.max+", stopping")}}function R(e){var t={};if(e.messagesToVisitor&&!Me.shadow)for(var n=0;n<e.messagesToVisitor.length;n++){t=e.messagesToVisitor[n];try{lpTag.events.trigger(t.destination,t.subject,t.content)}catch(i){b("Failed on _handleMsgs when triggering dest="+t.destination+" ,subject="+t.subject+" ,content= "+t.content+" ,e="+JSON.stringify(i.message))}}}function U(e){return Ze.readCookie(e)||null}function x(e,t,n,i,r){et="true"===Me.isPartitionCookieEnabled||Me.isPartitionCookieEnabled===!0;D("_setCookie with parameters: name - "+e+" isPartionedCookieEnabled - "+et);Ze.writeSessionCookie(e,t,n,i,r,et?!0:!1,et?"none":void 0,et?!0:!1)}function V(e,t,n){U(e)&&Ze.clearCookie(e,t,n)}function L(){Me.rmVisitor&&F();Me.rmSession&&j();Me.lpVisitorId&&A(Me.lpVisitorId);Me.lpSessionId&&J(Me.lpSessionId);Me.useSecureStorage&&ke&&!Me.secureStorageUnSupported&&q()}function J(e){Ee=e;Me.useStorage?Je.setSessionData("LPSID-"+Me.accountId,e):x("LPSID-"+Me.accountId,e,void 0,"/",Me.domain);Me.lpSessionId=void 0}function A(e){Pe=e;Me.useStorage?Je.setSessionData("LPVID",e):x("LPVID",e,"undefined"!=typeof Me.expiration?Me.expiration:31536e3,"/",Me.domain);Me.lpVisitorId=void 0}function j(){delete Me.lpSessionId;Ee=null;Je.removeSessionData("LPSID-"+Me.accountId);V("LPSID-"+Me.accountId,"/",Me.domain)}function F(){delete Me.lpVisitorId;Pe=null;Je.removeSessionData("LPVID");V("LPVID","/",Me.domain)}function q(){(Pe||Ee)&&_e.setValue({key:ze,site:Me.accountId,app:Xe,value:{vid:Pe,sid:Ee},success:B,error:$,appName:Le,domain:Me.secureStorageLocation,firstParty:!0})}function M(e){_e.getValue({key:ze,site:Me.accountId,app:Xe,success:K.bind(this,e),error:W.bind(this,e),appName:Le,domain:Me.secureStorageLocation,firstParty:!0})}function K(e,t){Pe=t&&t.vid;Ee=t&&t.sid;e()}function W(e,t){$(t);e()}function B(e){D("Setting data on secureStorage.setValue in _setDataInSecureStorage. Data = "+JSON.stringify(e))}function $(e){b("Failed on secureStorage get/setValue. Error = "+JSON.stringify(e))}function z(){var e=Me.lpLastVisit;if(e){Je.setPersistentData("lpLastVisit-"+Me.accountId,e);Me.lpLastVisit=void 0}}function G(e){if(e.sdkConf)for(var t in e.sdkConf)Me[t]=e.sdkConf[t]}function H(e,t){return t===je.ok&&!e.error}function Q(e){var t=g();t&&(e.data.vid=t);var n=p();n&&(e.url=X(e.url,"sid",n));return e}function Z(e){var t;if(e.data.t===Ae.startPage){t=Je.getPersistentData("lpLastVisit-"+Me.accountId);t&&(e.data.rvt=t)}}function X(e,t,n){if(e.indexOf(t)>-1){var i=new RegExp("([?&])"+t+"=.*?(&|$)","i");return e.replace(i,"$1"+encodeURIComponent(t)+"="+encodeURIComponent(n)+"$2")}var r=encodeURIComponent(t)+"="+encodeURIComponent(n);e+=e.indexOf("?")===e.length-1?r:e.indexOf("?")>-1&&e.indexOf("?")<e.length?"&"+r:"?"+r;return e}function Y(e,t){var n="https://"+Me.acCdnDomain+"/api/account/"+lpTag.site+"/configuration/le-connectors/all-connectors";xe.issueCall({url:n,timeout:5e3,retries:0,credentials:Ye?"omit":void 0,cache:Ye&&Ue?Ue:void 0,success:function(t){D("_getAllConnectors - Success");var n=Ye?t&&t.body:t;e(n)},error:function(){D("_getAllConnectors - ERROR FROM SERVER");t()}})}function ee(e,t){var n,i="lpTag.taglets.unAuthMessaging.lpUnauthFunction",r="lpTag.taglets.unAuthMessaging",a=lpTag.features&&lpTag.features.getFeature("Common.Multiple_Consumer_IDP");if(a&&e.length&&t&&t.length)for(var o=0;o<e.length;o++)for(var s=e[o].configuration,c=0;c<t.length;c++)if(s.issuer===t[c].iss){n={type:e[o].type,id:e[o].id};return n}e.forEach(function(e){var t=e&&e.configuration;t&&t.jsContext!==r&&t.jsMethodName!==i&&(n={type:e.type,id:e.id})});return n}function te(e,n){function i(){ve("getValue",{success:r,error:function(){Y(o,u)}})}function r(e){if(e){He=e;Y(o,u)}else{l=p&&p.conf&&p.conf.isStepUpEnabled;if(l){if(g.stepUpChecked){a();return}lpTag.events.once({eventName:"STEPUP_CHECKED",appName:"*",func:function(){a()}})}else Y(o,u)}}function a(){if(g.stepUpChecked.isStepUp){n(S);lpTag.identitiesObjects=lpTag.identitiesObjects.concat(f)}else Y(o,u);g.stepUpChecked=null}function o(e){var t,n,i=ee(e,f),r={};if(i){if(1===i.type){t="id_token";n="https://"+Me.idpDomain+"/api/account/"+lpTag.site+"/app/"+i.id+"/authenticate?v=3.0"}else if(2===i.type){t="code";n="https://"+Me.idpDomain+"/api/account/"+lpTag.site+"/app/"+i.id+"/authenticate?v=3.0"}f.forEach(function(e){var i=e;r[t]=i.tkn;i.redirect_uri&&(r.redirect_uri=i.redirect_uri);if(He&&He.tkn){var a=s(He.tkn);if(a&&a.exp&&Date.now()<1e3*a.exp){i.tkn=He.tkn;S.push(i);c();return}ve("removeValue")}var o={url:n,data:r,method:"POST",success:function(e){var n=e.body&&e.body.token;if(n){D("fetched secure identity JWT from IDP: "+i.tkn+", "+i.iss+", "+i.acr);i.tkn=n;S.push(i);ve("setValue",{value:{tkn:n,code:r[t]}})}else b("no token in response from IDP for secure identity: "+i.tkn+", "+i.iss+", "+i.acr);c()},error:function(e){b("sending secure identity to IDP failed: "+i.tkn+", "+i.iss+", "+i.acr+", error: "+e);c()}};if(Ye){o.headers=o.headers||{};o.headers["Content-Type"]="application/json";xe.issueCall(o)}else Re.issueCall(o)})}else{D("undefined connector auth type");e.length&&c()}}function s(e){if(e){var t=e.split(".");if(t.length>=2)try{return JSON.parse(window.atob(t[1]))}catch(n){return!1}}return!1}function c(){v-=1;0>=v&&n(S)}function u(){n(S)}var l,d=e.filter(function(e){return!!e&&"undefined"!=typeof e.acr}),p=lpTag.taglets.lpUnifiedWindow&&lpTag.taglets.lpUnifiedWindow.inspect(),g=lpTag.taglets.lpUnifiedWindow;lpTag.identities.safeIdentities=d.map(function(e){var t={};for(var n in e)e.hasOwnProperty(n)&&"tkn"!==n&&(t[n]=e[n]);return t});var f=d.filter(function(e){return e.hasOwnProperty("tkn")}),m=d.filter(function(e){return!e.hasOwnProperty("tkn")}),S=[].concat(m),v=f.length;if(v>0)ke?i():t(i);else{He=null;n(S)}}function ne(e,t){function n(e){r-=1;a=a.concat(e);if(0>=r){try{for(var n=[],i=0;i<a.length;i++){for(var o=!0,s=0;s<n.length;s++)if(n[s].iss===a[i].iss&&n[s].acr===a[i].acr&&n[s].sub===a[i].sub&&n[s].account===a[i].account){o=!1;break}o&&n.push(a[i])}a=n}catch(c){}t(a)}}var i=e.filter(function(e){return"function"==typeof e}),r=i.length,a=[];r>0?i.forEach(function(e){try{e(n)}catch(t){n()}}):n()}function ie(e){O("Called _prepareRequest with params: "+JSON.stringify(e));var t,n;if(e.data)t=e.data.sdes;else{t=qe;qe=[]}n=ae(e);Q(n);Z(n);e.type===Ae.startPage&&oe(n);t=re(t);t&&t.length>0&&(n.data.sdes=t);var i=tt.debug();i&&(n.data.dbg=i);return n}function re(e){var t,n=Array.isArray(e)&&e.length>0;if(n&&lpTag.hooks&&lpTag.hooks.exec){t=lpTag.hooks.exec({name:Fe.BEFORE_SEND_SDE,data:{sdes:e}});e=t&&t.data&&Array.isArray(t.data.sdes)&&t.data.sdes}return e}function ae(e){return{rid:e.rid,data:{t:e.type,ts:(new Date).getTime(),pid:We,tid:Be},method:"POST",encoding:lpTag.charset||"UTF-8",transportOrder:["jsonp","postmessage"],success:function(t){e.result=t;e.status=je.ok;N(e)},error:function(t){e.result=t;e.status=je.err;N(e)},url:Me.protocol+Me.baseUrl+Me.apiPath+"/"+Me.accountId+"?"}}function oe(e){e.timeout=Me.timeout;var t=tt.title();t&&(e.data.pt=t);var n=tt.url();n&&(e.data.u=n);var i=tt.referrer();i&&(e.data.r=i);var r=tt.section();r&&(e.data.sec=r);lpTag.device&&lpTag.device.family&&(e.data.df=lpTag.device.family());lpTag.device&&lpTag.device.os&&(e.data.os=lpTag.device.os());var a=tt.emtVisitorId();a&&(e.data.evid=a)}function se(e){he.push(e);ue()}function ce(e,t){if(e.error)try{e.error(t)}catch(n){b("Failed calling client onError _callClientCbOnError e="+n)}}function ue(){if(!ye&&he.length>0&&be){O("Called _processPendingSyncRequests, initiating a new sync request: "+he.length+" inProgress: "+JSON.stringify(ye));var e=he.shift();e=Q(e);ye=e;try{I(e)}catch(t){b("Failed on lpAjax.issueCall in _processPendingSyncRequests. e: "+JSON.stringify(t.message));ce(e,{error:{code:"500",message:"error while issue request: "+JSON.stringify(t.message)}})}}else D("Called _processPendingSyncRequests no sync requests to initiate, pending: "+he.length+" inProgress: "+JSON.stringify(ye))}function le(){O("Called _syncRequestFinished");ye=void 0}function de(){ge()}function pe(e){O("Called _initPageCb isSuccess: "+e);e&&(be=!0);ge()}function ge(){le();ue()}function fe(){O("Called _asyncRequestCb");De=!1}function me(e){ye=e;try{lpTag.taglets.lpAjax.issueCall(e)}catch(t){b("Failed on lpAjax.issueCall in _sendInitializingRequest. requestId: "+e.rid+", e="+JSON.stringify(t.message))}}function Se(e){e.rid=P();var t=ie(e);Ke[e.rid]={req:t,cOnSuccess:e.onSuccess,cOnError:e.onError};return t}function ve(e,t){var n={app:Xe,appName:Le,site:lpTag&&lpTag.site,domain:Me.secureStorageLocation,firstParty:!0};n.key=t&&t.key||Ge;n.success=t&&t.success?t.success:function(){};n.error=t&&t.error?t.error:function(){b("Error on secure storage, action - "+e)};t&&t.value&&(n.value=t.value);"function"==typeof _e[e]&&_e[e](n)}var he,ye,Te,Ce,be,Oe,De,Pe,Ee,Ie,ke,Ne,we,_e,Re,Ue,xe,Ve="3.4.0",Le="lp_monitoringSDK",Je=lpTag.storageMethods,Ae={startPage:"sp",pageLoaded:"pl",inPage:"ip",updateContext:"uc"},je={err:"ERROR",ok:"OK"},Fe={BEFORE_SEND_SDE:"BEFORE_SEND_SDE"},qe=[],Me={},Ke={},We=E(),Be=k(),$e=0,ze="lpsmt",Ge="lpsmtAuth",He=null,Qe="Common.LiveEngage_2_CrossDomainStorage",Ze=lpTag.cookieMethods,Xe="monitoringSDK",Ye=!1,et=!1;lpTag.identities=lpTag.identities||[];lpTag.identitiesObjects=lpTag.identitiesObjects||[];lpTag.identitiesSupport=!0;var tt={referrer:function(){var e;document.referrer&&document.referrer.length>0&&(e=document.referrer);return e},title:function(){var e;document.title&&document.title.length>0&&(e=document.title);return e},url:function(){var e;lpTag.url?e=lpTag.url:window.location.href&&window.location.href.length>0&&(e=window.location.href);return e},debug:function(){var e=Je.getPersistentData("lpDebug-"+Me.accountId);if(e&&!Oe){Oe=!0;return!0}return!1},section:function(){var e=lpTag.section;"string"==typeof e&&e.length&&(e=[e]);return e},emtVisitorId:function(){return U(Me.accountId+"-VID")},identities:function(e){ne(lpTag.identities,function(t){te(t,function(t){e(t.map(function(e){var t={iss:e.iss,acr:e.acr};e.sub?t.sub=e.sub:e.tkn&&(t.tkn=e.tkn);e.account&&(t.account=e.account);e.redirect_uri&&(t.redirect_uri=e.redirect_uri);return t}))})})}};return{v:Ve,name:Le,inspect:T,init:e,sdes:{push:l},hooks:Fe,appendCtx:m,isTPCEnabled:f,getVid:g,getSid:p,getSidPrefix:d,send:u,inPage:c,pageLoaded:s,startPage:a,stop:h,reset:v,reinit:y,stringify:S}}();}catch(e){lpTag.handleGeneralError("lp_monitoringSDK",e);}try{window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.lpajax_utils={_name:"lpajax_utils",_v:"0.1",each:function(e,t,r){if(null!=e){var a=Array.prototype.forEach;if(a&&e.forEach===a)e.forEach(t,r);else if(e.length===+e.length){for(var n=0,o=e.length;o>n;n++)if(n in e&&t.call(r,e[n],n,e)==={})return}else for(var l in e)if(Object.prototype.hasOwnProperty.call(e,l)&&t.call(r,e[l],l,e)==={})return}},extend:function(e){this.each(Array.prototype.slice.call(arguments,1),function(t){for(var r in t)e[r]=t[r]});return e},isEmptyObj:function(e){for(var t in e)return!1;return!0},init:function(){}};window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.lpAjax=lpTag.taglets.lpAjax||function(e){function t(){m=!0}function r(t,r){e.lpTag&&lpTag.log&&lpTag.log(t,r,f)}function a(e,t){if(g[e])r("Existing transport: "+e+" tried to register",h.DEBUG);else{g[e]=t;r("Added transport: "+e,h.DEBUG)}}function n(e){m||t();var a,n="unknown";try{a=i(e);if(a){a.issueCall(e);return!0}r("No Transport found to issueCall",h.ERROR);c(h.ERROR,e.error,{responseCode:601,error:"No Transport found to issueCall, request: "+e.url,body:"ERROR"},e.context)}catch(o){a&&a.getName&&(n=a.getName());r("Transport - "+n+" - unknown exception while issueCall",h.ERROR);c(h.ERROR,e.error,{responseCode:600,error:"Transport - "+n+" - unknown exception while issueCall: "+e.url+" e="+o,body:"ERROR"},e.context)}}function o(e){m||t();for(var r in e){var a=g[r];a&&a.configure(e[r])}}function l(e){if(e&&"object"==typeof e){e.appName=p;e.ts=(new Date).getTime();e.tags&&e.tags.constructor===Array&&e.tags.push({pageId:y});r(e,h.METRICS)}}function i(e){for(var t,r=!1,a=-1,n=0;n<e.transportOrder.length;n++)if(!r){t=u({},e);var o=g[t.transportOrder[n]];if(o&&o.isValidRequest&&o.isValidRequest(t)){r=!0;a=n}}return r?g[t.transportOrder[a]]:null}function s(e,t,r){if(null!=e){var a=Array.prototype.forEach;if(a&&e.forEach===a)e.forEach(t,r);else if(e.length===+e.length){for(var n=0,o=e.length;o>n;n++)if(n in e&&t.call(r,e[n],n,e)==={})return}else for(var l in e)if(Object.prototype.hasOwnProperty.call(e,l)&&t.call(r,e[l],l,e)==={})return}}function u(e){s(Array.prototype.slice.call(arguments,1),function(t){for(var r in t)e[r]=t[r]});return e}function c(e,t,a,n){if("function"==typeof t)try{t.call(n||null,a);t=null}catch(o){r("runCallback: Exception in execution of callback, type :"+e+" e=["+o.message+"]",h.ERROR)}else r("runCallBack: No callback, of type :"+e,h.INFO)}var d="1.1.3",f="lpAjax",p="lpTransporter",g={},m=!1,h={ERROR:"ERROR",DEBUG:"DEBUG",INFO:"INFO",METRICS:"METRICS"},y="lpT"+Math.floor(1e5*Math.random())+"_"+Math.floor(1e6*Math.random());return{getVersion:function(){return d},getName:function(){return f},init:t,publishMetrics:l,issueCall:n,configureTransports:o,addTransport:a}}(window);window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.jsonp=lpTag.taglets.jsonp||function(e){function t(){if(lpTag&&lpTag.taglets&&lpTag.taglets.lpAjax)try{lpTag.taglets.lpAjax.addTransport(W,z)}catch(e){}E()}function r(e){if(e)for(var r in e)D.hasOwnProperty(r)&&e.hasOwnProperty(r)&&(D[r]=e[r]);t()}function a(t){var r=!1;if(M&&t&&t.url){var a=!1;t.callbackName&&"string"==typeof t.callbackName&&(Q[t.callbackName]||e[t.callbackName])&&(a=!0);var n;try{n=c(t)}catch(o){k("Could not evaluate the length  of the request, e="+o,L.ERROR,"isValidRequest");r=!1}"undefined"!=typeof n&&U>n&&!a&&(r=!0)}return r}function n(e){var t;if(!a(e)){k("URL request was too long or static callback name already exists, url: "+t,L.ERROR,"issueCall");T();e&&e.error&&F(L.ERROR,e.error,s(600,"Transport - JSONP - unable to run request: "+e.url),e.context);return!1}e=l(e);e.callbackName&&"string"==typeof e.callbackName?e.retries=0:e.callbackName=q+i();t=e.url+(e.url.indexOf("?")>-1?"&":"?")+e.callback+"="+e.callbackName;e.data&&(t+="&"+d(e.data));e.query&&(t+="&"+d(e.query));e.callUrl=t;if(p(e)){I(e);g()}else k("URL request was too long and was not sent, url: "+t,L.ERROR,"issueCall");return!0}function o(){var e={};for(var t in D)D.hasOwnProperty(t)&&(e[t]=D[t]);return e}function l(e){if("string"==typeof e){var t=e;e={url:t}}if(!e.url)return!1;e.encoding=e.encoding||D.encoding;e.callback=e.callback||D.callback;e.retries="number"==typeof e.retries?e.retries:D.retries;e.timeout=e.timeout?e.timeout:D.timeout;return e}function i(e){var t,r=99999,a="x";t=e?r+a+r:Math.round(Math.random()*r)+a+Math.round(Math.random()*r);return t}function s(e,t){return{statusCode:e,responseCode:e,error:t,body:"ERROR"}}function u(){return"scr"+Math.round(999999999*Math.random())+"_"+Math.round(999999999*Math.random())}function c(e){var t=H;e.callbackName&&"string"==typeof e.callbackName&&(t=e.callbackName.length);return 4+(e.callback||D.callback).length+e.url.length+t+d(e.data).length+d(e.query).length}function d(e){var t="";if("string"==typeof e)t+=e;else{var r=!0;for(var a in e){var n;"object"==typeof e[a]?n=f(e[a]):"function"!=typeof e[a]&&(n=e[a]);if("undefined"!=typeof n){r||(t+="&");t+=encodeURIComponent(a)+"="+encodeURIComponent(n);r=!1}}}return t}function f(e){var t;if("function"==typeof Array.prototype.toJSON){var r=Array.prototype.toJSON;delete Array.prototype.toJSON;try{t=JSON.stringify(e)}catch(a){Array.prototype.toJSON=r;throw a}Array.prototype.toJSON=r}else t=JSON.stringify(e);return t}function p(t){var r,a=!1,n=new RegExp(/(http{1}s{0,1}?:\/\/)([^\/\?]+)(\/?)/gi);r=n.exec(0===t.callUrl.indexOf("http")?t.callUrl:e.location.href);if(r&&r.length>=3&&""!==r[2]){var o=r[2].toLowerCase();t.domainMatch=o;_[o]=_[o]||[];_[o].inFlight=_[o].inFlight||0;_[o].push(t);a=!0;G+=1;k("buffered URL: "+t.callUrl,L.DEBUG,"lpTag.taglets.jsonp.bufferRequest")}else k("NO MATCH for URL: "+t.callUrl,L.ERROR,"lpTag.taglets.jsonp.bufferRequest");return a}function g(){var e;for(var t in _)if(_.hasOwnProperty(t)){e=_[t];for(var r=!1;!r&&e.inFlight<6&&e.length>0;){var a=e.shift();if(a){k("Sent URL: "+a.callUrl,L.DEBUG,"lpTag.taglets.jsonp.sendRequests");a.scriptId=h(a.callUrl,a.encoding,a.callbackName);a.startTime=(new Date).getTime();y(t,a.callbackName,a.timeout);G-=1}else r=!0}}e=null}function m(){clearTimeout(A);A=null;var t=new Date;for(var r in Q)if(Q.hasOwnProperty(r)&&Q[r].launchTime){var a=t-Q[r].launchTime;(Q[r].loadTime||a>Q[r].timeout)&&e[r].apply(null,[s(408,{message:"Request timed out",name:"timeout"}),!0])}P>0&&(A=setTimeout(m,1e3))}function h(t,r,a){var n=u(),o=document.createElement("script");o.setAttribute("type","text/javascript");o.setAttribute("charset",r);o.onload=function(){Q[a]&&(Q[a].loadTime=new Date);this.onload=this.onerror=this.onreadystatechange=null};e.addEventListener?o.onerror=function(){Q[a]&&(Q[a].loadTime=new Date);this.onload=this.onerror=this.onreadystatechange=null}:o.onreadystatechange=function(){if(this.readyState&&("loaded"===this.readyState||"complete"===this.readyState)){Q[a]&&(Q[a].loadTime=new Date);this.onload=this.onerror=this.onreadystatechange=null}};o.setAttribute("src",t);o.setAttribute("id",n);document.getElementsByTagName("head")[0].appendChild(o);A||(A=setTimeout(m,1e3));o=null;return n}function y(e,t,r){_[e].inFlight=_[e].inFlight+1;Q[t]={launchTime:new Date,timeout:r};P+=1;S+=1}function T(){B+=1}function R(e){var t=document.getElementById(e);if(t)try{t.parentNode.removeChild(t)}catch(r){k("error when removing script",L.ERROR,"removeScript")}}function v(e){_[e].inFlight=_[e].inFlight-1;P-=1}function O(e,t,r){N(t.startTime,t.url,r);R(t.scriptId);v(t.domainMatch);x(t.callbackName,r);if(r){if(t.callbackName){t.callbackName=null;delete t.callbackName}w(e,t)}else{C(t);F("callback",t.success,e,t.context);t=null;g()}}function b(){var e;if(lpTag.taglets.lpAjax&&lpTag.taglets.lpAjax.publishMetrics&&V.length>0){e={tags:[{transport:W}],metrics:V};lpTag.taglets.lpAjax.publishMetrics(e);V.length=0}E()}function E(){j&&clearTimeout(j);j=setTimeout(b,D.metricsTimeout)}function N(e,t,r){var a,n;if(e){n=(new Date).getTime();a=n-e;V.push({rd:a,ts:e,url:t,method:"GET",statusCode:r?400:200});V.length>=D.metricsCount&&b()}}function w(e,t){J+=1;if(t.retries>0){t.retries=t.retries-1;n(t)}else{C(t);F(L.ERROR,t.error,e||s(408,{id:408,name:"TIMEOUT",message:"Request has timed out on all retries"}),t.context);t=null;g()}}function C(e){for(var t=["callUrl","retries","id","requestTimeout","type","encoding","launchTime","callbackName","domainMatch","startTime"],r=0;r<t.length;r++)if(e.hasOwnProperty(t[r])){e[t[r]]=null;delete e[t[r]]}}function F(e,t,r,a){if("function"==typeof t)try{t.call(a||null,r);t=null}catch(n){k("Exception in execution of callback, type :"+e+" e=["+n.message+"]",L.ERROR,"runCallback")}else k("No callback, of type :"+e,L.INFO,"runCallback")}function x(t,r){Q[t]=null;delete Q[t];if(r===!0)e[t]=function(){e[t]=null;try{delete e[t]}catch(r){}};else{e[t]=null;try{delete e[t]}catch(a){}}}function I(t){if(Q[t.callbackName]){T();w(s(409,{message:"This callbackName is already in a pending request and can't be serviced",id:409,name:"CONFLICT"}),t)}else e[t.callbackName]=function(e,r){O(e,t,r)}}function k(t,r,a){if(e.lpTag&&lpTag.log){"string"==typeof t&&a&&(t=a+": "+t);lpTag.log(t,r,W)}}var A,j,D={callback:"cb",encoding:"UTF-8",timeout:1e4,retries:2,metricsCount:100,metricsTimeout:6e4},L={ERROR:"ERROR",DEBUG:"DEBUG",INFO:"INFO"},M=!0,U=2083,q="lpCb",_={},S=0,G=0,P=0,B=0,J=0,V=[],Q={},H=i(!0).length,K="1.1.7",W="jsonp",z={init:t,configure:r,issueCall:n,isValidRequest:a,getVersion:function(){return K},getName:function(){return W},getDefaults:o,inspect:function(){return{name:W,version:K,callsMade:S,errorsFound:J,pending:P,buffered:G,refused:B,defaults:o()}}};t();return z}(window);window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.postmessage=lpTag.taglets.postmessage||function(e){function t(e){var t=0===location.protocol.indexOf("https");if(e){if(e.frames){e.frames=e.frames.constructor===Array?e.frames:[e.frames];for(var r=0;r<e.frames.length;r++)g(e.frames[r],t)}if(e.defaults)for(var a in e.defaults)Te.hasOwnProperty(a)&&e.defaults.hasOwnProperty(a)&&(Te[a]=e.defaults[a])}re=!0}function r(){if(lpTag&&lpTag.taglets&&lpTag.taglets.lpAjax)try{lpTag.taglets.lpAjax.addTransport(te,Oe)}catch(e){}}function a(t){var r=!1;if(e.postMessage&&e.JSON&&t&&t.success&&(t.domain&&t.validation||t.url)){t.domain=t.domain||p(t.url);(ae[t.domain]||ue[t.domain])&&(r=!0)}return r}function n(e){var t=!1;if(re&&a(e))if(ae[e.domain])if(ae[e.domain].validated!==ve.PENDING||e.validation){t=L(e);t?v(e.domain):ne[e.callId].timeout=0}else t=O(e.domain,e);else{Y("Adding iFrame to DOM - first request: "+e.domain,fe.INFO,"issueCall");t=O(e.domain,e);m(ue[e.domain]);delete ue[e.domain]}else t=D(e.domain,e.error,e.context);return t}function o(e){return e&&ae[e]?{url:ae[e].url,validated:ae[e].validated,requestCount:ae[e].requestCount,defaults:S(ae[e].defaults),started:ae[e].validated===ve.VALIDATED}:{}}function l(){var e={};for(var t in ae)ae.hasOwnProperty(t)&&(e[t]=o(t));return e}function i(e,t,r){e.addEventListener?e.addEventListener(t,r,!1):e.attachEvent("on"+t,r)}function s(e,t){return{callId:e,responseType:t.responseType,responseCode:t.responseCode,error:{message:t.message,id:t.responseCode,name:t.name}}}function u(e,t,r){e.removeEventListener?e.removeEventListener(t,r,!1):e.detachEvent&&e.detachEvent("on"+t,r)}function c(){if(document.body){ce=!0;d()}else setTimeout(c,5)}function d(){for(;de.length>0;)try{de.shift().call(null)}catch(e){Y("Unable to execute queued callbacks for window interactive state: "+e,fe.ERROR,"_attachPendingIFrames")}}function f(e){return e+"_"+Math.floor(1e5*Math.random())+"_"+Math.floor(1e5*Math.random())}function p(e){var t,r=new RegExp(/(http{1}s{0,1}?:\/\/)([^\/\?]+)(\/?)/gi),a=null;if(0!==e.indexOf("http"))return location.protocol+"//"+location.host;t=r.exec(e);t&&t.length>=3&&""!==t[2]&&(a=t[1].toLowerCase()+t[2].toLowerCase());return a}function g(e,t){var r,a,n=!1;if(!e||!e.url||"string"!=typeof e.url){Y("iFrame configuration empty or missing url parameter",fe.ERROR,"_queueFrame");return n}r=p(e.url);a=0===e.url.toLowerCase().indexOf("https");if(!(ae[r]||ue[r]||t&&a!==t)){ue[r]=e;n=!0}return n}function m(e){var t=p(e.url);if(ae[t])return b(t,e.callback||e.success,e.context);var r=f("fr");ae[t]={elem:E(r),url:e.url,validated:ve.PENDING,defaults:e.defaults||{},delayLoad:isNaN(e.delayLoad)?0:e.delayLoad,requestCount:0,success:e.callback||e.success,error:e.error,maxReloadRetries:e.maxReloadRetries||3,reloadInterval:1e3*e.reloadInterval||3e4};setTimeout(function(){y(e.url,t)},ae[t].delayLoad);Y("iFrame Queued to load "+t,fe.INFO,"_addFrame");return ve.PENDING}function h(e){var t=p(e.url);ue[t]={url:e.url,defaults:e.defaults||{},delayLoad:e.delayLoad,success:e.success,error:e.error,maxReloadRetries:e.maxReloadRetries,reloadInterval:e.reloadInterval/1e3}}function y(e,t){ce?T(e,t):de.push(function(){T(e,t)})}function T(e,t){ae[t].loadCallback=ae[t].loadCallback||R(t);V(ae[t].elem,e);i(ae[t].elem,"load",ae[t].loadCallback);ae[t].iFrameOnloadTimeout=setTimeout(ae[t].loadCallback,Re);ae[t].attachTime=(new Date).getTime();document.body.appendChild(ae[t].elem)}function R(e){return function(t){if(ae[e].iFrameOnloadTimeout){clearTimeout(ae[e].iFrameOnloadTimeout);delete ae[e].iFrameOnloadTimeout}ae[e].loadTime=(new Date).getTime()-ae[e].attachTime;C(e,t)}}function v(e){le+=1;se+=1;ae[e].requestCount=ae[e].requestCount+1}function O(e,t){oe[e]=oe[e]||[];oe[e].push(t);return!0}function b(e,t,r){var a=o(e);W(t,r,a);return ae[e].validated}function E(e){var t=document.createElement("IFRAME");t.setAttribute("id",e);t.setAttribute("name",e);t.setAttribute("tabindex","-1");t.setAttribute("aria-hidden","true");t.setAttribute("title","");t.setAttribute("role","presentation");t.style.width="0px";t.style.height="0px";t.style.position="absolute";t.style.top="-1000px";t.style.left="-1000px";t.style.display="none";return t}function N(e,t,r,a,n,o){var l=!1;if(e&&t&&"function"==typeof t){ne[e]={success:t,error:r,progress:a,ctx:n,launchTime:new Date,timeout:isNaN(o)?Te.timeout:o+1e3};l=!0}return l}function w(e){if(ne[e]){ne[e]=null;delete ne[e];return!0}return!1}function C(e,t){Y("onLoad validation called "+e,fe.INFO,"_validateFrame");var r=function(t){F(t,e)};t&&t.error?F(t,e):setTimeout(function(){n({domain:e,success:r,error:r,validation:!0,timeout:100,retries:-1,defaults:ae[e].defaults})},10);return!0}function F(e,t){var r,a=ae[t];Y("running validation of domain "+t,fe.INFO,"_validateFrameCallback");if(a){ae[t].validated=e&&e.error?ve.FAILED:ve.VALIDATED;r=ae[t].validated===ve.VALIDATED;r?x(t,e):ae[t].reloadObj&&ae[t].reloadObj.retriesLeft>0?k(t):I(t)}a=null;return r}function x(e,t){var r;Y("FrameLoaded "+e,fe.INFO,"_runFrameValidated");r=S(he);for(var a in t)t.hasOwnProperty(a)&&(r[a]=t[a]);W(ae[e].success,ae[e].context,r);H(e);A(e,!0)}function I(e){Y("iFrame is a teapot "+e,fe.ERROR,"_runFrameFailedToLoad");if(ae[e].error){var t=s(0,ye);t.domain=e;W(ae[e].error,ae[e].context,t)}j(e);A(e,!1)}function k(e){Y("Retry loading domain: "+e,"info","_runReloadAttempt");A(e,!1);P(e)}function A(e,t){Y("Running buffer queue : "+e+" loaded: "+t,fe.INFO,"_runQueuedRequests");if(oe[e]&&oe[e].length>0){do{var r=oe[e].shift();t?n(r):W(r.error,r.context,{responseCode:600,error:"Transport - postmessage - unable to run request: "+e,body:"ERROR"})}while(oe[e].length>0);oe[e]=null;delete oe[e]}}function j(e){Y("Cleaning up failed iFrame: "+e,fe.INFO,"_cleanupIFrame");if(ae[e]){u(ae[e].elem,"load",ae[e].loadCallback);ae[e].elem.parentNode.removeChild(ae[e].elem);var t=S(ye);t.domain=e;t.url=ae[e].url;W(ae[e].error,ae[e].context,t);h(ae[e]);ae[e]=null;delete ae[e]}}function D(e,t,r){Y("Frame not found for domain: "+e,fe.ERROR,"_noFrameFound");W(t,{responseCode:600,error:"Transport - postmessage - unable to run request: "+e,body:"ERROR"},r);return!1}function L(e){var t,r=!1;e=U(e);t=S(e);try{t=M(t)}catch(a){Y("Error trying to _stringify message",fe.ERROR,"sendMessageToFrame");return!1}Y("sending msg to domain "+e.domain,fe.DEBUG,"sendMessageToFrame");var n;isNaN(e.timeout)||isNaN(e.retries)||(n=e.timeout*(e.retries+1)+2e3);N(e.callId,e.success,e.error,e.progress,e.context,n);try{r=q(e.domain,t);$=setTimeout(_,1e3)}catch(a){Y("Error trying to send message: "+a,fe.ERROR,"sendMessageToFrame");r=!1}return r}function M(e){var t;if("function"==typeof Array.prototype.toJSON){var r=Array.prototype.toJSON;delete Array.prototype.toJSON;try{t=JSON.stringify(e)}catch(a){Array.prototype.toJSON=r;throw a}Array.prototype.toJSON=r}else t=JSON.stringify(e);return t}function U(t){var r=ae[t.domain]&&ae[t.domain].defaults;t.callId=f("call");t.returnDomain=pe;"undefined"==typeof t.timeout&&(t.timeout=r&&r.timeout||Te.timeout);"undefined"==typeof t.retries&&(t.retries=r&&"undefined"!=typeof r.retries?r.retries:Te.retries);t.progress&&(t.fireProgress=!0);t.headers=t.headers||{};t.headers["LP-URL"]=e.location.href;return t}function q(e,t){var r=!1;try{ae[e].elem.contentWindow.postMessage(t,e);r=!0}catch(a){Y("Error trying to send message: "+a,fe.ERROR,"_postTheMessage")}return r}function _(){$&&clearTimeout($);$=null;var e=new Date,t=0,r=[];for(var a in ne)if(ne.hasOwnProperty(a)&&ne[a].launchTime){var n=e-ne[a].launchTime;n>ne[a].timeout?r.push(a):t+=1}if(r.length){Y("Checking errors found "+r.length+" timeout callbacks to call",fe.DEBUG,"_checkForErrors");for(var o=0;o<r.length;o++)G(s(r[o],me))}t>0&&($=setTimeout(_,1e3));return!0}function S(e){var t=e;try{t=JSON.parse(M(e))}catch(r){}return t}function G(e,t){var r,a=ne[e.callId],n=e.responseType,o=!1;if(e.callId&&ne[e.callId]||e.responseType===ge.reloading||e.responseType===ge.stats)try{switch(n){case ge.completed:r=a.success;o=!0;break;case ge.error:r=a.error;o=!0;ie+=1;break;case ge.progress:r=a.progress;break;case ge.reloading:e=t;r=P;break;case ge.stats:r=Z;e=e.rawData}if(o){w(e.callId);K(e);se=se>=0?0:se-1}r&&"function"==typeof r&&W(r,a&&a.ctx||null,e);r=null;a=null}catch(l){Y("Error in executing callback: "+l,fe.ERROR,"_executeMessageCallback");return!1}return!0}function P(e){Y("Got reload request from "+e,fe.INFO,"_handleReload");ae[e].validated=ve.PENDING;if(!ae[e].reloadObj){Y("Creating reloadObj"+e,fe.DEBUG,"_handleReload");ae[e].reloadObj=Q(e)}B(e)}function B(e){Y("Reload try for domain "+e+" ,retries left "+ae[e].reloadObj.retriesLeft,fe.INFO,"_reloadIFrame");ae[e].reloadObj.retriesLeft=ae[e].reloadObj.retriesLeft-1;ae[e].reloadObj.setLocationTimeout&&clearTimeout(ae[e].reloadObj.setLocationTimeout);if(ae[e].reloadObj.retry)ae[e].reloadObj.setLocationTimeout=setTimeout(J(e),ae[e].reloadInterval);else{ae[e].reloadObj.retry=!0;J(e)()}}function J(e){return function(){ae[e].iFrameOnloadTimeout=setTimeout(function(){C(e,{error:{code:404,message:"Frame did not trigger load"}})},Re);V(ae[e].elem,ae[e].url)}}function V(e,t){t+=t.indexOf("?")>0?"&bust=":"?bust=";t+=(new Date).getTime();t+="&loc="+encodeURIComponent(location.protocol+"//"+location.host);Y("Setting iFrame to URL: "+t,fe.INFO,"_setIFrameLocation");e.setAttribute("src",t)}function Q(e){Y("Creating reload object "+e,fe.INFO,"_createReloadObject");var t=ae[e].maxReloadRetries;return{retriesLeft:t}}function H(e){Y("Cleaning up reload object for this instance"+e,fe.INFO,"_cleanUpReloadObject");if(ae[e].reloadObj){ae[e].reloadObj.setLocationTimeout&&clearTimeout(ae[e].reloadObj.setLocationTimeout);ae[e].reloadObj=null;delete ae[e].reloadObj}}function K(e){for(var t=["callId","responseType"],r=0;r<t.length;r++){e[t[r]]=null;delete e[t[r]]}}function W(e,t,r){if(e&&"function"==typeof e)try{e.call(t||null,r)}catch(a){Y("Error in executing callback: "+a,fe.ERROR,"runCallback")}}function z(e){var t,r;try{r=e.origin;if(!ae[r])return;t=X(e.data);t.body=X(t.body)}catch(a){t=null;Y("Error in handling message from frame:"+a+" origin: "+r,fe.ERROR,"_handleMessage")}t&&"object"==typeof t&&G(t,r)}function X(e){var t=e;if("string"==typeof e)try{t=JSON.parse(e)}catch(r){Y("Error in parsing string: "+e,fe.DEBUG,"_parseJSONString")}return t}function Y(t,r,a){if(e.lpTag&&lpTag.log){"string"==typeof t&&a&&(t=a+": "+t);lpTag.log(t,r,te)}}function Z(e){if(lpTag.taglets.lpAjax&&lpTag.taglets.lpAjax.publishMetrics){e.tags&&e.tags.constructor===Array&&e.tags.push({transport:te});lpTag.taglets.lpAjax.publishMetrics(e)}}var $,ee="1.1.8",te="postmessage",re=!0,ae={},ne={},oe={},le=0,ie=0,se=0,ue={},ce=!1,de=[],fe={DEBUG:"DEBUG",INFO:"INFO",ERROR:"ERROR"},pe=p(document.location.href),ge={progress:"progressLoad",completed:"completeLoad",success:"success",error:"errorLoad",reloading:"reloading",stats:"statData"},me={responseType:ge.error,responseCode:404,message:"Request timed out on parent postMessage layer",name:"TIMEOUT"},he={responseType:ge.success,responseCode:200,message:"iFrame has successfully loaded",name:"OK"},ye={responseType:ge.error,responseCode:418,message:"This iFrame is a teapot, not very useful for communication but lovely for earl grey",name:"TEAPOT"},Te={timeout:6e4,metricsCount:1e3},Re=1e4,ve={VALIDATED:"valid",PENDING:"pending",FAILED:"failed"};c();i(e,"message",z);var Oe={v:ee,name:te,init:r,issueCall:n,isValidRequest:a,getVersion:function(){return ee},getName:function(){return te},configure:t,getFrameData:o,inspect:function(){return{name:te,version:ee,callsMade:le,errorsFound:ie,pending:se,defaults:Te,iFrameList:S(ue),activeFrames:l()}}};r();return Oe}(window);window.lpTag=lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.lpTransporter=lpTag.taglets.lpTransporter||function(){function e(e,t){window.lpTag&&lpTag.log&&lpTag.log(e,t,r)}function t(){for(var t=0;t<n.taglets.length;t++){var r=lpTag.taglets[n.taglets[t]];try{r.init();e("Called init on taglet: "+n.taglets[t],"DEBUG")}catch(a){e("Error init taglet:"+n.taglets[t]+"  e="+a,"ERROR")}}for(var o=0;t<n.taglets.length;o++){var l=lpTag.taglets[n.taglets[o]];try{"function"==typeof l.start&&l.start();e("Called start on taglet: "+n.taglets[o],"DEBUG")}catch(a){e("Error start taglet: "+n.taglets[o]+"e= "+a,"ERROR")}}}var r="lpTransporter",a="1.1.0",n={taglets:["lpAjax","lpajax_utils","jsonp","postmessage"]};return{v:a,name:r,init:t}}();}catch(e){lpTag.handleGeneralError("lpTransporter",e);}try{window.lpTag = window.lpTag || {};
lpTag.taglets = lpTag.taglets || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};

/**
 * This is a utility object.
 * Cna be used by every other class/taglet.
 *
 * Dependencies: none
 */
lpTag.taglets.lpUtil = lpTag.taglets.lpUtil || (function () {

    var name = "Utils";


    /**
 * Returns the index of obj inside arr, if not found will return -1
 * This is a fallback function for IE8.
 * @param arr
 * @param obj
 * @returns {number}
 */
function indexOf(arr, obj) {
    if (typeof [].indexOf === 'function' && typeof arr.indexOf === "function") {
        return arr.indexOf(obj);
    } else if(arr.constructor === Array) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === obj) {
                return i;
            }
        }
    }
    return -1;
}

/**
 * Returns a trimmed string or the passed variable if its type is different
 * @param value
 * @returns {*}
 */
function trim(value) {
    if (typeof value !== "string") {
        return value;
    }
    if (value.trim) {
        return value.trim();
    } else {
        return value.replace(/^\s+|\s+$/gm, '');
    }
}

/**
 * Returns the string value trimmed and converted to lowercase, or the passed variable if its type is different
 * @param value
 * @returns {*}
 */
function trimAndLower(value) {
    if (typeof value !== "string") {
        return value;
    }
    var returnValue = trim(value);
    return returnValue.toLowerCase();
}

/**
 * Gets the domain including protocol
 * @param url
 * @param fullPath
 *
 */
function getDomain(url, fullPath) {
    var domainRegEx = new RegExp(/((?:http|ftp|ws){1}s{0,1}?:\/\/){0,1}([^\/\?/:]+)(\/?)/ig),
        matches = domainRegEx.exec(url),
        domain = null;
    if (matches && matches.length >= 3 && matches[2] !== "") {
        domain = matches[2].toLowerCase(); // 0 - full match 1- HTTPS 2- domain
        if (fullPath) {
            domain = matches[1] + domain;
        }
    }
    return domain;
}

function getURLParams(search) {
    var queryParams = {}, queryArray, singleQuery;

    if ("string" === typeof search) {
        queryArray = search.substr(1).split("&");
        for (var i = 0; i < queryArray.length; i++) {
            if (queryArray[i].indexOf("=") > -0) {
                singleQuery = queryArray[i].split("=");
                if (singleQuery.length == 2) {
                    queryParams[decodeURIComponent(singleQuery[0])] = decodeURIComponent(singleQuery[1]);
                }
            }
        }
    }

    return queryParams;
}

var IANADomains = {//Reference: http://en.wikipedia.org/wiki/List_of_Internet_top-level_domains
    customTopLevelDomain: { "aero": "aero", "asia": "asia", "bike": "bike", "biz": "biz", "camera": "camera", "cat": "cat", "clothing": "clothing", "coop": "coop", "equipment": "equipment", "estate": "estate", "eus": "eus", "gallery": "gallery", "graphics": "graphics", "guru": "guru", "info": "info", "int": "int", "holdings": "holdings", "jobs": "jobs", "lighting": "lighting", "mobi": "mobi", "museum": "museum", "name": "name", "photography": "photography", "plumbing": "plumbing", "post": "post", "pro": "pro", "singles": "singles", "tel": "tel", "travel": "travel", "ventures": "ventures", "xxx": "xxx" },
    topLevelDomain: { "ac": "ac", "co": "co", "com": "com", "edu": "edu", "gov": "gov", "mil": "mil", "net": "net", "org": "org" },
    countryTopLevelDomain: {"ac":"ac", "ad":"ad", "ae":"ae", "af":"af", "ag":"ag", "ai":"ai", "al":"al", "am":"am", "an":"an", "ao":"ao", "aq":"aq", "ar":"ar", "as":"as", "at":"at", "au":"au", "aw":"aw", "ax":"ax", "az":"az", "ba":"ba", "bb":"bb", "bd":"bd", "be":"be", "bf":"bf", "bg":"bg", "bh":"bh", "bi":"bi", "bj":"bj", "bm":"bm", "bn":"bn", "bo":"bo", "bq":"bq", "br":"br", "bs":"bs", "bt":"bt", "bv":"bv", "bw":"bw", "by":"by", "bz":"bz", "bzh":"bzh", "ca":"ca", "cc":"cc", "cd":"cd", "cf":"cf", "cg":"cg", "ch":"ch", "ci":"ci", "ck":"ck", "cl":"cl", "cm":"cm", "cn":"cn", "co":"co", "cr":"cr", "cs":"cs", "cu":"cu", "cv":"cv", "cw":"cw", "cx":"cx", "cy":"cy", "cz":"cz", "dd":"dd", "de":"de", "dj":"dj", "dk":"dk", "dm":"dm", "do":"do", "dz":"dz", "ec":"ec", "ee":"ee", "eg":"eg", "eh":"eh", "er":"er", "es":"es", "et":"et", "eu":"eu", "fi":"fi", "fj":"fj", "fk":"fk", "fm":"fm", "fo":"fo", "fr":"fr", "ga":"ga", "gb":"gb", "gd":"gd", "ge":"ge", "gf":"gf", "gg":"gg", "gh":"gh", "gi":"gi", "gl":"gl", "gm":"gm", "gn":"gn", "gp":"gp", "gq":"gq", "gr":"gr", "gs":"gs", "gt":"gt", "gu":"gu", "gw":"gw", "gy":"gy", "hk":"hk", "hm":"hm", "hn":"hn", "hr":"hr", "ht":"ht", "hu":"hu", "id":"id", "ie":"ie", "il":"il", "im":"im", "in":"in", "io":"io", "iq":"iq", "ir":"ir", "is":"is", "it":"it", "je":"je", "jm":"jm", "jo":"jo", "jp":"jp", "ke":"ke", "kg":"kg", "kh":"kh", "ki":"ki", "km":"km", "kn":"kn", "kp":"kp", "kr":"kr", "krd:":"krd", "kw":"kw", "ky":"ky", "kz":"kz", "la":"la", "lb":"lb", "lc":"lc", "li":"li", "lk":"lk", "lr":"lr", "ls":"ls", "lt":"lt", "lu":"lu", "lv":"lv", "ly":"ly", "ma":"ma", "mc":"mc", "md":"md", "me":"me", "mg":"mg", "mh":"mh", "mk":"mk", "ml":"ml", "mm":"mm", "mn":"mn", "mo":"mo", "mp":"mp", "mq":"mq", "mr":"mr", "ms":"ms", "mt":"mt", "mu":"mu", "mv":"mv", "mw":"mw", "mx":"mx", "my":"my", "mz":"mz", "na":"na", "nc":"nc", "ne":"ne", "nf":"nf", "ng":"ng", "ni":"ni", "nl":"nl", "no":"no", "np":"np", "nr":"nr", "nu":"nu", "nz":"nz", "om":"om", "pa":"pa", "pe":"pe", "pf":"pf", "pg":"pg", "ph":"ph", "pk":"pk", "pl":"pl", "pm":"pm", "pn":"pn", "pr":"pr", "ps":"ps", "pt":"pt", "pw":"pw", "py":"py", "qa":"qa", "re":"re", "ro":"ro", "rs":"rs", "ru":"ru", "rw":"rw", "sa":"sa", "sb":"sb", "sc":"sc", "sd":"sd", "se":"se", "sg":"sg", "sh":"sh", "si":"si", "sj":"sj", "sk":"sk", "sl":"sl", "sm":"sm", "sn":"sn", "so":"so", "sr":"sr", "ss":"ss", "st":"st", "su":"su", "sv":"sv", "sx":"sx", "sy":"sy", "sz":"sz", "tc":"tc", "td":"td", "tf":"tf", "tg":"tg", "th":"th", "tj":"tj", "tk":"tk", "tl":"tl", "tm":"tm", "tn":"tn", "to":"to", "tp":"tp", "tr":"tr", "tt":"tt", "tv":"tv", "tw":"tw", "tz":"tz", "ua":"ua", "ug":"ug", "uk":"uk", "us":"us", "uy":"uy", "uz":"uz", "va":"va", "vc":"vc", "ve":"ve", "vg":"vg", "vi":"vi", "vn":"vn", "vu":"vu", "wf":"wf", "ws":"ws", "ye":"ye", "yt":"yt", "yu":"yu", "za":"za", "zm":"zm", "zr":"zr"}
};

/**
 * Extracts the top parent domain for a specific domain
 */
function getParentDomain(hostName) {
    hostName = '' + hostName;
    var lowestIndex = null,
        domainSearch = {
            top: null,
            country: null
        },
        parts,
        sliceIndex;
    hostName = getDomain(hostName);

    parts = hostName.split(".");
    if (parts.length < 3) {//Less than 3 parts means it's always what we want
        return hostName;
    } else {
        var len = parts.length - 1;
        for (var i = len; i > -1; i--) {
            _getIndexOfDomainPart(parts[i], domainSearch, i);
            if (domainSearch.country !== null && domainSearch.top !== null) {
                break;
            }
        }
    }

    if (domainSearch.top !== null || domainSearch.country !== null) {
        lowestIndex = domainSearch.top;
        if (lowestIndex === null ||
            ((domainSearch.country !== null) &&
            domainSearch.country < lowestIndex &&
            (lowestIndex - 1 === domainSearch.country)) //If the country isn't adjacent to the top level domain, it is NOT part of the parent domain
        ) {
            lowestIndex = domainSearch.country;
        }

        sliceIndex = lowestIndex > 0 ? lowestIndex - 1 : lowestIndex;
        return _rebuildHostName(parts.slice(sliceIndex));
    } else {//We've got nothing.....at least let's not fail the request
        return hostName;
    }
}

/**
 * Rebuilds the top level domain
 */
function _rebuildHostName(res) {
    return res.join(".");
}

/**
 * Checks if the party is a valid IANA top level domain
 */
function _getIndexOfDomainPart(str, domainSearch, index) {

    str = "" + str;

    if (domainSearch.top === null && (IANADomains.topLevelDomain[str] ||
        IANADomains.customTopLevelDomain[str])) {
        domainSearch.top = index;
    } else if (domainSearch.country === null && IANADomains.countryTopLevelDomain[str]) {
        domainSearch.country = index;
    }
}

/**
 * This function adds (or overrides) query param key-value to url
 * @param url
 * @param params -  key-value object {key:<string> : value:<string|number>} or array of key-value objects [{key:<string>, value:<string|number>}]
 * @returns the function will return undefined value on bad input or the url with the additional parameters
 */
function addQueryParams(url, params) {
    var removeLastURLChar = /(\?|&|\/|\\)$/;

    if (typeof url === "string" && url.length > 0) {
        if (removeLastURLChar.test(url)) {
            url = url.substr(0, url.length - 1);
        }
        if (Array.isArray(params)) {
            return _addQueryParamsFromArray(url, params);
        } else if (_isKeyValueObject(params)) {
            return _addKeyValueObject(url, params);
        } else if (typeof params === "object") {
            return _addQueryParamFromObject(url, params);
        }
    }
    return url;
}


/*
@param url
@param params
@deprecated - this must be deprecated - stay only with _addQueryParamFromObject
 */
function _addQueryParamsFromArray(url, params) {
    var keyValueObject,
        result = url;

    for (var i = 0; i < params.length; i++) {
        keyValueObject = params[i];
        if (result && typeof keyValueObject === "object") {
            result = _addKeyValueObject(result, keyValueObject);
        } else {
            break;
        }
    }
    return result;
}

/*
 @param url
 @param obj
 @deprecated - this must be deprecated - stay only with _addQueryParamFromObject
 */
function _addKeyValueObject(url, obj) {
    if (!_isValidInput(url, obj)) {
        return url;
    }
    return _addKeyValue(url, obj.key, obj.value);
}


/*
 @param url - url string
 @param obj - object that its keys and values will be query params of the url
 */
function _addQueryParamFromObject(url, obj) {
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            url = _addKeyValue(url, key, obj[key]);
        }
    }
    return url;
}

function _addKeyValue(url, key, value) {
    var isParamExistsRegex = new RegExp("([?&])" + key + "=.*?(&|$)", "ig"),
        paramPrefix = url.indexOf('?') === -1 ? "?" : "&";

    if (typeof value === "object") {
        try {
            value = JSON.stringify(value);
        } catch (e) {
            /*ignore*/
        }
    }

    if (url.match(isParamExistsRegex)) {
        return url.replace(isParamExistsRegex, '$1' + key + "=" + value + '$2');
    } else {
        return url + paramPrefix + key + "=" + value;
    }
}

function _isValidInput(url, keyValuObject) {
    return (typeof url === "string" && url.length > 0) && _isKeyValueObject(keyValuObject);
}

function _isKeyValueObject(keyValuObject) {
    var key = keyValuObject && keyValuObject.key,
        value = keyValuObject && keyValuObject.value;

    return keyValuObject && typeof key === "string" && key.length > 0 && (typeof value === "number" || (typeof value === "string" && value.length > 0));
}


/**
 * Gets two objects (obj and extendObj) and boolean and returns:
 *  - obj, if its type differs from object
 *  - copy of obj, if extendObj is empty
 *  - object extendObj, extended with the obj object (recursively if deep is true)
 *    (undefined values from obj will not be copied to extendObj)
 * TODO: is not deep extending objects currently, should be recursively called as
 * TODO: cloneExtend(obj[prop], newObj[prop], deep) to keep the extendObj properties
 * @param obj
 * @param extendObj
 * @param deep
 * @returns {object}
 */
function cloneExtend(obj, extendObj, deep) {
    var newObj;

    if (!obj || "object" !== typeof obj) {
        return obj;
    }

    if (!extendObj) {
        return clone(obj);
    }

    newObj = extendObj || obj.constructor() || {};
    for (var prop in obj) {
        // Prevent never-ending loop
        if (newObj[prop] === obj[prop]) {
            continue;
        }

        if (obj.hasOwnProperty(prop)) {
            newObj[prop] = deep ? cloneExtend(obj[prop], void 0, deep) : obj[prop];
        }
    }

    return newObj;
}

/**
 * Gets an object and returns its copy
 * @param obj
 * @returns {object}
 */
function clone(obj) {
    try {
        return JSON.parse(stringify(obj));
    }
    catch (e) {
        lpTag.log('unable to clone object:' + JSON.stringify(e), 'ERROR', name);
        return;
    }
}

function convertConfig(conf, _config) {
    if (typeof(_config) == 'undefined') {
        lpTag.log('_config is passed as undefined', 'ERROR', name);
        return;
    }
    if (conf) {
        for (var i = 0; i < conf.length; i++) {
            var val = conf[i].value;
            if (typeof(val) === 'string' && val !== '') {
                if (val === 'true') {
                    val = true;
                }
                else if (val === 'false') {
                    val = false;
                }
                else if (val.charAt(0) == '[' || val.charAt(0) == '{') {
                    try {
                        val = JSON.parse(val);
                    } catch (e) {
                        lpTag.log('unable to parse JSON:' + JSON.stringify(e), 'ERROR', name);
                    }
                }
            }
            _config[conf[i].id] = val;
        }
    }
}

/**
 * This function allows for adding style tag to a document
 * @param {string} cssText - css style text
 * @param {object} options
 *                  document {object} - reference to window document object (default: window.document)
 *                  id {string} - id to provide to the style tag (default: undefined)
 */
function addStyleTag(cssText, options) {
    if (!cssText || typeof cssText !== "string") {
        return;
    }
    options = options || {};
    var _document = options.document || window.document;
    var id = options.id;

    var styleTag;
    if (typeof id !== 'undefined') {
        styleTag = _document.getElementById(id) || _document.createElement('style');
        styleTag.id = id;
    } else {
        styleTag = _document.createElement('style');
    }

    styleTag.type = 'text/css';
    _document.getElementsByTagName('head')[0].appendChild(styleTag);

    if (styleTag.styleSheet) {
        styleTag.styleSheet.cssText = cssText;
    } else {
        styleTag.appendChild(document.createTextNode(cssText));
    }
    return styleTag;
}

/**
 * This function returns the object consisting keys of a passed object
 * with the structure {key: key}
 * @param object
 * @returns {object}
 */
function objectKeys(object) {
    var keys = {};
    for (var key in object) {
        if (object.hasOwnProperty(key)) {
            keys[key] = key;
        }
    }
    return keys;
}

/**
 * This function enables to run a callback once the document body is ready
 * @param bodyReadyCallback
 * @param options
 *          context - context to run from
 *          document - document to refer to
 */
function waitForBody(bodyReadyCallback, options) {
    options = options || {};
    var context = options.context;
    var _document = options.document || window.document;

    _callback();

    function _callback() {
        if (_document.body) {
            runCallback(bodyReadyCallback, context);
        } else {
            setTimeout(_callback, 50);
        }
    }
}

/**
 * This function was added because of incompatibility between the JSON.stringify and Prototype.js library
 * When a costumer uses Prototype.js library, It overrides the Array.prototype.toJSON function the the native JSON
 * uses. This causes arrays to be double quoted and Shark to fail on those SDEs.
 * The function accepts a value and uses the native JSON.stringify
 * Can throw an exception (same as JSON.stringify).
 * @param value
 * @returns {string}
 */
function stringify(value) {
    var stringified, toJSONPrototype;
    if (typeof Array.prototype.toJSON === 'function') {
        toJSONPrototype = Array.prototype.toJSON;
        delete Array.prototype.toJSON;
        try {
            stringified = JSON.stringify(value);
        } catch (e) {
            Array.prototype.toJSON = toJSONPrototype;
            throw e;
        }
        Array.prototype.toJSON = toJSONPrototype;
    } else {
        stringified = JSON.stringify(value);
    }
    return stringified;
}

var cookieActions = {
    delimiter: '|',
    set: function (key, values, domain) {
        if (typeof key === 'string' && values.join && typeof (values.join) === "function") {
            var cookieString = encodeURIComponent(key) + '=' + encodeURIComponent(values.join(this.delimiter)) + ';path=/';
            if(typeof domain !== 'undefined'){
                cookieString += ';domain='+ domain;
            }
            document.cookie = cookieString;
            return true;
        }
    },
    get: function (key) {
        var token = "\\$" + "&"; // Please do not remove the string concat since grunt replace will fail to replace the string otherwise!!!!!!!!
        if (typeof key === 'string') {
            var val = (document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(key).replace(/[\-\.\+\*]/g, token) + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1") || null);
            if (typeof val === 'string') {
                var decoded = decodeURIComponent(val);
                if (decoded) {
                    return decoded.split(this.delimiter);
                }
            }
        }
    },
    remove: function (key, domain) {
        if (typeof key === 'string') {
            this.set(key, ['null'], domain);
            return true;
        }
    }
};

/**
 * Generates random UUID if crypto.randomUUID is supported
 * Generates pseudo UUID if crypto.getRandomValues is supported
 * Backward compatibility if crypto API is not available
 * Generates UID in the following format: xxxxxxxx-xxxx-4xxx-xxxx-x7xxxxxxxxxxx-xxxx(x)
 * @returns {string}
 */
function getUID() {
    var randomNumbers,
        randomString = "";

    if (crypto && typeof crypto.randomUUID === "function") {
        return crypto.randomUUID();
    }

    if (crypto && typeof crypto.getRandomValues === "function") {
        randomNumbers = new Uint8Array(32);
        crypto.getRandomValues(randomNumbers);
        // Convert random numbers to base16 string
        for (var i = 0; i < randomNumbers.length; i++) {
            randomString += randomNumbers[i].toString(16);
        }
        // Construct and return string of octets
        return randomString.substring(0, 8) +
            '-' +
            randomString.substring(8, 12) +
            '-' +
            randomString.substring(12, 16) +
            '-' +
            randomString.substring(16, 20) +
            '-' +
            randomString.substring(20, 32);
    }

    var UID = 'tttttttt-tttt-4ttt-fttt-t7ttttttttttt'.replace(/[tf]/g, function (c) {
        var r = Math.random() * 16 | 0, v = c == 't' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
    return  UID + '-' + Math.floor(Math.random() * 100000);
}

/**
 * Runs a callback function with a provided context,
 * returns the same value as this callback function returns
 * @param callback
 * @param context
 * @returns {*}
 */
function runCallback(callback, context) {
    context = context || window;
    if (typeof callback === "function") {
        var args = Array.prototype.slice.call(arguments, 2);
        try {
            return callback.apply(context, args);
        } catch (exc) {
            lpTag.log("Failed to execute callback exc= " + exc.message, 'ERROR', name);
        }
    }
}

/**
 * Runs a callback function with a context from a provided object
 * @param obj
 * @param args
 * @param errorCallback
 * @returns {*}
 * @dependency lpTag.log
 */
function runCallbackByObject(obj, args, errorCallback) {
    if (typeof getPropertyFromObject !== "function") {
        lpTag.log("lpTag.taglets.lpUtil.getPropertyFromObject is not a function", "ERROR", "utils");
        return;
    }

    obj = obj || {};

    var context = getPropertyFromObject(window, obj.jsContext);
    var func = getPropertyFromObject(window, obj.jsMethodName);

    if(typeof func !== "function") {
        lpTag.log("runCallbackByObject err=function " + obj.jsMethodName + " was not found", "ERROR", "utils");
        errorCallback();
    } else {
        lpTag.log("runCallbackByObject calling function " + obj.jsMethodName, "DEBUG", "utils");
        func.call(context, args);
    }
}

function registerEvent(element, eventName, callback) {
    if (element && eventName && callback) {
        if (element.addEventListener) {
            element.addEventListener(eventName, callback, false);
        } else {
            element.attachEvent('on' + eventName, callback);
        }
    }
}

function unregisterEvent(element, eventName, callback) {
    if (element && eventName && callback) {
        if (element.removeEventListener) {
            element.removeEventListener(eventName, callback, false);
        } else {
            element.detachEvent('on' + eventName, callback);
        }
    }
}

function buildClassString(classString, classesToAdd, classesToRemove) {
    var items, resItems;

    classString = typeof classString === 'string' ? classString : '';
    items = classString.split(" ");

    resItems = classesToAdd && classesToAdd.constructor === Array ? classesToAdd : (typeof classesToAdd === 'string' ? [classesToAdd] : []);

    classesToRemove = classesToRemove && classesToRemove.constructor === Array ? classesToRemove : (typeof classesToRemove === 'string' ? [classesToRemove] : []);

    for (var i = 0; i < items.length; i++) {
        if (indexOf(classesToRemove, items[i]) < 0 && indexOf(resItems, items[i]) < 0) {
            resItems.push(items[i]);
        }
    }
    return resItems.join(' ').replace(/$\s/ig, '');
}

/**
 * Checks if object is not empty (whitespaces are considered as non-empty values,
 * null, undefined, etc. also but only as values inside objects). Only objects'
 * own properties are considered
 * @param obj
 * @returns {boolean}
 */
function isEmpty(obj) {
    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            return false;
        }
    }
    return true;
}

/**
 * Gets a property from a JSON object
 * @param obj
 * @param path
 * @param defaultValue
 * @returns {*}
 * @private
 */
function getPropertyFromObject(obj, path, defaultValue) {
    var pathNames,
        currentLocation = obj;
    if (typeof path === 'string') {
        pathNames = path.split(".");

        for (var i = 0; i < pathNames.length; i++) {
            if (typeof currentLocation !== 'undefined' && currentLocation !== null &&
                typeof currentLocation[pathNames[i]] !== 'undefined' && currentLocation[pathNames[i]] !== null) {
                currentLocation = currentLocation[pathNames[i]];
            } else {
                currentLocation = typeof defaultValue !== 'undefined' ? defaultValue : void 0;
                break;
            }
        }
    } else {
        lpTag.log('Empty path sent to lookup getPropertyFromObject', 'DEBUG', 'utils');
    }
    return currentLocation;
}

function addClass(elem, className) {
    if (elem.className.indexOf(className) < 0) {
        elem.className = [elem.className, className].join(' ');
        elem.className = _removeSpaces(elem.className);
    }
}

function removeClass(elem, className) {
    elem.className = elem.className.replace(new RegExp(className, 'g'), '');
    elem.className = _removeSpaces(elem.className);
}

/**
 * Replaces all the white space characters in a string to single dash and trims the string
 * @param str
 * @returns {string}
 */
function _removeSpaces(str) {
    return trim(str.replace(/\s\s*/g, " "));
}

/**
 * Returns a map of the string of a pattern p1=v1(delimiter)p2=v2(delimiter)p3=v3...(delimiter)pN=vN
 * @param subjectStr
 * @param delimiter
 * @param isURIComponent
 * @returns {{}}
 */
function mapString(subjectStr, delimiter, isURIComponent) {
    var hashMap = {};
    if (subjectStr && typeof subjectStr === "string") {
        if (isURIComponent) {
            subjectStr = decodeURIComponent(subjectStr);
        }
        var parts = subjectStr.split(delimiter);
        var pair;
        for (var i=0; i<parts.length; i++) {
            pair = parts[i].split("=");
            hashMap[pair[0]] = pair[1];
        }
    }
    return hashMap;
}

function escapeHtml(text) {
    var map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '/': '&#x2F;',
        '`': '&#x60;',
        '=': '&#x3D;'
    };

    if (!text){
        return;
    }

    return text.replace(/[&<>"'`=/]/g, function (s) {
        return map[s];
    });
}



    return {
        indexOf:indexOf,
trim:trim,
trimAndLower:trimAndLower,
getDomain:getDomain,
getURLParams:getURLParams,
getParentDomain:getParentDomain,
addQueryParams:addQueryParams,
cloneExtend:cloneExtend,
clone:clone,
convertConfig:convertConfig,
addStyleTag:addStyleTag,
objectKeys:objectKeys,
waitForBody:waitForBody,
stringify:stringify,
cookieActions:cookieActions,
getUID:getUID,
runCallback:runCallback,
runCallbackByObject:runCallbackByObject,
registerEvent:registerEvent,
unregisterEvent:unregisterEvent,
buildClassString:buildClassString,
isEmpty:isEmpty,
getPropertyFromObject:getPropertyFromObject,
addClass:addClass,
removeClass:removeClass,
mapString:mapString,
escapeHtml:escapeHtml
    };

})();


/****************************************************************/

window.lpTag = window.lpTag || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};

/**
 * This Class handle the account settings management.
 *
 *  - init(conf) - will be called on instantiation.
 *      conf = {
 *           accountId, //mandatory
 *           domain, //mandatory
 *      }
 *
 *  - getSettings (callback)
 *      callback = function(settings);
 *
 * Dependencies:
 * @link lpTag.taglets.lpUtil,
 * @link lpTag.unifiedWindow.log,
 * @link lpTag.taglets.jsonp
 * @link lpTag.taglets.fetch
 */

lpTag.unifiedWindow.AccountSettingsManager = lpTag.unifiedWindow.AccountSettingsManager || function (conf) {

    var name = "AccountSettingsManager",
        log = lpTag.unifiedWindow.log,
        util = lpTag.taglets.lpUtil,
        accountId,
        domain,
        accountSettings,
        isFetchEnabled = false,
        fetchCacheMode;

    function init(conf) {
        if (typeof conf === "object" && conf.accountId && conf.domain) {
            accountId = conf.accountId;
            domain = conf.domain;
            var currentEnv = (typeof lpTag.getEnv === "function" && lpTag.getEnv());
            isFetchEnabled = ((conf.initialConf && (conf.initialConf.isFetchEnabled !== undefined)) ? JSON.parse(conf.initialConf.isFetchEnabled) : currentEnv === 'alpha');
            fetchCacheMode = conf.initialConf && conf.initialConf.fetchCacheMode;
        } else {
            //<excludeFromBuild>
            log.error("init: no configuration given", name);
            //</excludeFromBuild>
        }
    }

    init(conf);

    function getSettings(callback) {
        var accountSettingsAlreadyRequested = _accountSettingsAlreadyRequested();
        var transport = isFetchEnabled ? lpTag.taglets.fetch : lpTag.taglets.jsonp;
        //<excludeFromBuild>
        log.info("_getSettings", name);
        //</excludeFromBuild>
        var ACCDNConfig = "https://" + domain + "/api/account/" + accountId + "/configuration/setting/accountproperties" + (isFetchEnabled ? "" : "/");
        if (!accountSettings && !accountSettingsAlreadyRequested) {
            _accountSettingsRequested();
            transport.issueCall({
                url: ACCDNConfig,
                timeout: 5000,
                retries: 0,
                callbackName: 'accountSettingsCB',
                credentials: isFetchEnabled ? 'omit' : undefined,
                cache: (isFetchEnabled && fetchCacheMode) ? fetchCacheMode : undefined,
                success: function (response) {
                    var data = isFetchEnabled ? (response && response.body) : response;
                    _receivedAccountsSettings(data, true, callback);
                }.bind(this),
                error: function() {
                    _receivedAccountsSettingsFailed(true, callback);
                }.bind(this)
            });
        } else if (!accountSettings && accountSettingsAlreadyRequested) {
            _log('getSettings - Account settings network call already in progress', 'DEBUG');
            _bindAccountSettingsListeners(callback);
        }
    }

    
    function _accountSettingsRequested() {
        lpTag.events.trigger({
            appName: "*",
            eventName: "requestedAccountSettings",
            data: {}
        });
    } 

    // handle getting the data back from another taglet that has requested the account settings
    function _bindAccountSettingsListeners(callback) {
        var receivedAccountSettingsFired = lpTag.events.hasFired("*","receivedAccountSettings");
        var receivedAccountSettingsFailedFired = lpTag.events.hasFired("*","receivedAccountSettingsFailed");
        
        if (receivedAccountSettingsFired.length < 1) {
            lpTag.events.once({
                appName: "*",
                eventName: "receivedAccountSettings",
                func: function(data) {_receivedAccountsSettings(data, false, callback);}
            });
        } else {
            _receivedAccountsSettings(receivedAccountSettingsFired[0].data, false, callback);
        }
        if (receivedAccountSettingsFailedFired.length < 1) {
            lpTag.events.once({
                appName: "*",
                eventName: "receivedAccountSettingsFailed",
                func: function() { _receivedAccountsSettingsFailed(false, callback);}
            });
        } else {
            _receivedAccountsSettingsFailed(false, callback);
        }
        
    }

    // can be triggered by bound event listener or account settings call being returned
    // if triggered by account settings call we should trigger the receivedAccountSettings event
    // to share the data with other taglets
    function _receivedAccountsSettings(data, triggerEvent, callback) {
        if (data && Array.isArray(data) && !data.error) {
            //<excludeFromBuild>
            log.info("_getAcSettings - got configuration: " + JSON.stringify(data), name);
            //</excludeFromBuild>
            util.runCallback(callback, null, data);
        } else {
            //<excludeFromBuild>
            log.info("_getAcSettings - NO CONFIGURATION FOUND", name);
            //</excludeFromBuild>
            util.runCallback(callback, null, []);
        }

        if (triggerEvent){
            lpTag.events.trigger({
                appName: "*",
                eventName: "receivedAccountSettings",
                data: data
            });
        }
    }

    // can be triggered by bound event listener or account settings call being returned
    function _receivedAccountsSettingsFailed(triggerEvent, callback) {
       //<excludeFromBuild>
       log.info("_getAcSettings - ERROR FROM SERVER", name);
       //</excludeFromBuild>
       util.runCallback(callback, null, []);

        if (triggerEvent) {
            lpTag.events.trigger({
                appName: "*",
                eventName: "receivedAccountSettingsFailed",
                data: {}
            });
        }
    }

    function _accountSettingsAlreadyRequested() {
        return lpTag.events.hasFired("*","requestedAccountSettings").length > 0;
    }

        /**
     * Log function
     * @param msg - the text information
     * @param lvl - INFO or ERROR
     */
    function _log(msg, lvl) {
        if (window.lpTag && lpTag.log) {
            lpTag.log(msg, lvl, name);
        }
    }


    return {
        getSettings: getSettings
    };
};


/****************************************************************/

window.lpTag = window.lpTag || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};
lpTag.unifiedWindow.AppConfigurationManager = lpTag.unifiedWindow.AppConfigurationManager || function (dependencies) {

        var S2S_AUTH = 0,
            OAUTH_IMPLICIT = 1,
            OAUTH_CODE = 2,
            DEV_ENV_TYPE = "dev",
            STR_WINDOW_FEATURES = "menubar=no, location=no, resizable=1, scrollbars=no, status=yes, width=280px, height=400px, modal=true",
            STR_WINDOW_FEATURES_WITH_CAPTCHA = "menubar=no, location=no, resizable=1, scrollbars=no, status=yes, width=320px, height=450px, modal=true",
            DEAFULT_CHAT_TIMEOUTS = { // in secs
                DESKTOP: 180,
                MOBILE: 180,
                TABLET: 180
            },
            CHAT_CHANNEL = '-lpuw-chat',
            UNAUTHENTICATED_MESSAGING_CHANNEL = '-lpuw-unauthMessaging',
            MESSAGING_CHANNEL = '-lpuw-authMessaging',
            LEGACY_CHANNEL = '-lpuw',
            DEFAULT_CHANNEL_PRIORITY = [CHAT_CHANNEL, UNAUTHENTICATED_MESSAGING_CHANNEL, MESSAGING_CHANNEL, LEGACY_CHANNEL],
            CHANNELS = {},
            utils,
            lpTag,
            deviceDetector,
            queryParams,
            shouldAddPKCERedirectParam;

        _init(dependencies);

        // public

        function getSMSClientLaunchResourceURL(engConf, unifiedConf, smsConf) {
            var externalConfig = createExternalConfiguration(engConf, unifiedConf, false);

            externalConfig.smsClientLaunch = true;

            externalConfig.smsConf = {
                smsAPI: smsConf.smsAPI
            };

            externalConfig.smsConf.launchProperties = {
                phoneNumber: smsConf.launchProperties.phoneNumber,
                message: smsConf.launchProperties.message
            };

            externalConfig.resource = "/taptotextv2.html";

            return _getExternalURL(externalConfig, engConf, unifiedConf);
        }

        /**
         * Creates URL for external UW
         * @param {Object} engConf - engagement config
         * @param {Object} unifiedConf - UW config
         * @param {boolean} popOut - Defines if it is popout
         * @param {boolean} shouldAddPKCEParam - defines whether special query parameter should be added for PKCE flow
         * @returns {*}
         */
        function getExternalResourceURL(engConf, unifiedConf, popOut, shouldAddPKCEParam) {
            var externalConfig = createExternalConfiguration(engConf, unifiedConf, popOut);
            var url;
            if (shouldAddPKCEParam) {
                shouldAddPKCERedirectParam = true;
            }
            url = _getExternalURL(externalConfig, engConf, unifiedConf);
            shouldAddPKCERedirectParam = false;
            return url;
        }

        function createExternalConfiguration(engConf, conf, popOut) {
            var externalConf = {
                accountId: (engConf.subscription && engConf.subscription.conversationowneraccountid) || conf.accountId,
                env: conf.env,
                clickedChannel: conf.clickedChannel
            };
            if (conf.connectorsSfConfig) {
                externalConf.connectorsSfConfig = typeof conf.connectorsSfConfig === "object";
            }
            if (popOut) {
                _createPopoutConfiguration(externalConf, engConf, conf);
            } else {
                _createWindowConfiguration(externalConf, engConf, conf);
            }

            return externalConf;
        }

        function isAuthenticatedEnabled(engConf) {
            return engConf.connector && engConf.connector.type === 0;
        }

        function isRecaptchaEnabled() {
            return typeof lpTag.taglets.lpUnifiedWindowRecaptcha !== "undefined";
        }

        /**
         * This is for pointing on another cdn folder by queryparam
         * If there's no queryparam, folder will be set by "v" parameter
         * @returns {*}
         */
        function getUWDir(conf, v) {
            var versionQueryParam = queryParams && queryParams.lpVersion;

            if (versionQueryParam && conf.debug && conf.env !== DEV_ENV_TYPE) {
                return "/" + versionQueryParam;
            }
            else {
                return v ? "/" + v : "";
            }
        }

        function getChannels(conf) {
            if (utils.isEmpty(CHANNELS)) {
                _setChannels(conf);
            }
            return CHANNELS;
        }

        function getChannelsPriority(conf) {
            return conf.channelPriority || DEFAULT_CHANNEL_PRIORITY;
        }

        function getClickedChannel(engConf, forceLegacy) {
            if (!!engConf.async) {
                // Placeholder. How do we know if the engagement is unauthenticated messaging? What is the real flag?
                if (!!engConf.allowUnauthMsg) {
                    return UNAUTHENTICATED_MESSAGING_CHANNEL;
                }
                return MESSAGING_CHANNEL;
            }
            return forceLegacy? LEGACY_CHANNEL : CHAT_CHANNEL;
        }

        function getEngagementTypeByChannel(channel) {
            switch (channel) {
                case CHAT_CHANNEL:
                case LEGACY_CHANNEL:
                    return lpTag.unifiedWindow.consts.engagementTypes.CHAT_ENGAGEMENT;
                case MESSAGING_CHANNEL:
                case UNAUTHENTICATED_MESSAGING_CHANNEL:
                    return lpTag.unifiedWindow.consts.engagementTypes.MESSAGING_ENGAGEMENT;
            }
        }

        function getFeatureById(featureId) {
            var featureConfig;

            if (lpTag.features && typeof lpTag.features.getFeature === "function") {
                featureConfig = lpTag.features.getFeature(featureId);
            }

            return featureConfig;
        }

        function openExternal(engConf,url) {
            var options = isRecaptchaEnabled() ? STR_WINDOW_FEATURES_WITH_CAPTCHA : STR_WINDOW_FEATURES;
            return window.open(url, engConf.target + "POP", options);
        }

        // private

        function _setChannels(conf) {
            var channelsPriority = getChannelsPriority(conf);

            channelsPriority.forEach(function (channel) {
                CHANNELS[channel] = {
                    sessionKey: channel,
                    sessionTimeout: _getSessionTimeout(channel, conf)
                };
            });
        }

        function _getSessionTimeout(channel, conf) {
            var timeout;

            switch (channel) {
                case CHAT_CHANNEL:
                case LEGACY_CHANNEL:
                    timeout = _getSessionTimeoutByDevice(conf, 'chatSessionTimeout');
                    break;
                case UNAUTHENTICATED_MESSAGING_CHANNEL:
                    timeout = _getSessionTimeoutByDevice(conf, 'unauthenticatedMessagingSessionTimeout');
                    break;
                case MESSAGING_CHANNEL:
                    timeout = _getSessionTimeoutByDevice(conf, 'messagingSessionTimeout');
                    break;
            }

            return timeout;
        }

        function _getSessionTimeoutByDevice(conf, sessionTimeoutKey) {
            var timeout,
                deviceFamily = deviceDetector.getDeviceFamilyName().toLowerCase();

            if (conf && conf[sessionTimeoutKey] && conf[sessionTimeoutKey][deviceFamily]) {
                timeout = conf[sessionTimeoutKey][deviceFamily];
            } else {
                timeout = _getDefaultSessionTimeout();
            }

            return timeout;
        }

        function _getDefaultSessionTimeout() {
            var timeout;

            if (deviceDetector.isMobile()) {
                timeout = DEAFULT_CHAT_TIMEOUTS.MOBILE;
            } else if (deviceDetector.isTablet()) {
                timeout = DEAFULT_CHAT_TIMEOUTS.TABLET;
            } else {
                timeout = DEAFULT_CHAT_TIMEOUTS.DESKTOP;
            }

            return timeout;
        }

        /**
         * Function checks and returns the lpDebug or lpVersion params if they are available
         * @param params
         * @returns {*}
         */
        function _addLpParams(params) {
            if (queryParams && queryParams.lpDebug) {
                params.lpDebug = queryParams.lpDebug;
            }
            if (queryParams && queryParams.lpVersion) {
                params.lpVersion = queryParams.lpVersion;
            }

            return params;
        }

        // private

        function _init() {
            utils = dependencies.utils;
            lpTag = dependencies.lpTag;
            deviceDetector = dependencies.deviceDetector;
            queryParams = dependencies.queryParams;
        }

        function _getURLData(url) {
            var link = document.createElement("a");
            link.href = url;
            return {
                search: link.search,
                port: link.port,
                protocol: link.protocol,
                hostname: link.hostname,
                pathname: _addSlashPrefix(link.pathname)
            };
        }

        function getURLBreakdownInfo(url) {
            return _getURLData(url);
        }

        function _addSlashPrefix(str) {
            return str.indexOf("/") === 0 ? str : "/" + str;
        }

        function _createPopoutConfiguration(externalConf, engConf, conf) {
            externalConf.poppedOut = true;
            externalConf.sessionId = conf.sessionId;
            externalConf.supportBlockCCPattern = conf.supportBlockCCPattern;
            externalConf.scp = conf.scp;

            externalConf.engConf = {
                lewid: engConf.lewid
            };

        }

        function _createWindowConfiguration(externalConf, engConf, conf) {
            var connector = engConf.connector;

            var acrCheck = utils.getPropertyFromObject(connector, 'configuration.acrValues');
            if(typeof acrCheck != 'undefined') {
                delete connector.configuration.acrValues;
            }


            if (engConf.connector && engConf.connector.configuration && !engConf.async) {
                connector = utils.clone(engConf.connector);
                if (connector.configuration.authorizationEndpoint) {
                    connector.configuration.authorizationEndpoint = encodeURIComponent(connector.configuration.authorizationEndpoint);
                }
                if (connector.configuration.tokenEndpoint) {
                    connector.configuration.tokenEndpoint = encodeURIComponent(connector.configuration.tokenEndpoint);
                }
            }

            externalConf.external = true;
            externalConf.chatSessionTimeout = conf.chatSessionTimeout;
            externalConf.supportBlockCCPattern = conf.supportBlockCCPattern;
            externalConf.scp = conf.scp;
            externalConf.secureStorageType = conf.secureStorageType;
            externalConf.vars = conf.vars;
            externalConf.originationUrl = conf.originationUrl;

            externalConf.engConf = {
                async: engConf.async,
                scid: engConf.scid,
                cid: engConf.cid,
                eid: engConf.eid,
                lang: engConf.lang,
                svid: engConf.svid,
                ssid: engConf.ssid,
                lewid: engConf.lewid,
                connector: connector,
                allowUnauthMsg: engConf.allowUnauthMsg,
                availabilityPolicy: engConf.availabilityPolicy,
                subscription: engConf.subscription
            };

            if (engConf.isOffline) {
                externalConf.engConf.isOffline = true;
            }

            if (isRecaptchaEnabled()) {
                externalConf.useRecaptcha = true;
            }
            if (conf.sessionTimeout) {
                externalConf.sessionTimeout = conf.sessionTimeout;
            }
            if (conf.chatReconnectTimeout) {
                externalConf.chatReconnectTimeout = conf.chatReconnectTimeout;
            }
            if (isAuthenticatedEnabled(engConf)) {
                externalConf.engConf.authConnId = engConf.connector.id;
            }
            if (engConf.skill) {
                externalConf.engConf.skill = engConf.skill;
            }
            if (engConf.skillId) {
                externalConf.engConf.skillId = engConf.skillId;
            }
            if (engConf.preChatLines) {
                // Dump lines on external in case of URL length issues
                externalConf.engConf.preChatLines = _limitLinesLength(engConf.preChatLines);
            }
            if (engConf.subscription) {
                externalConf.engConf.subscription = engConf.subscription;

                // remove settings that are not using to prevent 414 (URL too long) error
                if (engConf.subscription.conversationownerSettings) {
                    try {
                        var conversationownerSettings = JSON.parse(engConf.subscription.conversationownerSettings);

                        engConf.subscription.conversationownerSettings = JSON.stringify(conversationownerSettings.filter(function (el) {
                            return el.id.indexOf("account.profile.") >= 0;
                        }));
                    } catch (err){
                        engConf.subscription.conversationownerSettings = "[]";
                    }
                }
            }
            if (engConf.externalTargets) {
                externalConf.engConf.externalTargets = engConf.externalTargets;
            }
            if (externalConf.engConf.connector && externalConf.engConf.connector.configuration) {
                delete externalConf.engConf.connector.configuration.jwtPublicKey;
            }
        }

        function _getExternalURL(externalConfig, engConf, unifiedConf) {
            var url = "";
            var identities = window.lpTag.identities && lpTag.identities.safeIdentities || [];
            var allConnectors = unifiedConf.connectors;
            var clientIdentities = identities.filter(function (identity) {
                var acr = identity.acr;
                var acrNum = parseInt(acr, 10);
                return acr.length !== 1 || acrNum !== 0;
            });
            if(engConf.connector){
                if (allConnectors && allConnectors.length) {
                    allConnectors.forEach(function (connector) {
                        if (!_isUnAuthConnector(connector)) {
                            clientIdentities.forEach(function (identity) {
                                if (connector.configuration.issuer === identity.iss) {
                                    engConf.connector = connector;
                                    if (externalConfig.engConf) {
                                        externalConfig.engConf.connector = connector;
                                    }
                                }
                            });
                        } 
                    });
                } 
                if(engConf.connector.type === S2S_AUTH){
                    url = _getExternalURLForS2SAuth(externalConfig, engConf, unifiedConf);
                }
                else if (engConf.connector.type === OAUTH_IMPLICIT || engConf.connector.type === OAUTH_CODE){
                    url = _getExternalURLForAuth2(externalConfig, engConf, unifiedConf);
                }
            }else{
                url = _getExternalURLForNoAuth(externalConfig, unifiedConf);
            }
            return url;
        }

        function _getExternalURLForAuth2(externalConfig, engConf, unifiedConf) {
            var type,
                useOAuth2Standard,
                url;

            engConf.connector = engConf.connector || {};
            useOAuth2Standard = unifiedConf.useOAuth2Standard || (engConf.connector.configuration && engConf.connector.configuration.rfcCompliance);

            if (_isValidConnector(engConf.connector)) {
                if (engConf.connector.type === OAUTH_IMPLICIT) {
                    // Up until now the implicit type was passed as "token". For standard OAuth2 it should be "id_token"
                    type = !useOAuth2Standard ? 'token' : 'id_token';
                } else {
                    type = 'code';
                }

                var redirectURI = _getExternalURI(unifiedConf, true, externalConfig);
                // If we're using the OAuth2 standard - we need to pass the state as an object. If not - query string.
                var state = _getExternalQueryString(externalConfig, true, useOAuth2Standard);
                var queryParams = {
                    response_type: type
                };

                if (typeof engConf.connector.configuration.clientId !== 'undefined') {
                    queryParams.client_id = engConf.connector.configuration.clientId;
                }
                if (!useOAuth2Standard) {
                    queryParams.redirect_uri = redirectURI + state;
                } else {
                    //append "openid" to the "scope" param to the authorization endpoint if rfcCompliance is true and if scope already doesn't exist
                    if(engConf && engConf.connector && engConf.connector.configuration && engConf.connector.configuration.rfcCompliance){
                        var authorizationEndpointData = _getURLData(engConf.connector.configuration.authorizationEndpoint);
                        var qsObj = lpTag.taglets.lpUtil.getURLParams(authorizationEndpointData.search);
                        if (lpTag.taglets.lpUtil.isEmpty(qsObj)) {
                            queryParams.scope = encodeURIComponent("openid");
                        } else if (qsObj && !qsObj.scope) {
                            queryParams.scope = encodeURIComponent("openid");
                        }
                    }
                    queryParams.redirect_uri = redirectURI;
                    queryParams.state = state;
                }

                url = utils.addQueryParams(engConf.connector.configuration.authorizationEndpoint, queryParams);
            } else {
                externalConfig.invalidAuthConnector = true;
                url = _getExternalURLForNoAuth(externalConfig, unifiedConf);
            }

            return url;
        }

        function _getExternalURLForS2SAuth(externalConfig, engConf, unifiedConf) {
            var url = engConf.connector.configuration.genKeyUrl,
                urlData = _getURLData(url),
                params = {
                    rt: "redir",
                    redirect: encodeURIComponent(unifiedConf.codeRepository + (externalConfig.resource || "/index.html")),
                    lpUnifiedWindowConfig: encodeURIComponent(utils.stringify(externalConfig))
                };

            params = _addLpParams(params);
            urlData.search = utils.addQueryParams(urlData.search, params);

            return urlData.protocol + "//" + urlData.hostname + (urlData.port ? ":" + urlData.port : "") + urlData.pathname + urlData.search;
        }

        function _getExternalURLForNoAuth(externalConfig, unifiedConf, encodeAll) {
            return _getExternalURI(unifiedConf, encodeAll, externalConfig) + _getExternalQueryString(externalConfig, encodeAll);
        }

        function _getExternalURI(unifiedConf, encodeAll, externalConfig) {
            var urlData = _getURLData(unifiedConf.staticCodeRepository + (externalConfig.resource || "/index.html")),
                url = urlData.protocol + "//" + urlData.hostname + (urlData.port ? ":" + urlData.port : "") + urlData.pathname;

            return (encodeAll ? encodeURIComponent(url) : url);
        }

        function _getExternalQueryString(externalConfig, encodeAll, useOAuth2) {
            var params,
                queryString;

            if (!useOAuth2) {
                // If it's not full OAuth2 - we encode the params as query params
                params = {lpUnifiedWindowConfig: encodeURIComponent(utils.stringify(externalConfig))};
                if (shouldAddPKCERedirectParam) {
                    params.pkce_reauthentication = 1;
                }
                params = _addLpParams(params);
                queryString = utils.addQueryParams('?', params);
            } else {
                // If it's full OAuth2 - we send the params as an object
                params = {lpUnifiedWindowConfig: externalConfig};
                if (shouldAddPKCERedirectParam) {
                    params.pkce_reauthentication = 1;
                }
                params = _addLpParams(params);
                queryString = utils.stringify(params);
            }

            return encodeAll ? encodeURIComponent(queryString) : queryString;
        }

        function _isValidConnector(connector) {
            connector.configuration = connector.configuration || {};
            return (connector.configuration.authorizationEndpoint && connector.type);
        }

        function _limitLinesLength(lines) {
            var maxParameterLength = 1500,// URL maximum length in most browsers is ~2000
                limited = {},
                length = 0;

            for (var key in lines) {
                limited[key] = lines[key];
                if (length >= maxParameterLength) {
                    break;
                }
                length += key.length + lines[key].length;
            }

            return limited;
        }
        
        function _isUnAuthConnector(connector) {
            var config = connector && connector.configuration;
            var unAuthJsMethod = "lpTag.taglets.unAuthMessaging.lpUnauthFunction";
            var unAuthJsContext = "lpTag.taglets.unAuthMessaging";
            return config.jsContext === unAuthJsContext && config.jsMethodName === unAuthJsMethod;
        }

        function getQueryString (url) {
            var urlWithoutHash = url.split('#')[0];
            var splitByQuestionMark = urlWithoutHash.split('?');
            if (splitByQuestionMark.length > 1) {
                return '?' + splitByQuestionMark[1];
            }
            return '';
        }

        return {
            createExternalConfiguration: createExternalConfiguration,
            isRecaptchaEnabled: isRecaptchaEnabled,
            isAuthenticatedEnabled: isAuthenticatedEnabled,
            getExternalResourceURL: getExternalResourceURL,
            getFeatureById: getFeatureById,
            getUWDir: getUWDir,
            openExternal: openExternal,
            getChannels: getChannels,
            getChannelsPriority: getChannelsPriority,
            getClickedChannel: getClickedChannel,
            getEngagementTypeByChannel: getEngagementTypeByChannel,
            getSMSClientLaunchResourceURL: getSMSClientLaunchResourceURL,
            getURLBreakdownInfo : getURLBreakdownInfo,
            getQueryString: getQueryString
        };
    };

/****************************************************************/

/**
 * ***************************************************************
 * Taglet name: BrowserStateManager
 * Version: 1.0
 * Description: Manage browser state.
 *    - Gives the abilility to register callbac on various events.
 *    - Returns various browser's states.
 *    - On initilaize object - register to event orientation changed, focus and blur. For unregister call dispose.
 *
 *  *****************************************************************
 * * Dependencies: @link lpTag.device, lpTag.unifiedWindow.log, lpTag.taglets.lpUtil
 * ******************************************************************
 *
 * ************************** PROPERTIES ****************************
 *
 * EVENT_NAME: { ORIENTATION_CHANGE, FOCUS_CHANGE, VISIBILITY_CHANGE }
 * on: Register to browser state events with givven event name, callback and context.
 *     -  EVENT_NAME.ORIENTATION_CHANGE: Register to orientation change event. run callback when detect orientation change. callback gets: { landscape: (true/ false) }.
 *     -  EVENT_NAME.FOCUS_CHANGE: Register to focus event on window event. run callback when detect focus, or blur. the callback gets: { focus: (true/ false) }.
 *     -  EVENT_NAME.VISIBILITY_CHANGE: Register to visibility changed event on window event. run callback when detect visibility change gets: { visibility: (true/ false) }.
 *
 * off: Register to browser state events with givven event name, callback and context.
 *     -  EVENT_NAME.ORIENTATION_CHANGE: unregister orientation event by callback and context.
 *     -  EVENT_NAME.FOCUS_CHANGE: unregister window's focus event by callback and context.
 *     -  EVENT_NAME.VISIBILITY_CHANGE: unregister document's visibility changed event by callback and context.
 *
 * isConnected: Return true if there is connection, otherwise false. Comment: some browsers as FF detect offline connection as online.
 * isConnected: Return true if there is connection, otherwise false. Comment: some browsers as FF detect offline connection as online.
 * isHidden: Returns true if the tab is hidden (not visible), otherwise - false.
 * isFocus: Returns true if the window has focus, otherwise - false.
 * isLandscape: Returns true if the device is on landscape mode, otherwise - false.
 * dispose: Dispose events and array on this class. After call dispose need to recreate the browser state manager.
 */

window.lpTag = window.lpTag || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};

lpTag.unifiedWindow.BrowserStateManager = lpTag.unifiedWindow.BrowserStateManager || function (_deviceDetector) {

    var log = lpTag.unifiedWindow.log,
        name = "BrowserStateManager",
        EVENT_NAME = {
            RESIZE_START: "resizeStart",
            ORIENTATION_CHANGE: "orientationChange",
            RESIZE: "resize",
            FOCUS_CHANGE: "focusChange",
            VISIBILITY_CHANGE: "visibilityChange"
        },
        events = {},
        hasFocus = true,
        utils = lpTag.taglets.lpUtil,
        canDetectConnection,
        onLineState,
        windowInnerWidth,
        currentLandscape,
        hiddenAttr,
        visibilityChange,
        onResizeTimeout,
        onOrientationTimeout,
        deviceDetector,
        orientationEvent;

    init(_deviceDetector);

    /********************
     *  PUBLIC FUNCTIONS
     *********************/
    function init(_deviceDetector) {
        canDetectConnection = typeof navigator.onLine === "boolean";
        onLineState = canDetectConnection ? navigator.onLine : true;
        deviceDetector = _deviceDetector;
        currentLandscape = isLandscape();
        windowInnerWidth = window.innerWidth;
        orientationEvent = _getOrientationEventName();
        var visibilityAttributes = _getVisibilityAttributes();
        hiddenAttr = visibilityAttributes.hiddenAttr;
        visibilityChange = visibilityAttributes.visibilityChange;
        _initEvents();
    }

    /**
     * Register to events ORIENTATION_CHANGE or FOCUS_CHANGE or VISIBILITY_CHANGE, and run callback when fired.
     * @param eventName
     * @param callback
     * @param context
     */
    function on(eventName, callback, context) {
        events[eventName] = events[eventName] || [];
        events[eventName].push({callback: callback, context: context});
    }

    /**
     * Unregister to events ORIENTATION_CHANGE or FOCUS_CHANGE or VISIBILITY_CHANGE.
     * @param eventName
     * @param callback
     */
    function off(eventName, callback) {
        _removeListener(eventName, callback);
    }

    /**
     * Return true if there is connection, otherwise false.
     * Comment: some browsers as FF detect offline connection as online.
     * Comment: some browsers as FF detect offline connection as online.
     */
    function isConnected() {
        if (canDetectConnection) {
            onLineState = navigator.onLine;
        }
        return onLineState;
    }

    function visibilitySupported() {
        return !!hiddenAttr;
    }

    /**
     * Detect if the window has focus or not.
     * @returns {boolean} Returns true if the window has focus, otherwise - false.
     */
    function isFocus() {
        return hasFocus;
    }

    /**
     * Detect if the tab is hidden or visible.
     * @returns {*} Returns true if the tab is hidden (not visible), otherwise - false.
     */
    function isHidden() {
        return document[hiddenAttr];
    }

    /**
     * Detect if the device on landscape or portrait mode.
     * @returns {*} Returns true if the device is on landscape mode, otherwise - false.
     */
    function isLandscape() {
        var landscape;
        if (typeof window.orientation !== "undefined") {
            var orientation = window.orientation;
            landscape = orientation === 90 || orientation === -90;
        } else {
            landscape = window.innerWidth > window.screen.availHeight;
        }
        return landscape;
    }

    function unregisterAllEvents() {
        for (var key in events) {
            if (events[key] && events[key].constructor === Array) {
                events[key].length = 0;
            }
            events[key] = null;
            delete events[key];
        }
    }

    /**
     * Cleans all event bindings and any listeners on this object
     */
    function dispose() {
        unregisterAllEvents();

        if (orientationEvent) {
            utils.unregisterEvent(window, orientationEvent, _onOrientationChange);
        }
        utils.unregisterEvent(window, "resize", _onResize);
        utils.unregisterEvent(window, "focus", _onFocus);
        utils.unregisterEvent(window, "blur", _onBlur);
    }

    /**********************
     * PRIVATE FUNCTIONS
     *********************/
    /**
     * Binds to DOM events and starts
     * the event containers
     * @private
     */
    function _initEvents() {
        if (orientationEvent) {//On desktop this won't exist
            utils.registerEvent(window, orientationEvent, _onOrientationChange);
        }
        utils.registerEvent(window, "resize", _onResize);
        utils.registerEvent(window, "focus", _onFocus);
        utils.registerEvent(window, "blur", _onBlur);
        utils.registerEvent(document, visibilityChange, _onVisibilityChange);
    }

    /**
     * triggered when a browser is focused
     * @private
     */
    function _onFocus() {
        hasFocus = true;
        if ("undefined" !== typeof events[EVENT_NAME.FOCUS_CHANGE]) {
            for (var i = 0; i < events[EVENT_NAME.FOCUS_CHANGE].length; i++) {
                utils.runCallback(events[EVENT_NAME.FOCUS_CHANGE][i].callback, events[EVENT_NAME.FOCUS_CHANGE][i].context, {focus: hasFocus});
            }
        }

        //<excludeFromBuild>
        log.info("_onFocus: trigger window focus event", name);
        //</excludeFromBuild>
    }

    /**
     * triggered when a visibility changed
     * @private
     */
    function _onVisibilityChange() {
        if ("undefined" !== typeof events[EVENT_NAME.VISIBILITY_CHANGE]) {
            for (var i = 0; i < events[EVENT_NAME.VISIBILITY_CHANGE].length; i++) {
                utils.runCallback(events[EVENT_NAME.VISIBILITY_CHANGE][i].callback, events[EVENT_NAME.VISIBILITY_CHANGE][i].context, {visible: !document[hiddenAttr]});
            }
        }
        //<excludeFromBuild>
        log.info("_onVisibilityChange: trigger visibility change event", name);
        //</excludeFromBuild>
    }

    /**
     * Triggered when a browser is blurred
     * @private
     */
    function _onBlur() {
        hasFocus = false;
        if ("undefined" !== typeof events[EVENT_NAME.FOCUS_CHANGE]) {
            for (var i = 0; i < events[EVENT_NAME.FOCUS_CHANGE].length; i++) {
                utils.runCallback(events[EVENT_NAME.FOCUS_CHANGE][i].callback, events[EVENT_NAME.FOCUS_CHANGE][i].context, {focus: hasFocus});
            }
        }
        //<excludeFromBuild>
        log.info("_onBlur: trigger window blur event", name);
        //</excludeFromBuild>
    }

    /**
     * Determines if visibility is supported and sets the visibility parameter we need to query
     * @private
     */
    function _getVisibilityAttributes() {
        var hiddenAttrName, visibilityChangeEvent;

        if (typeof document.webkitHidden !== "undefined") {
            hiddenAttrName = "webkitHidden";
            visibilityChangeEvent = "webkitvisibilitychange";
        } else if (typeof document.mozHidden !== "undefined") {
            hiddenAttrName = "mozHidden";
            visibilityChangeEvent = "mozvisibilitychange";
        } else if (typeof document.msHidden !== "undefined") {
            hiddenAttrName = "msHidden";
            visibilityChangeEvent = "msvisibilitychange";
        } else if (typeof document.hidden !== "undefined") {
            hiddenAttrName = "hidden";
            visibilityChangeEvent = "visibilitychange";
        }

        return {
            hiddenAttr: hiddenAttrName,
            visibilityChange: visibilityChangeEvent
        };
    }

    /**
     *  Detect whether device supports orientationchange event, otherwise returns undefined (Used to return resize).
     *  browser prefixed: onmozorientationchange
     * @returns {*|string}
     * @private
     */
    function _getOrientationEventName() {
        if (deviceDetector.isAndroid() || deviceDetector.isIOS()) {
            return "orientationchange";
        } else {
            return "resize";
        }
    }

    /**
     * Triggers the onResize callback with a delay taking into consideration
     * known issues of timing
     * @param e
     * @private
     */
    function _onOrientationChange(e) {
        if (onOrientationTimeout) {
            clearTimeout(onOrientationTimeout);
        }

        var delayResizeTimeout = 300;//Default delay for all browsers - get the last trigger
        if (deviceDetector.isAndroid()) {
            if (windowInnerWidth === window.innerWidth) {
                delayResizeTimeout = 900;
            } else {
                delayResizeTimeout = 400;
            }
        }

        onOrientationTimeout = setTimeout(_triggerOrientationChange, delayResizeTimeout);
    }

    /**
     * Triggers all the callbacks for Orientation change
     * @private
     */
    function _triggerOrientationChange() {
        var landscape, windowWidth, windowHeight;

        landscape = isLandscape();
        windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0;
        windowHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0;

        if (landscape !== currentLandscape && "undefined" !== typeof events[EVENT_NAME.ORIENTATION_CHANGE]) {
            for (var i = 0; i < events[EVENT_NAME.ORIENTATION_CHANGE].length; i++) {
                utils.runCallback(events[EVENT_NAME.ORIENTATION_CHANGE][i].callback, events[EVENT_NAME.ORIENTATION_CHANGE][i].context, { landscape: landscape, height: windowHeight, width: windowWidth});
                currentLandscape = landscape;
            }
            //<excludeFromBuild>
            log.info("_triggerOrientationChange: trigger orientation changed event. landscape: " + currentLandscape, name);
            //</excludeFromBuild>
        }
        windowInnerWidth = window.innerWidth;
    }

    /**
     * Triggers the onResize callback with a delay taking into consideration a 300 ms delay for all resize flows to fire
     * @param e
     * @private
     */
    function _onResize() {
        if (onResizeTimeout) {
            clearTimeout(onResizeTimeout);
        } else {
            _onResizeStart();
        }

        onResizeTimeout = setTimeout(function () {
            var windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0,
                windowHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0,
                resizeData = {
                    height: windowHeight,
                    width: windowWidth
                };
            if ("undefined" !== typeof events[EVENT_NAME.RESIZE]) {
                for (var i = 0; i < events[EVENT_NAME.RESIZE].length; i++) {
                    utils.runCallback(events[EVENT_NAME.RESIZE][i].callback, events[EVENT_NAME.RESIZE][i].context, resizeData);
                }
            }
            onResizeTimeout = null;
        }, 300);
    }

    function _onResizeStart() {
        if ("undefined" !== typeof events[EVENT_NAME.RESIZE_START]) {
            for (var i = 0; i < events[EVENT_NAME.RESIZE_START].length; i++) {
                utils.runCallback(events[EVENT_NAME.RESIZE_START][i].callback, events[EVENT_NAME.RESIZE_START][i].context);
            }
        }
    }

    /**
     * Removes listeners we no longer want
     * @param eventName
     * @param callback
     * @returns {*}
     * @private
     */
    function _removeListener(eventName, callback) {
        var listenerArr = events[eventName];
        if (listenerArr) {
            var listeners = [];
            for (var i = 0; i < listenerArr.length; i++) {
                if (listenerArr[i].callback !== callback) {
                    listeners.push(listenerArr[i]);
                }
            }
            listenerArr.length = 0;
            events[eventName] = listeners;
        }
    }

    return {
        EVENT_NAME: EVENT_NAME,
        on: on,
        off: off,
        visibilitySupported: visibilitySupported,
        isConnected: isConnected,
        isHidden: isHidden,
        isFocus: isFocus,
        isLandscape: isLandscape,
        unregisterAllEvents: unregisterAllEvents,
        dispose: dispose
    };
};




/****************************************************************/

window.lpTag = window.lpTag || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};
lpTag.unifiedWindow.defaultDictionary = lpTag.unifiedWindow.defaultDictionary || {
    error: "Error",
    couldNotConnect: "Oops - unable to connect.",
    tryAgain: "Try again",
    loadingOnMinimize: "Loading",
    loading: "Loading",
    unableToConnect: "Unable to connect",
    reconnect: "Trying to reconnect",
    chatEndedOnExternalWindow: "Close window in order to start new chat",
    externalWindowOpen: "You have an ongoing chat. Return to that window to continue the chat.",
    unsupportedBrowserMode: "Your browser may be in incognito mode, or it may be blocking third party cookies. Please open a regular browser session to chat, or check your browser privacy settings",
    cannotResumeChat: "Resume chat from the tab where the interaction began",
    crossDomainError: "Cannot resume conversation, please return to previous page to continue.",
    chatAuthError: "Go back to the previous page or log in to continue your conversation.",
    confirmMessage: "Closing the conversation means that you won’t be able to continue even if you go back or log in. Are you sure you want to proceed?",
    startConversationError: "Please refresh the page and start a new conversation.",
    connectionUnavailable: "Connection unavailable",
    sessionExpired: "Session expired",
    sessionError: "Your session has expired. Please close this window and start a new conversation in order to resume.",
    sharkSessionExpired: "Please refresh the page and start a new conversation.",
    toMoveThisWindowPressAltPlusArrowKey: "To move this window, press alt plus arrowkey",

    tooltip_Close: "Close",
    tooltip_Minimize: "Minimize",
    tooltip_open_widgets: "Open widgets",
    tooltip_close_widgets: "Close widgets",
    tooltip_refresh_slider: "Refresh",
    closeWindowOkBtn: "OK",
    closeWindowCancelBtn: "Cancel",
    windowRegionLabel: "Chat window",
    pkceAuthTitle: "Authorisation",
    pkceAuthStarted: "Authorisation process started",
    DownloadTranscriptAction: "Download\ntranscript",
    logoAltText: "Logo",

    'de-DE': {
        error: "Fehler",
        couldNotConnect: "Leider kann die Verbindung nicht hergestellt werden",
        tryAgain: "Versuchen Sie es erneut",
        loadingOnMinimize: "System lädt",
        loading: "Chat lädt",
        unableToConnect: "Verbindung kann nicht hergestellt werden",
        reconnect: "Wiederhole Verbindungsaufbau",
        chatEndedOnExternalWindow: "Schließen Sie das Fenster, um einen neuen Chat zu starten",
        externalWindowOpen: "Sie befinden sich derzeit in einem Chatgespräch. Kehren Sie zu diesem Fenster zurück, um den Chat fortzusetzen.",
        unsupportedBrowserMode: "Ihr Browser ist möglicherweise im Incognito-Modus, oder er blockiert Cookies von Drittanbietern. Bitte starten Sie eine reguläre Browsersitzung, oder überprüfen Sie die Privatsphäreeinstellungen Ihres Browsers.",
        cannotResumeChat: "Chat vom Tab fortführen, auf dem der Chat begonnen hat",
        crossDomainError: "Gespräch kann nicht wieder aufgenommen werden. Wechseln Sie zur vorherigen Seite, um fortzufahren.",
        chatAuthError: "Gehen Sie zurück zur vorherigen Seite oder melden Sie sich an, um das Gespräch fortzuführen.",
        confirmMessage: "Wenn Sie das Gespräch schließen, können Sie es nicht fortsetzen, auch wenn Sie zurück auf die vorherige Seite gehen oder sich anmelden. Möchten Sie wirklich fortfahren?",
        startConversationError: "Aktualisieren Sie die Seite und starten Sie ein neues Gespräch.",
        connectionUnavailable: "Verbindung nicht verfügbar",
        sessionExpired: "Sitzung abgelaufen",
        sessionError: "Die Sitzung ist abgelaufen. Schließen Sie dieses Fenster und starten Sie ein neues Gesprächs, um die Unterhaltung fortzusetzen.",
        sharkSessionExpired: "Aktualisieren Sie die Seite und starten Sie ein neues Gespräch.",
        logoAltText: "Logo"
    },

    'da-DK' : {
        //Failed to connect page
        error: "Fejl",
        couldNotConnect: "Hov- kan ikke oprette forbindelse",
        tryAgain: "Prøv igen",
        loadingOnMinimize: "Indlæser",
        loading: "Indlæser",
        unableToConnect: "Kan ikke oprette forbindelse",
        reconnect: "Prøver at oprette forbindelse igen",
        chatEndedOnExternalWindow: "Luk vinduet for at starte ny chat",
        externalWindowOpen: "Du har en igangværende chat. Vend tilbage til vinduet for at fortsætte chatten.",
        unsupportedBrowserMode: "Din browser er i incognito-funktion eller blokerer eksterne cookies. Åbn en almindelig browser for at chatte eller kontroller browserens indstillinger",
        cannotResumeChat: "Fortsæt chat fra fanen, hvor interaktionen startede",
        crossDomainError: "Kan ikke fortsætte samtalen, gå tilbage til forrige side for at fortsætte.",
        chatAuthError: "Gå tilbage til forrige side eller på og fortsæt samtalen.",
        confirmMessage: "Lukker du samtalen, kan du ikke fortsætte, selvom du går tilbage eller logger ind. Er du sikker på du vil gå videre?",
        startConversationError: "Opdater siden og start ny samtale.",
        connectionUnavailable: "Ingen forbindelse",
        sessionExpired: "Session udløbet",
        sessionError: "Din session er udløbet. Luk vinduet og start ny samtale for at fortsætte.",
        sharkSessionExpired: "Opdater siden og start ny samtale.",
        logoAltText: "Logo"
    },

    'es-ES' : {
        //Failed to connect page
        error: "Error",
        couldNotConnect: "Vaya, no hemos podido conectar",
        tryAgain: "Inténtelo de nuevo",
        loadingOnMinimize: "Cargando",
        loading: "Cargando",
        unableToConnect: "No se ha podido conectar",
        reconnect: "Intentando reconectar",
        chatEndedOnExternalWindow: "Cierre la ventana para iniciar un nuevo chat",
        externalWindowOpen: "Tiene un chat en proceso Vuelva a esa ventana para continuar el chat.",
        unsupportedBrowserMode: "Su navegador puede estar en modo incógnito, o quizá esté bloqueando cookies de terceros. Por favor, abra una sesión de navegador normal para charlar, o compruebe los ajustes de privacidad de su navegador",
        cannotResumeChat: "Reanudar el chat desde la pestaña donde comenzó la interacción",
        crossDomainError: "No se puede reanudar la conversación; por favor, vuelva a la página anterior para continuar.",
        chatAuthError: "Vuelva a la página anterior o inicie sesión para continuar su conversación.",
        confirmMessage: "Cerrar la conversación significa que no podrá continuar incluso si vuelve o inicia sesión. ¿Seguro que desea continuar?",
        startConversationError: "Por favor, actualice la página e inicie una nueva conversación.",
        connectionUnavailable: "Conexión no disponible",
        sessionExpired: "Sesión caducada",
        sessionError: "Su sesión ha caducado. Por favor cierre esta ventana e inicie una nueva conversación para reanudar.",
        sharkSessionExpired: "Por favor, actualice la página e inicie una nueva conversación.",
        logoAltText: "Logotipo"
    },

    'fi-FI' : {
        //Failed to connect page
        error: "Virhe",
        couldNotConnect: "Oho - yhteys ei onnistunut",
        tryAgain: "Yritä uudelleen",
        loadingOnMinimize: "Lataa",
        loading: "Lataa",
        unableToConnect: "Yhteys ei onnistunut",
        reconnect: "Yhdistää uudelleen",
        chatEndedOnExternalWindow: "Sulje ikkuna aloittaaksesi uuden keskustelun",
        externalWindowOpen: "Sinulla on meneillään keskustelu. Palaa takaisin kyseiseen ikkunaan jatkaaksesi keskustelua.",
        unsupportedBrowserMode: "Selaimesi saattaa olla incognito-tilassa tai se saattaa estää kolmannen osapuolen evästeet. Avaa normaali selainistunto keskustellaksesi tai tarkista selaimesi yksityisyysasetukset",
        cannotResumeChat: "Jatka keskustelua välilehdestä, josta aloitit sen.",
        crossDomainError: "Keskustelua ei voitu jatkaa, palaa edelliselle sivulle.",
        chatAuthError: "Mene takaisin edelliselle sivulle tai kirjaudu sisään jatkaaksesi keskustelua.",
        confirmMessage: "Keskustelun sulkeminen tarkoittaa sitä, ettet voi jatkaa sitä, vaikka palaisitkin takaisin tai kirjautuisit sisään. Haluatko varmasti jatkaa?",
        startConversationError: "Päivitä tämä sivu ja aloita uusi keskustelu.",
        connectionUnavailable: "Ei yhteyttä",
        sessionExpired: "Istunto umpeutui",
        sessionError: "Istuntosi on umpeutunut. Sulje tämä ikkuna ja aloita uusi keskustelu jatkaaksesi",
        sharkSessionExpired: "Päivitä tämä sivu ja aloita uusi keskustelu.",
        logoAltText: "Logo"
    },

    'fr-FR' : {
        //Failed to connect page
        error: "Erreur",
        couldNotConnect: "Oops - connexion impossible.",
        tryAgain: "Réessayer",
        loadingOnMinimize: "Chargement",
        loading: "Chargement",
        unableToConnect: "Impossible de se connecter",
        reconnect: "Tentative de reconnexion en cours",
        chatEndedOnExternalWindow: "Fermer la fenêtre pour démarrer une nouvelle conversation",
        externalWindowOpen: "Vous avez une conversation en cours. Revenir à cette fenêtre pour continuer la conversation.",
        unsupportedBrowserMode: "Votre navigateur est peut-être en mode incognito ou bloque peut-être les cookies en provenance de tierce partie. Veuillez ouvrir une session de navigateur ordinaire pour démarrer une conversation ou vérifiez les paramètres de confidentialité de votre navigateur",
        cannotResumeChat: "Reprenez la conversation sur l’onglet ou la communication a commencé",
        crossDomainError: "Impossible de reprendre la conversation. Veuillez retourner à la page précédente pour continuer.",
        chatAuthError: "Retournez à la page précédente ou connectez-vous pour continuer votre conversation.",
        confirmMessage: "Si vous fermez la conversation, vous ne pourrez pas continuer celle-ci même si vous retournez en arrière ou si vous vous connectez. Êtes-vous sûr de vouloir continuer ?",
        startConversationError: "Veuillez rafraîchir la page et démarrer une nouvelle discussion.",
        connectionUnavailable: "Connexion indisponible",
        sessionExpired: "Session expirée",
        sessionError: "Votre session a expiré. Veuillez fermer cette fenêtre et démarrer une nouvelle conversation pour continuer.",
        sharkSessionExpired: "Veuillez rafraîchir la page et démarrer une nouvelle discussion.",
        logoAltText: "Logo"
    },

    'it-IT' : {
        //Failed to connect page
        error: "Errore",
        couldNotConnect: "Oops - impossibile connettere",
        tryAgain: "Riprova",
        loadingOnMinimize: "Caricamento..",
        loading: "Caricamento..",
        unableToConnect: "Impossibile connettere.",
        reconnect: "Tentativo di riconnessione",
        chatEndedOnExternalWindow: "Chiudi la finestra per iniziare una nuova chat",
        externalWindowOpen: "Hai una chat in corso. Torna alla finestra per continuare la chat.",
        unsupportedBrowserMode: "Il tuo browser potrebbe essere in modalità private o bloccare i cookie di terze parti. Apri una sessione di browser regolare oppure controlla le impostazioni di bel browser",
        cannotResumeChat: "Ripristina la chat dalla scheda in cui è stata avviata l'interazione",
        crossDomainError: "Impossibile riprendere la conversazione, tornare alla pagina precedente per continuare.",
        chatAuthError: "Torna alla pagina precedente o accedi per proseguire la conversazione.",
        confirmMessage: "Se chiuderai la conversazione non potrai proseguirla, nemmeno tornando indietro o effettuando l’acceso. Continuare?",
        startConversationError: "Aggiorna la pagina e avvia una nuova conversazione.",
        connectionUnavailable: "Connessione non disponibile",
        sessionExpired: "Sessione scaduta",
        sessionError: "Sessione scaduta. Chiudere questa finestra e avviare una nuova conversazione per riprendere.",
        sharkSessionExpired: "Aggiorna la pagina e avvia una nuova conversazione.",
        logoAltText: "Logo"
    },
    'ja-JP' : {
        //Failed to connect page
        error: "エラー",
        couldNotConnect: "接続に失敗しました",
        tryAgain: "もう一度実行してください。",
        loadingOnMinimize: "読み込み中…",
        loading: "読み込み中…",
        unableToConnect: "接続に失敗しました。",
        reconnect: "再度、接続中です。",
        chatEndedOnExternalWindow: "新しいチャットを開始するにはウィンドウを閉じてください",
        externalWindowOpen: "継続中のチャットがあります。ウィンドウに戻ってチャットを続行してください。",
        unsupportedBrowserMode: "ブラウザがプライベートモードになっているか、第三者のクッキーをブロックしている可能性があります。通常のブラウザ セッションを開いてチャットするか、ブラウザのプライバシー設定を確認してください。",
        cannotResumeChat: "チャットは元の場所から再開してください",
        crossDomainError: "会話を再開できません。前のページに戻って続行してください。",
        chatAuthError: "会話を続行するには、前のページに戻るか、ログインしてください。",
        confirmMessage: "会話をクローズすると、前に戻っても、ログインしても、続行できなくなります。実行しますか?",
        startConversationError: "ページを再読み込みして、新しい会話を開始してください。",
        connectionUnavailable: "接続できません",
        sessionExpired: "セッションが切れました",
        sessionError: "セッションが切れました。再開するには、このウィンドウを閉じて、新しい会社を開始してください。",
        sharkSessionExpired: "ページを再読み込みして、新しい会話を開始してください。",
        logoAltText: "ロゴ"
    },
    'ko-KR' : {
        //Failed to connect page
        error: "오류",
        couldNotConnect: "이런 - 연결할 수 없습니다",
        tryAgain: "다시 시도",
        loadingOnMinimize: "로드 중",
        loading: "로드 중",
        unableToConnect: "연결할 수 없습니다",
        reconnect: "다시 연결을 시도하는 중",
        chatEndedOnExternalWindow: "새 채팅을 시작하려면 창을 닫습니다",
        externalWindowOpen: "진행 중인 채팅이 있습니다. 그 창으로 다시 돌아가서 채팅을 계속합니다.",
        unsupportedBrowserMode: "브라우저가 시크릿 모드이거나 타사의 쿠키를 차단하고 있습니다. 일반 브라우저 세션을 시작하여 채팅하거나 브라우저 개인 정보 설정을 확인하십시오",
        cannotResumeChat: "상호작용을 시작한 탭에서 채팅을 다시 시작합니다",
        crossDomainError: "대화를 다시 시작할 수 없습니다. 이전 페이지로 돌아가서 계속 하십시오.",
        chatAuthError: "이전 페이지로 돌아가거나 로그인하여 대화를 계속합니다.",
        confirmMessage: "이 대화를 닫으면 뒤로 돌아가거나 로그인하여도 계속할 수 없습니다. 정말로 계속하시겠습니까?",
        startConversationError: "페이지를 새로 고쳐서 새 대화를 시작하십시오.",
        connectionUnavailable: "연결을 사용할 수 없음",
        sessionExpired: "세션이 만료됨",
        sessionError: "세션이 만료되었습니다. 다시 시작하려면 이 창을 닫고 새 대화를 시작하십시오.",
        sharkSessionExpired: "페이지를 새로 고쳐서 새 대화를 시작하십시오.",
        logoAltText: "로고",
        // locale configurations (not for translations)
        __config__: {
            timeOrder: 'mdt'    //month-day-time
        }
    },
    'nl-NL' : {
        //Failed to connect page
        error: "Fout",
        couldNotConnect: "Oeps, we kunnen geen verbinding maken.",
        tryAgain: "Probeer het opnieuw",
        loadingOnMinimize: "Bezig met openen...",
        loading: "Bezig met openen...",
        unableToConnect: "Er kan geen verbinding tot stand worden gebracht",
        reconnect: "Er wordt opnieuw geprobeerd verbinding te maken",
        chatEndedOnExternalWindow: "Sluit het venster om een nieuw chatgesprek te starten.",
        externalWindowOpen: "Er is een chatgesprek actief. Ga terug naar het venster om het chatgesprek voort te zetten.",
        unsupportedBrowserMode: "Uw browser is wellicht in incognitomodus of blokkeert cookies van externe partijen. Start een gewone browsersessie om te chatten of controleer de privacy-instellingen van uw browser",
        cannotResumeChat: "Hervat de chatsessie op het tabblad waar de interactie begon",
        crossDomainError: "Het gesprek kan niet worden hervat. Ga terug naar de vorige pagina om verder te gaan.",
        chatAuthError: "Ga terug naar de vorige pagina of meld u aan om uw gesprek te vervolgen.",
        confirmMessage: "Als u het gesprek beëindigt, kunt u het niet vervolgen – ook al zou u teruggaan of u opnieuw aanmelden.      Weet u zeker dat u verder wilt gaan?",
        startConversationError: "Vernieuw de pagina en start een nieuw gesprek.",
        connectionUnavailable: "Verbinding niet beschikbaar",
        sessionExpired: "Sessie verlopen",
        sessionError: "Uw sessie is verlopen. Sluit dit venster en start een nieuw gesprek om te hervatten.",
        sharkSessionExpired: "Vernieuw de pagina en start een nieuw gesprek.",
        logoAltText: "Logo"
    },
    'ru-RU' : {
        //Failed to connect page
        error: "Ошибка",
        couldNotConnect: "Сбой при попытке соединения",
        tryAgain: "Попробуйте еще раз",
        loadingOnMinimize: "Загрузка...",
        loading: "Загрузка...",
        unableToConnect: "Сбой при попытке соединения",
        reconnect: "Пробуем восстановить связь",
        chatEndedOnExternalWindow: "Для начала нового чата закройте это окно.",
        externalWindowOpen: "Вы уже открыли окно чата. Для продолжения чата в открытом окне вернитесь в него.",
        unsupportedBrowserMode: "Возможно ваш браузер работает в режиме «инкогнито»; или же блокируютсю внешние куки-файлы. Пожалуйста, проверьте настройки конфиденциальности своего браузера или откройте браузер в обычном режиме",
        cannotResumeChat: "Чтобы продолжить чат, перейдите на вкладку, из которой чат был начат.",
        crossDomainError: "Невозможно возобновить разговор. Пожалуйста, вернитесь на предыдущую страницу.",
        chatAuthError: "Для продолжения разговора вернитесь на предыдущую страницу или войдите в систему.",
        confirmMessage: "Если вы закроете этот разговор, вы не сможете продолжить его вернувшись на предыдущую страницу или после повторного входа в систему. Продолжить?",
        startConversationError: "Обновите страницу и начните новый разговор.",
        connectionUnavailable: "Нет связи",
        sessionExpired: "Сеанс закончен",
        sessionError: "Сеанс закончен. Для возобновления разговора закройте это окно и начните новую сессию.",
        sharkSessionExpired: "Обновите страницу и начните новый разговор.",
        logoAltText: "Логотип"
    },
    'pt-BR' : {
        //Failed to connect page
        error: "Erro",
        couldNotConnect: "Ops – impossível conectar.",
        tryAgain: "Tente novamente",
        loadingOnMinimize: "Carregando",
        loading: "Carregando",
        unableToConnect: "Impossível conectar",
        reconnect: "Tentando reconectar",
        chatEndedOnExternalWindow: "Fechar a janela para iniciar um novo chat",
        externalWindowOpen: "Você tem um chat em andamento. Volte para a janela para continuar o chat.",
        unsupportedBrowserMode: "Seu navegador poder estar no modo anônimo ou estar bloqueando cookies de terceiros. Abra uma sessão regular do navegador para conversar por chat ou verifique as configurações de privacidade do navegador",
        cannotResumeChat: "Continuar o chat na guia onde a interação começou",
        crossDomainError: "Não possível continuar a conversa. Volte para a página anterior para continuar.",
        chatAuthError: "Volte para a página anterior ou faça login para continuar sua conversa.",
        confirmMessage: "Fechar a conversa significa que você não poderá continuar mesmo de voltar ou fizer login. Tem certeza de que deseja continuar?",
        startConversationError: "Atualize a página e inicie uma nova conversa.",
        connectionUnavailable: "Conexão não disponível.",
        sessionExpired: "Sessão expirada",
        sessionError: "Sua sessão expirou. Feche esta janela e inicie uma nova conversa para continuar.",
        sharkSessionExpired: "Atualize a página e inicie uma nova conversa.",
        logoAltText: "Logotipo"
    },
    'sk-SK' : {
        //Failed to connect page
        error: "Chyba",
        couldNotConnect: "Uff – pripojenie nie je možné",
        tryAgain: "Skúste znova",
        loadingOnMinimize: "Načítavanie",
        loading: "Načítavanie",
        unableToConnect: "Pripojenie nie je možné",
        reconnect: "Pokúša sa o opätovné pripojenie",
        chatEndedOnExternalWindow: "Ak chcete začať novú konverzáciu, zavrite okno",
        externalWindowOpen: "Momentálne prebieha konverzácia. Ak chcete pokračovať v konverzácii, vráťte sa do príslušného okna.",
        unsupportedBrowserMode: "Prehliadač môže byť spustený v anonymnom režime alebo môže blokovať súbory „cookie“ tretích strán. Ak chcete konverzovať, otvorte prehliadač v štandardnom režime alebo skontrolujte nastavenia ochrany osobných údajov prehliadača",
        cannotResumeChat: "Obnovte diskusiu z karty, na ktorej sa začala interakcia",
        crossDomainError: "Konverzáciu nemožno obnoviť; pokračujte návratom na predchádzajúcu stránku.",
        chatAuthError: "Ak chcete pokračovať v konverzácii, vráťte sa na predchádzajúcu stránku alebo sa prihláste.",
        confirmMessage: "Zavretie konverzácie znamená, že nebudete môcť pokračovať, ani ak sa vrátite alebo prihlásite. Naozaj chcete pokračovať?",
        startConversationError: "Obnovte stránku a začnite novú konverzáciu.",
        connectionUnavailable: "Pripojenie je nedostupné",
        sessionExpired: "Platnosť relácie uplynula",
        sessionError: "Platnosť vašej relácie uplynula. Ak chcete pokračovať, zavrite toto okno a začnite novú konverzáciu.",
        sharkSessionExpired: "Obnovte stránku a začnite novú konverzáciu.",
        logoAltText: "Logo"
    },
    'tr-TR' : {
        //Failed to connect page
        error: "Hata",
        couldNotConnect: "Ne yazık ki, bağlanılamıyor",
        tryAgain: "Tekrar dene",
        loadingOnMinimize: "Yükleniyor",
        loading: "Yükleniyor",
        unableToConnect: "Bağlanılamıyor",
        reconnect: "Yeniden bağlanmaya çalışılıyor",
        chatEndedOnExternalWindow: "Yeni sohbet başlatmak için pencereyi kapatın",
        externalWindowOpen: "Devam eden bir sohbetiniz var. Sohbete devam etmek için o pencereye geri dönün.",
        unsupportedBrowserMode: "Tarayıcınız gizli modda olabilir veya üçüncü parti tanımlama bilgilerini bloke ediyor olabilir. Lütfen sohbet etmek için normal bir tarayıcı oturumu açın veya tarayıcınızın kişisel gizlilik ayarlarını kontrol edin",
        cannotResumeChat: "Etkileşimin başladığı sekmeden sohbeti sürdürün",
        crossDomainError: "Görüşme sürdürülemiyor, lütfen devam etmek için önceki sayfaya geri dönün.",
        chatAuthError: "Konuşmaya devam etmek için lütfen önceki sayfaya dönün veya tekrar giriş yapın.",
        confirmMessage: "Bu sohbeti kapatırsanız, tekrar giriş yapsanız veya önceki sayfaya dönseniz bile, daha sonra devam edemezsiniz. Devam etmek istediğinizden emin misiniz?",
        startConversationError: "Lütfen sayfayı yenileyin ve yeni bir görüşme başlatın.",
        connectionUnavailable: "Bağlantı yok",
        sessionExpired: "Oturum süresi doldu",
        sessionError: "Oturumunuzun süresi doldu. Devam etmek için lütfen bu pencereyi kapatın ve yeni bir görüşme başlatın.",
        sharkSessionExpired: "Lütfen sayfayı yenileyin ve yeni bir görüşme başlatın.",
        logoAltText: "Logo"
    },
    'en-US' : {
        //Failed to connect page
        error: "Error",
        couldNotConnect: "Oops - unable to connect",
        tryAgain: "Try again",
        loadingOnMinimize: "Loading",
        loading: "Loading",
        unableToConnect: "Unable to connect",
        reconnect: "Trying to reconnect",
        chatEndedOnExternalWindow: "Close window in order to start new chat",
        externalWindowOpen: "You have an ongoing chat. Return to that window to continue the chat.",
        unsupportedBrowserMode: "Your browser may be in incognito mode, or it may be blocking third party cookies. Please open a regular browser session to chat, or check your browser privacy settings",
        cannotResumeChat: "Resume chat from the tab where the interaction began",
        crossDomainError: "Cannot resume conversation, please return to previous page to continue.",
        chatAuthError: "Go back to the previous page or log in to continue your conversation.",
        confirmMessage: "Closing the conversation means that you won’t be able to continue even if you go back or log in. Are you sure you want to proceed?",
        startConversationError: "Please refresh the page and start a new conversation.",
        connectionUnavailable: "Connection unavailable",
        sessionExpired: "Session expired",
        sessionError: "Your session has expired. Please close this window and start a new conversation in order to resume.",
        sharkSessionExpired: "Please refresh the page and start a new conversation.",
        logoAltText: "Logo"
    },
    'zh-CN' : {
        //Failed to connect page
        error: "错误",
        couldNotConnect: "哎呀——无法连接",
        tryAgain: "重试",
        loadingOnMinimize: "正在加载",
        loading: "正在加载",
        unableToConnect: "无法连接",
        reconnect: "正在尝试重新连接",
        chatEndedOnExternalWindow: "关闭窗口以开始新聊天",
        externalWindowOpen: "您有一个未完成的聊天。返回该窗口以继续聊天。",
        unsupportedBrowserMode: "您的浏览器可能处于无痕模式，或者它可能屏蔽第三方的 cookie。请打开正常浏览器会话以聊天，或检查浏览器的隐私设置",
        cannotResumeChat: "从开始互动的选项卡中恢复聊天",
        crossDomainError: "无法继续对话，请返回上一页以继续。",
        chatAuthError: "返回上一页或登录以继续对话。",
        confirmMessage: "关闭对话意味着即使您返回或登录也无法继续。您确定要继续吗？",
        startConversationError: "请刷新页面并开始新的对话。",
        connectionUnavailable: "连接不可用",
        sessionExpired: "会话过期",
        sessionError: "您的会话已过期。请关闭此窗口并开始新对话以继续。",
        sharkSessionExpired: "请刷新页面并开始新的对话。",
        logoAltText: "标志"
    },
    'ro-RO' : {
        //Failed to connect page
        error: "Eroare",
        couldNotConnect: "Oops - nu se poate conecta",
        tryAgain: "Încercați din nou",
        loadingOnMinimize: "Se încarcă",
        loading: "Se încarcă",
        unableToConnect: "Nu se poate conecta",
        reconnect: "Se încearcă reconectarea",
        chatEndedOnExternalWindow: "Închideți fereastra pentru a începe un nou chat",
        externalWindowOpen: "Aveți un chat în desfășurare. Reveniți la fereastra respectivă pentru a continua chatul.",
        unsupportedBrowserMode: "Este posibil ca browserul dv. să fie în modul incognito sau să blocheze cookie-urile de la terți. Vă rugăm deschideți o sesiune ordinară de browser sau verificați setările de confidențialitate.",
        cannotResumeChat: "Reluați conversația de pe fila unde a început interacțiunea.",
        crossDomainError: "Conversația nu poate fi reluată. Pentru a continua, vă rugăm să reveniți la pagina anterioară.",
        chatAuthError: "Mergeți la pagina anterioară sau autentificați-vă pentru a continua conversația.",
        confirmMessage: "Dacă închideți conversația, nu o mai puteți continua chiar dacă mergeți la pagina anterioară sau vă autentificați. Sunteți sigur(ă) că doriți să continuați?",
        startConversationError: "Vă rugăm actualizați pagina și începeți o nouă conversație.",
        connectionUnavailable: "Conexiune indisponibilă",
        sessionExpired: "Sesiune expirată",
        sessionError: "Sesiunea dv. a expirat. Pentru a continua, vă rugăm închideți fereastra și începeți o nouă conversație.",
        sharkSessionExpired: "Vă rugăm actualizați pagina și începeți o nouă conversație.",
        logoAltText: "Logo"
    },
    'uk-UA' : {
        //Failed to connect page
        error: "Помилка",
        couldNotConnect: "Помилка. Не вдалося підключитися",
        tryAgain: "Спробуйте ще раз",
        loadingOnMinimize: "Триває завантаження",
        loading: "Триває завантаження",
        unableToConnect: "Не вдалося підключитися",
        reconnect: "Триває спроба відновлення підключення",
        chatEndedOnExternalWindow: "Закрийте вікно, щоб почати нову розмову",
        externalWindowOpen: "У вас є активна розмова. Поверніться до цього вікна, щоб продовжити розмову.",
        unsupportedBrowserMode: "Можливо, ваш браузер відкрито в режимі інкогніто або він блокує сторонні файли cookies Для спілкування відкрийте браузер у звичайному режимі або перевірте налаштування приватності браузера",
        cannotResumeChat: "Продовжити чат зі вкладення, на якому було розпочато діалог",
        crossDomainError: "Неможливо відновити розмову. Для продовження поверніться на попередню сторінку.",
        chatAuthError: "Поверніться на попередню сторінку або виконайте вхід, щоб продовжити розмову.",
        confirmMessage: "Якщо ви закриєте розмову, то не зможете продовжити, навіть якщо повернетеся назад або виконаєте вхід. Справді продовжити?",
        startConversationError: "Оновіть сторінку та розпочніть нову розмову.",
        connectionUnavailable: "Підключення недоступне",
        sessionExpired: "Термін дії сеансу завершився",
        sessionError: "Термін дії сеансу завершився. Для продовження закрийте вікно та почніть нову розмову.",
        sharkSessionExpired: "Оновіть сторінку та розпочніть нову розмову.",
        logoAltText: "Логотип"
    },
    'ar-AE' : {
        //Failed to connect page
        error: "خطأ",
        couldNotConnect: "عفوا - تعذر الاتصال",
        tryAgain: "أعد المحاولة",
        loadingOnMinimize: "تحميل",
        loading: "تحميل",
        unableToConnect: "تعذر الاتصال",
        reconnect: "محاولة إعادة الاتصال",
        chatEndedOnExternalWindow: "اغلق النافذة حتى تتمكن من فتح محادثة جديدة",
        externalWindowOpen: "لديك محادثة جارية. ارجع إلى تلك النافذة للاستمرار في المحادثة.",
        unsupportedBrowserMode: "ربما يكون المستعرض في وضع التصفح الخفي أو ربما أنه يحظر ملفات الكوكي من الغير. يرجى فتح جلسة مستعرض عادية لإتمام المحادثة أو التأكد من إعدادات الخصوصية في المستعرض.",
        cannotResumeChat: "إستئنف الدردشة من علامة التبويب التي بدأ فيها التفاعل",
        crossDomainError: "يتعذر استئناف المحادثة. يرجى الرجوع إلى الصفحة السابقة للمتابعة.",
        chatAuthError: "ارجع إلى الصفحة السابقة أو قم بتسجيل الدخول لمتابعة المحادثة.",
        confirmMessage: "إغلاق المحادثة يعني أنك لن تستطيع المتابعة حتى بعد الرجوع للصفحة السابقة أو تسجيل الدخول. هل أنت متأكد أنك تريد المتابعة؟",
        startConversationError: "رجاءً أنعش الصفحة وابدأ محادثة جديدة.",
        connectionUnavailable: "لا يوجد اتصال متاح",
        sessionExpired: "انتهت صلاحية الجلسة",
        sessionError: "انتهيت صلاحية جلستك. يرجى إغلاق هذه النافذة وفتح محادثة جديدة من أجل الاستئناف.",
        sharkSessionExpired: "رجاءً أنعش الصفحة وابدأ محادثة جديدة.",
        logoAltText: "شعار"
    },

    'hr-HR' : {
        //Failed to connect page
        error: "Greška",
        couldNotConnect: "Ups - povezivanje nije uspjelo",
        tryAgain: "Pokušajte ponovno",
        loadingOnMinimize: "Učitavanje",
        loading: "Učitavanje",
        unableToConnect: "Nije se moguće povezati",
        reconnect: "Ponovno se pokušava uspostaviti veza",
        chatEndedOnExternalWindow: "Zatvorite prozor kako biste započeli novo čavrljanje",
        externalWindowOpen: "Imate aktivno čavrljanje Vratite se u taj prozor ako želite nastaviti čavrljati.",
        unsupportedBrowserMode: "Vaš preglednik možda je u inkognito načinu rada ili blokira kolačiće treće strane. Ako želite čavrljati, započnite sesiju u običnom pregledniku ili provjerite postavke privatnosti u vašem pregledniku",
        cannotResumeChat: "Čavrljanje ćete nastaviti u kartici u kojoj ste započeli interakciju",
        crossDomainError: "Nije moguće nastaviti razgovor, molimo vratite se na prethodnu stranicu kako biste nastavili.",
        chatAuthError: "Vratite se natrag na prethodnu stranicu ili se prijavite da nastavite razgovor.",
        confirmMessage: "Ako zatvorite razgovor nećete moći nastaviti čak i ako se vratite natrag ili se prijavite. Jeste li sigurni da želite nastaviti?",
        startConversationError: "Molimo osvježite stranicu i započnite novi razgovor.",
        connectionUnavailable: "Veza je nedostupna.",
        sessionExpired: "Sesija je istekla",
        sessionError: "Vaša sesija je istekla. Ako želite nastaviti, zatvorite ovaj prozor i pokrenite novi razgovor.",
        sharkSessionExpired: "Molimo osvježite stranicu i započnite novi razgovor.",
        logoAltText: "Logotip"
    },
    'lt-LT' : {
        //Failed to connect page
        error: "Klaida",
        couldNotConnect: "Atsiprašome, prisijungti nepavyko",
        tryAgain: "Bandyti vėl",
        loadingOnMinimize: "Įkeliama",
        loading: "Įkeliama",
        unableToConnect: "Nepavyksta prisijungti",
        reconnect: "Bandoma prisijungti pakartotinai",
        chatEndedOnExternalWindow: "Užverkite langą, jei norite pradėti naują pokalbį",
        externalWindowOpen: "Šiuo metu turite vykstantį pokalbį. Grįžkite į tą langą, kad galėtumėte tęsti pokalbį.",
        unsupportedBrowserMode: "Galbūt jūsų naršyklė veikia „incognito“ režimu, arba blokuoja trečiųjų šalių slapukus. Atverkite įprastą naršyklės seansą, kad galėtumėte pradėti pokalbį, arba patikrinkite savo naršyklės privatumo nuostatas",
        cannotResumeChat: "Pratęskite pokalbį iš kortelės, kurioje pradėjote bendrauti",
        crossDomainError: "Pokalbio tęsti negalima, prašome grįžti į ankstesnį puslapį ir tęsti iš ten.",
        chatAuthError: "Grįžkite į ankstesnį puslapį arba prisijunkite, kad galėtumėte tęsti pašnekesį.",
        confirmMessage: "Jei užversite pašnekesį, nebegalėsite tęsti, net jei grįšite atgal arba prisijungsite. Ar tikrai norite tęsti?",
        startConversationError: "Atnaujinkite puslapį ir pradėkite naują pokalbį.",
        connectionUnavailable: "Yra ryšys",
        sessionExpired: "Seansas baigėsi",
        sessionError: "Jūsų seansas baigėsi. Norėdami tęsti, užverkite šį langą ir pradėkite naują pokalbį.",
        sharkSessionExpired: "Atnaujinkite puslapį ir pradėkite naują pokalbį.",
        logoAltText: "Logotipas"
    },
    'hu-HU' : {
        //Failed to connect page
        error: "Hiba",
        couldNotConnect: "Kapcsolódás sikertelen",
        tryAgain: "Kérjük, hogy próbáld meg újra!",
        loadingOnMinimize: "Betöltés",
        loading: "Betöltés",
        unableToConnect: "Kapcsolódás sikertelen",
        reconnect: "Újrakapcsolódás folyamatban",
        chatEndedOnExternalWindow: "Ablak bezárása új csevegés indításához",
        externalWindowOpen: "Folyamatban lévő csevegése van. Visszatérés ahhoz az ablakhoz a csevegés folytatásához.",
        unsupportedBrowserMode: "A böngésző inkognító módban lehet, vagy harmadik fél sütijét (cookie) blokkolja. Kérem, nyisson meg egy hagyományos böngésző ablakot vagy csevegést, vagy ellenőrizze a böngésző adatvédelmi beállításait",
        cannotResumeChat: "Hiba történt! Kérjük, hogy folytasd a beszélgetést arról a fülről, ahol a chat kezdődött",
        crossDomainError: "A beszélgetés nem folytatható. Kérem, lépjen vissza az előző oldalra a folytatáshoz.",
        chatAuthError: "A beszélgetés folytatásához lépj vissza az előző oldalra, vagy jelentkezz be.",
        confirmMessage: "A beszélgetés bezárása esetén akkor sem fogod tudni folytatni, ha visszalépsz vagy bejelentkezel. Biztosan folytatod?",
        startConversationError: "Nyisson új oldalt és kezdjen új beszélgetést.",
        connectionUnavailable: "A kapcsolat nem érhető el",
        sessionExpired: "A munkamenet lejárt",
        sessionError: "Az ülése lejárt. Kérem, zárja be az ablakot és az újrakezdéshez indítson új beszélgetést.",
        sharkSessionExpired: "Nyisson új oldalt és kezdjen új beszélgetést.",
        logoAltText: "logó"
    },
    'fr-CA' : {
        //Failed to connect page
        error: "Erreur",
        couldNotConnect: "Oops - connexion impossible.",
        tryAgain: "Réessayer",
        loadingOnMinimize: "Chargement",
        loading: "Chargement",
        unableToConnect: "Impossible de se connecter",
        reconnect: "Tentative de reconnexion en cours",
        chatEndedOnExternalWindow: "Fermer la fenêtre pour démarrer une nouvelle conversation",
        externalWindowOpen: "Vous avez une conversation en cours. Revenir à cette fenêtre pour continuer la conversation.",
        unsupportedBrowserMode: "Votre navigateur est peut-être en mode incognito ou bloque peut-être les cookies en provenance de tierce partie. Veuillez ouvrir une session de navigateur ordinaire pour démarrer une conversation ou vérifiez les paramètres de confidentialité de votre navigateur",
        cannotResumeChat: "Reprenez la conversation sur l’onglet ou la communication a commencé",
        crossDomainError: "Impossible de reprendre la conversation. Veuillez retourner à la page précédente pour continuer.",
        chatAuthError: "Retournez à la page précédente ou connectez-vous pour continuer votre conversation.",
        confirmMessage: "Si vous fermez la conversation, vous ne pourrez pas continuer celle-ci même si vous retournez en arrière ou si vous vous connectez. Êtes-vous sûr(e) de vouloir continuer ?",
        startConversationError: "Veuillez rafraîchir la page et démarrer une nouvelle discussion.",
        connectionUnavailable: "Connexion indisponible",
        sessionExpired: "Session expirée",
        sessionError: "Votre session a expiré. Veuillez fermer cette fenêtre et démarrer une nouvelle conversation pour continuer.",
        sharkSessionExpired: "Veuillez rafraîchir la page et démarrer une nouvelle discussion.",
        logoAltText: "Logo"
    },
    'bg-BG' : {
        //Failed to connect page
        error: "Грешка",
        couldNotConnect: "Опа – не може да се свърже",
        tryAgain: "Опитайте отново",
        loadingOnMinimize: "Зареждане",
        loading: "Зареждане",
        unableToConnect: "Не може да се свърже",
        reconnect: "Опитва се да се свърже отново",
        chatEndedOnExternalWindow: "Затворете прозореца, за да започнете нов чат",
        externalWindowOpen: "Имате текущ чат. Върнете се към този прозорец, за да продължите чата.",
        unsupportedBrowserMode: "Вашият браузър може да е в режим „инкогнито“ или може да блокира бисквитки от трети страни. Моля, отворете редовна сесия на браузъра, за да чатите, или проверете настройките за поверителност на браузъра",
        cannotResumeChat: "Продължете чата от раздела, от който е започнат разговора",
        crossDomainError: "Разговорът не може да бъде възобновен. Моля, върнете се към предишната страница, за да продължите.",
        chatAuthError: "Върнете се към предишната страница или влезте, за да продължите разговора си.",
        confirmMessage: "Затварянето на разговора означава, че няма да можете да продължите, дори и да се върнете или да влезете. Сигурни ли сте, че желаете да продължите?",
        startConversationError: "Моля, опреснете страницата и започнете нов разговор.",
        connectionUnavailable: "Връзката е недостъпна",
        sessionExpired: "Изтекла сесия",
        sessionError: "Сесията Ви е изтекла. Моля, затворете този прозорец и започнете нов разговор, за възобновяване.",
        sharkSessionExpired: "Моля, опреснете страницата и започнете нов разговор.",
        logoAltText: "Лого"
    },
    'zh-TW' : {
        //Failed to connect page
        error: "錯誤",
        couldNotConnect: "糟糕，無法連線",
        tryAgain: "再試一次",
        loadingOnMinimize: "載入中",
        loading: "載入中",
        unableToConnect: "無法連線",
        reconnect: "正在嘗試重新連線",
        chatEndedOnExternalWindow: "關閉視窗以啟動新的交談",
        externalWindowOpen: "您有正在進行中的交談返回該視窗以繼續交談。",
        unsupportedBrowserMode: "瀏覽器可能處於匿名模式，或是封鎖第三方 Cookie。請開啟一般瀏覽器工作階段以執行交談，或是檢查瀏覽器隱私設定",
        cannotResumeChat: "如需恢復對話，請打開您之前進行互動的分頁",
        crossDomainError: "無法恢復對話，請回到上一頁以繼續。",
        chatAuthError: "回到上一頁或登入繼續對話。",
        confirmMessage: "若關閉對話就無法再繼續對話，即使返回或登入亦然。您確定要繼續嗎？",
        startConversationError: "請重新整理頁面以開始新對話。",
        connectionUnavailable: "無可用連線",
        sessionExpired: "工作階段已到期",
        sessionError: "您的工作階段已到期。請關閉此視窗並啟動新的對話，以繼續操作。",
        sharkSessionExpired: "請重新整理頁面以開始新對話。",
        logoAltText: "登入"
    },
    'el-GR' : {
        //Failed to connect page
        error: "Σφάλμα",
        couldNotConnect: "Ωχ - δεν ήταν δυνατή η σύνδεση",
        tryAgain: "Προσπαθήστε ξανά",
        loadingOnMinimize: "Φόρτωση",
        loading: "Φόρτωση",
        unableToConnect: "Δεν είναι δυνατή η σύνδεση",
        reconnect: "Γίνεται προσπάθεια επανασύνδεσης",
        chatEndedOnExternalWindow: "Κλείστε το παράθυρο για να ξεκινήσετε μια νέα συνομιλία",
        externalWindowOpen: "Υπάρχει μια συνομιλία σε εξέλιξη. Επιστρέψτε στο αντίστοιχο παράθυρο για να συνεχίσετε τη συνομιλία.",
        unsupportedBrowserMode: "Το πρόγραμμα περιήγησης που χρησιμοποιείτε ίσως βρίσκεται σε κατάσταση ανώνυμης περιήγησης ή αποτρέπει τη χρήση cookies από τρίτους. Ανοίξτε το πρόγραμμα περιήγησης σε κανονική λειτουργία για να συνομιλήσετε ή ελέγξτε τις ρυθμίσεις απορρήτου του προγράμματος",
        cannotResumeChat: "Συνεχίστε τη συνομιλία από την καρτέλα όπου ξεκίνησε η αλληλεπίδραση",
        crossDomainError: "Δεν είναι δυνατή η συνέχιση της συνομιλίας, επιστρέψτε στην προηγούμενη σελίδα για να συνεχίσετε.",
        chatAuthError: "Επιστρέψτε στην προηγούμενη σελίδα ή συνδεθείτε για να συνεχίσετε τη συνομιλία σας.",
        confirmMessage: "Αν κλείσετε τη συνομιλία, δεν θα μπορέσετε να συνεχίσετε ακόμα κι αν επιστρέψετε πίσω ή συνδεθείτε. Είστε σίγουροι ότι θέλετε να προχωρήσετε με αυτήν την ενέργεια;",
        startConversationError: "Κάντε ανανέωση της σελίδας και ξεκινήστε μια νέα συζήτηση.",
        connectionUnavailable: "Μη διαθέσιμη σύνδεση",
        sessionExpired: "Η περίοδος λειτουργίας έχει λήξει",
        sessionError: "Η περίοδος λειτουργίας έχει λήξει. Για να συνεχίσετε, κλείστε αυτό το παράθυρο και ξεκινήστε μια νέα συνομιλία.",
        sharkSessionExpired: "Κάντε ανανέωση της σελίδας και ξεκινήστε μια νέα συζήτηση.",
        logoAltText: "Λογότυπο"
    },
    'sl-SL' : {
        //Failed to connect page
        error: "Napaka",
        couldNotConnect: "Ups – povezave ni mogoče vzpostaviti",
        tryAgain: "Poskusi znova",
        loadingOnMinimize: "Nalagam",
        loading: "Nalagam",
        unableToConnect: "Povezave ni mogoče vzpostaviti",
        reconnect: "Poskušam znova vzpostaviti povezavo",
        chatEndedOnExternalWindow: "Zapri okno za začetek novega klepeta",
        externalWindowOpen: "Odprt imate aktivni klepet. Za nadaljevanje pogovora se vrnite na to okno.",
        unsupportedBrowserMode: "Vaš brskalnik je morda v načinu brez beleženja zgodovine ali pa morda blokira piškotke tretjih oseb. Za klepet odprite običajno sejo brskalnika ali pa preverite njegove nastavitve zasebnosti.",
        cannotResumeChat: "Nadaljujte s klepetom na zavihku, v katerem ste začeli s komunikacijo",
        crossDomainError: "S pogovorom ni možno nadaljevati, za nadaljevanje se vrnite na prejšnjo stran.",
        chatAuthError: "Pojdite na prejšnjo stran ali se prijavite in nadaljujte s pogovorom.",
        confirmMessage: "Če zaprete pogovor, bo to pomenilo, da ne boste mogli nadaljevati, četudi se ponovno prijavite. Ali ste prepričani, da želite nadaljevati?",
        startConversationError: "Osvežite stran in začnite nov pogovor",
        connectionUnavailable: "Povezava ni na voljo",
        sessionExpired: "Seja je potekla",
        sessionError: "Vaša seja je potekla. Za nadaljevanje zaprite to okno in začnite nov pogovor.",
        sharkSessionExpired: "Osvežite stran in začnite nov pogovor"
    },
    'en-UK' : {
        //Failed to connect page
        couldNotConnect: "Oops - unable to connect",
        tryAgain: "Try again",
        loadingOnMinimize: "Loading",
        unableToConnect: "Unable to connect",
        reconnect: "Trying to reconnect",
        startConversationError: "Please refresh the page and start a new conversation.",
        logoAltText: "Logo"
    },
    'pl-PL' : {
        //Failed to connect page
        error: "Błąd",
        couldNotConnect: "Niestety, nie można się połączyć.",
        tryAgain: "Spróbuj ponownie",
        loadingOnMinimize: "Ładowanie",
        loading: "Ładowanie",
        unableToConnect: "Nie można się połączyć",
        reconnect: "Próba ponownego połączenia",
        chatEndedOnExternalWindow: "Zamknij okno, aby rozpocząć nową rozmowę",
        externalWindowOpen: "Masz bieżącą rozmowę. Wróć do tego okna, aby kontynuować rozmowę.",
        unsupportedBrowserMode: "Twoja przeglądarka może być uruchomiona w trybie incognito lub może blokować pliki cookie innych firm. Otwórz regularną sesję przeglądarki, aby porozmawiać lub sprawdź ustawienia prywatności przeglądarki.",
        cannotResumeChat: "Wznów rozmowę na karcie, na której rozpoczęła się interakcja",
        crossDomainError: "Nie można wznowić rozmowy; aby kontynuować, wróć do poprzedniej strony.",
        chatAuthError: "Wróć do poprzedniej strony lub zaloguj się, aby kontynuować rozmowę.",
        confirmMessage: "Zamknięcie rozmowy będzie oznaczać, że kontynuowanie nie będzie możliwe, nawet jeżeli wrócisz do poprzedniej strony lub się zalogujesz. Czy na pewno chcesz kontynuować?",
        startConversationError: "Prosimy odświeżyć stronę i rozpocząć nową rozmowę.",
        connectionUnavailable: "Połączenie niedostępne",
        sessionExpired: "Sesja wygasła",
        sessionError: "Twoja sesja wygasła. Zamknij to okno i rozpocznij nową konwersację, aby wznowić.",
        sharkSessionExpired: "Prosimy odświeżyć stronę i rozpocząć nową rozmowę.",
        logoAltText: "Logo"
    },
    'zh-HK' : {
        //Failed to connect page
        error: "错误",
        couldNotConnect: "哎 – 無法連接",
        tryAgain: "再試一次",
        loadingOnMinimize: "載入中",
        loading: "載入中",
        unableToConnect: "無法連接",
        reconnect: "正在嘗試再連接",
        chatEndedOnExternalWindow: "關閉視窗以啟動新的交談",
        externalWindowOpen: "您有正在進行中的交談返回該視窗以繼續交談。",
        unsupportedBrowserMode: "瀏覽器可能處於匿名模式，或是封鎖第三方 Cookie。請開啟一般瀏覽器工作階段以執行交談，或是檢查瀏覽器隱私設定",
        cannotResumeChat: "如需恢復對話，請打開您之前進行互動的分頁",
        crossDomainError: "無法恢復對話，請回到上一頁以繼續。",
        chatAuthError: "回到上一頁或登入繼續對話。",
        confirmMessage: "若關閉對話就無法再繼續對話，即使返回或登入亦然。你是否想結束此對話？",
        startConversationError: "請重新整理頁面以開始新對話。",
        connectionUnavailable: "無可用連線",
        sessionExpired: "工作階段已到期",
        sessionError: "您的工作階段已到期。請關閉此視窗並啟動新的對話，以繼續操作。",
        sharkSessionExpired: "請重新整理頁面以開始新對話。",
        logoAltText: "標誌"
    },
    'et-EE' : {
        //Failed to connect page
        error: "Tõrge",
        couldNotConnect: "Oih! Ühendamine ei õnnestu",
        tryAgain: "Proovige uuesti",
        loadingOnMinimize: "Laadimine",
        loading: "Laadimine",
        unableToConnect: "Ei suuda luua ühendust",
        reconnect: "Püüame uuesti ühendada",
        chatEndedOnExternalWindow: "Uue vestluse alustamiseks sulgege aken",
        externalWindowOpen: "Teil on avatud vestlus. Minge vestluse jätkamiseks tagasi aknasse.",
        unsupportedBrowserMode: "Teie brauser võib olla inkognito režiimis või blokeeritud kolmanda poole küpsiste poolt. Avage palun vestluseks tavaline brauseri sessioon või kontrollige oma privaatsusseadeid.",
        cannotResumeChat: "Jätkake vestlust vahelehelt, kus koostöö algas",
        crossDomainError: "Ei saa vestlust lõpetada, jätkamiseks minge tagasi eelmisele leheküljele.",
        chatAuthError: "Vestluse jätkamiseks naaske eelmisele lehele või logige sisse.",
        confirmMessage: "Kui see vestlus suletakse, ei saa te seda hiljem uuesti käivitada (isegi kui logite uuesti sisse). Olete kindel, et soovite vestluse lõpetada?",
        startConversationError: "Värskendage lehekülge ja alustage uut vestlust.",
        connectionUnavailable: "Ühenduse loomine ei ole võimalik",
        sessionExpired: "Sessioon aegus",
        sessionError: "Teie sessioon on aegunud. Sulgege palun see aken ja alustage jätkamiseks uut vestlust.",
        sharkSessionExpired: "Värskendage lehekülge ja alustage uut vestlust.",
        logoAltText: "Logo"
    },
    'mk-MK': {
        //Failed to connect page
        error: "Грешка",
        couldNotConnect: "Поврзувањето не успеа",
        tryAgain: "Обидете се повторно",
        loadingOnMinimize: "Вчитувам",
        loading: "Вчитувам",
        unableToConnect: "Поврзувањето не успеа.",
        reconnect: "Се обидувам да се поврзам",
        chatEndedOnExternalWindow: "Затвори го прозорецот за да започнам нов муабет",
        externalWindowOpen: "Имате започнат муабет. Вратете се на тој прозорец за да го завршите муабетот.",
        unsupportedBrowserMode: "Прелистувачот е во режим за тајност или ги блокира колачињата од трето лице. Отворете регуларна сесија за муабет во прелистувачот или проверете ги поставките за приватност кај прелистувачот",
        cannotResumeChat: "Вратете го разговорот кај табулаторот каде започна интеракцијата",
        crossDomainError: "Разговорот не може да се обнови. Вратете се на претходната страница за да продолжите.",
        chatAuthError: "Вратете се на претходната страница или најавете се за да продолжите со разговорот.",
        confirmMessage: "Ако го затворите овој разговор, нема да можете да го продолжите подоцна, дури и ако повторно се пријавите. Дали сигурно сакате да го затворите овој разговор?",
        startConversationError: "Освежете ја страницата и започнете нов разговор.",
        connectionUnavailable: "Нема врска",
        sessionExpired: "Сесијата е истечена",
        sessionError: "Сесијата истече. Затворете го прозорецот и започнете нов разговор за да продолжите.",
        sharkSessionExpired: "Освежете ја страницата и започнете нов разговор.",
        logoAltText: "Лого"
    },
    'lv-LV' : {
        //Failed to connect page
        error: "Kļūda",
        couldNotConnect: "Diemžēl neizdevās izveidot savienojumu",
        tryAgain: "Mēģiniet vēlreiz",
        loadingOnMinimize: "Notiek ielāde",
        loading: "Notiek ielāde",
        unableToConnect: "Neizdevās izveidot savienojumu",
        reconnect: "Mēģina vēlreiz izveidot savienojumu",
        chatEndedOnExternalWindow: "Aizveriet logu, lai sāktu jaunu tērzēšanu",
        externalWindowOpen: "Jums ir atvērta tērzēšanas sesija. Atgriezieties attiecīgajā logā, lai turpinātu tērzēšanu.",
        unsupportedBrowserMode: "Jūsu pārlūkprogramma var būt inkognito režīmā vai bloķē trešo pušu sīkfailus. Lūdzu, atveriet parastu pārlūkprogrammas sesiju, lai tērzētu, vai pārbaudiet savas pārlūkprogrammas privātuma iestatījumus",
        cannotResumeChat: "Turpiniet čatu no cilnes, kur saziņa sākās.",
        crossDomainError: "Nevar turpināt sarunu; lūdzu, atgriezties iepriekšējā lapā, lai turpinātu.",
        chatAuthError: "Dodieties atpakaļ uz iepriekšējo lapu vai piesakieties, lai turpinātu savu sarunu.",
        confirmMessage: "Sarunas aizvēršana nozīmē, ka jūs nevarēsit turpināt, pat ja atgriezīsities vai pieteiksieties. Vai tiešām vēlaties to darīt?",
        startConversationError: "Lūdzu, atsvaidziniet šo lapu un sāciet jaunu sarunu.",
        connectionUnavailable: "Savienojums nav pieejams",
        sessionExpired: "Sesijas derīgums beidzies",
        sessionError: "Jūsu sesijas derīgums ir beidzies. Lūdzu, aizveriet šo logu un sāciet jaunu sarunu, lai turpinātu.",
        sharkSessionExpired: "Lūdzu, atsvaidziniet šo lapu un sāciet jaunu sarunu.",
        logoAltText: "Logotips"
    },
    'nb-NO' : {
        //Failed to connect page
        error: "Feil",
        couldNotConnect: "Obs - kunne ikke koble til",
        tryAgain: "Prøv på nytt",
        loadingOnMinimize: "Laster inn",
        loading: "Laster inn",
        unableToConnect: "Kunne ikke koble til",
        reconnect: "Prøver å koble til på nytt",
        chatEndedOnExternalWindow: "Lukk vinduet for å starte en ny chat",
        externalWindowOpen: "Du er allerede i en aktiv chat. Dra tilbake til vinduet for å fortsette chatten.",
        unsupportedBrowserMode: "Det er mulig at din nettleser er i inkognitomodus eller at den blokkeres av informasjonskapsler fra en tredjepart. Vennligst start en vanlig nettleserside for å chatte eller bruk nettleserens historikk",
        cannotResumeChat: "Gjenoppta chaten fra fanen hvor kommunikasjonen begynte",
        crossDomainError: "Kunne ikke opprettholde samtalen. Gå tilbake til forrige side for å fortsette.",
        chatAuthError: "Gå tilbake til forrige side eller logg inn og fortsett samtalen.",
        confirmMessage: "Hvis du lukker denne samtalen, kan du ikke fortsette på den, selv om du kommer tilbake senere eller logger inn igjen. Er du sikker på at du vil fortsette?",
        startConversationError: "Vennligst oppdater siden og start en ny samtale.",
        connectionUnavailable: "Tilkobling ikke tilgjengelig",
        sessionExpired: "Økt utløpt",
        sessionError: "Økten din er utløpt. Vennligst lukk vinduet og start en ny samtale for å fortsette.",
        sharkSessionExpired: "Vennligst oppdater siden og start en ny samtale.",
        logoAltText: "Logo"
    },
    'cs-CZ' : {
        //Failed to connect page
        error: "Chyba",
        couldNotConnect: "Chyba! Připojení se nezdařilo.",
        tryAgain: "Zkuste to znovu",
        loadingOnMinimize: "Nahrávání",
        loading: "Nahrávání",
        unableToConnect: "Připojení nelze navázat.",
        reconnect: "Pokus o opětovné připojení",
        chatEndedOnExternalWindow: "Zavřete okno, abyste mohli začít nový chat",
        externalWindowOpen: "Váš chat pokračuje. Vraťte se k oknu, abyste mohli v chatu pokračovat.",
        unsupportedBrowserMode: "Váš prohlížeč může být v režimu inkognito, nebo může blokovat cookies třetích stran. Chcete-li chatovat, otevřete běžnou relaci prohlížeče, nebo zkontrolujte nastavení soukromí svého prohlížeče",
        cannotResumeChat: "Pokračujte v konverzaci ze záložky, kde interakce začala",
        crossDomainError: "Není možno znovu začít konverzaci; chcete-li pokračovat, vraťte se na předchozí stránku.",
        chatAuthError: "Vraťte se na předchozí stránku nebo se přihlaste, chcete-li pokračovat v konverzaci.",
        confirmMessage: "Pokud ukončíte konverzaci, nebudete ji moci obnovit. Opravdu chcete zavřít tuto konverzaci?",
        startConversationError: "Obnovte prosím stránku a zahajte novou konverzaci.",
        connectionUnavailable: "Spojení není dostupné",
        sessionExpired: "Relace vypršela",
        sessionError: "Vaše relace vypršela. Abyste mohli pokračovat, zavřete toto okno a začněte novou konverzaci.",
        sharkSessionExpired: "Obnovte prosím stránku a zahajte novou konverzaci.",
        logoAltText: "Logo"
    },
    'pt-PT' : {
        //Failed to connect page
        error: "Erro",
        couldNotConnect: "Ups, não foi possível estabelecer ligação",
        tryAgain: "Tente novamente",
        loadingOnMinimize: "A carregar",
        loading: "A carregar",
        unableToConnect: "Não foi possível estabelecer ligação",
        reconnect: "A tentar estabelecer de novo a ligação",
        chatEndedOnExternalWindow: "Fechar janela para iniciar uma nova conversa",
        externalWindowOpen: "Tem uma conversa em curso. Volte para essa janela para continuar a conversa.",
        unsupportedBrowserMode: "O browser pode estar no modo de navegação anónima ou a bloquear cookies de terceiros. Abra uma sessão normal com o browser para conversar ou verifique as definições de privacidade do browser",
        cannotResumeChat: "Retome a conversa a partir do separador onde teve início a interacção",
        crossDomainError: "Não é possível retomar a conversação, volte à página anterior para continuar",
        chatAuthError: "Volte para a página anterior ou inicie sessão para continuar a sua conversa.",
        confirmMessage: "Se fechar a conversa, não a poderá continuar mesmo que volte ou que inicie sessão. Tem a certeza de que pretende continuar?",
        startConversationError: "Atualize a página e inicie uma nova conversa.",
        connectionUnavailable: "Ligação não disponível",
        sessionExpired: "Sessão expirada",
        sessionError: "A sua sessão expirou. Por favor, feche esta janela e inicie uma nova conversa a fim de retomar.",
        sharkSessionExpired: "Atualize a página e inicie uma nova conversa.",
        logoAltText: "Logótipo"
    },
    'es-419' : {
        //Failed to connect page
        error: "Error",
        couldNotConnect: "Vaya, no pudimos conectar",
        tryAgain: "Inténtelo de nuevo",
        loadingOnMinimize: "Cargando",
        loading: "Cargando",
        unableToConnect: "No se pudo conectar",
        reconnect: "Intentando reconectar",
        chatEndedOnExternalWindow: "Cierre la ventana para iniciar un nuevo chat.",
        externalWindowOpen: "Tiene un chat en curso. Vuelva a esa ventana para continuar el chat.",
        unsupportedBrowserMode: "Puede que su navegador está en modo incógnito, o quizá esté bloqueando cookies de terceros. Abra una sesión de navegador normal para charlar, o revise los ajustes de privacidad de su navegador.",
        cannotResumeChat: "Reanudar el chat desde la pestaña donde comenzó la interacción",
        crossDomainError: "No se puede reanudar la conversación. Para continuar, vuelva a la página anterior.",
        chatAuthError: "Vaya a la página anterior o inicie sesión para continuar su conversación",
        confirmMessage: "Cerrar la conversación significa que no podrá continuar, incluso si va a la página anterior o si inicia sesión. ¿Seguro que desea proceder?",
        startConversationError: "Actualice la página y comience una nueva conversación.",
        connectionUnavailable: "Conexión no disponible",
        sessionExpired: "Sesión expirada",
        sessionError: "Su sesión ha expirado. Para reanudar, cierre esta ventana e inicie una nueva conversación.",
        sharkSessionExpired: "Actualice la página y comience una nueva conversación.",
        logoAltText: "Logotipo"
    },
    'th-TH' : {
        //Failed to connect page
        error: "ข้อผิดพลาด",
        couldNotConnect: "อุ๊ย – ไม่สามารถเชื่อมต่อได้",
        tryAgain: "ลองอีกครั้ง",
        loadingOnMinimize: "กำลังโหลด",
        loading: "กำลังโหลด",
        unableToConnect: "ไม่สามารถเชื่อมต่อได้",
        reconnect: "กำลังพยายามเชื่อมต่อใหม่",
        chatEndedOnExternalWindow: "ปิดหน้าต่างเพื่อเริ่มแชตใหม่",
        externalWindowOpen: "คุณมีการสนทนาที่ยังดำเนินอยู่ กลับไปยังหน้าต่างนั้นเพื่อสนทนาต่อ",
        unsupportedBrowserMode: "เบราว์เซอร์ของคุณอาจอยู่ในโหมดไม่เผยตัวตน หรืออาจมีคุกกี้ที่บล็อกบุคคลที่สาม โปรดเปิดเซสชันเบราว์เซอร์ปกติเพื่อแชต หรือตรวจสอบการตั้งค่าความเป็นส่วนตัวของเบราว์เซอร์ของคุณ",
        cannotResumeChat: "สนทนาต่อจากแท็บที่เริ่มการปฏิสัมพันธ์",
        crossDomainError: "ไม่สามารถเรียกคืนบทสนทนาได้ โปรดกลับไปยังหน้าเพจก่อนหน้านี้เพื่อดำเนินการต่อ",
        chatAuthError: "กลับไปยังหน้าที่แล้ว หรือเข้าสู่ระบบใหม่เพื่อคุยต่อ",
        confirmMessage: "การปิดกล่องสนทนาแปลว่าคุณจะไม่สามารถคุยต่อได้ แม้ว่าจะกลับไปหน้าเดิมหรือเข้าสู่ระบบใหม่ก็ตาม แน่ใจหรือว่าต้องการตัดการเชื่อมต่อ?",
        startConversationError: "โปรดรีเฟรชแล้วเริ่มการสนทนาใหม่",
        connectionUnavailable: "ไม่มีการเชื่อมต่อ",
        sessionExpired: "เซสชันหมดอายุแล้ว",
        sessionError: "เซสชันของคุณหมดอายุแล้ว โปรดปิดหน้าต่างและเริ่มบทสนทนาใหม่ๆ เพื่อเรียกคืน",
        sharkSessionExpired: "โปรดรีเฟรชแล้วเริ่มการสนทนาใหม่",
        logoAltText: "โลโก้"
    },
    'ms-MY': {
        //Failed to connect page
        error: "Ralat",
        couldNotConnect: "Alamak - tidak dapat menyambung",
        tryAgain: "Cuba lagi",
        loadingOnMinimize: "Memuat",
        loading: "Memuat",
        unableToConnect: "Tidak boleh sambung semula",
        reconnect: "Sedang cuba menyambung semula",
        chatEndedOnExternalWindow: "Tutup tetingkap untuk memulakan sembang baru",
        externalWindowOpen: "Anda ada sembang berjalan sekarang. Kembali ke tetingkap tersebut untuk terus bersembang.",
        unsupportedBrowserMode: "Pelayar anda mungkin dalam mod inkognito, atau ia mungkin menyekat kuki pihak ketiga. Sila buka sesi pelayar biasa untuk bersembang, atau periksa tetapan privasi pelayar anda",
        cannotResumeChat: "Sambung sembang dari tab yang memulakan interaksi.",
        crossDomainError: "Tidak boleh teruskan sembang, sila kembali ke laman terdahulu untuk meneruskan.",
        chatAuthError: "Kembali ke laman sebelumnya atau log masuk untuk meneruskan perbualan anda.",
        confirmMessage: "Menutup perbualan bermakna anda tidak akan dapat meneruskan walaupun jika anda kembali atau log masuk. Adakah anda pasti ingin teruskan?",
        startConversationError: "Sila muat semula halaman dan mulakan perbualan baru.",
        connectionUnavailable: "Sambungan tidak tersedia",
        sessionExpired: "Sesi sudah luput",
        sessionError: "Sesi anda telah tamat. Sila tutup tetingkap ini dan mulakan perbualan baru untuk meneruskan.",
        sharkSessionExpired: "Sila muat semula halaman dan mulakan perbualan baru.",
        logoAltText: "Logo"
    },
    'id-ID' : {
        //Failed to connect page
        error: "Kesalahan",
        couldNotConnect: "ups - tidak bisa tersambung",
        tryAgain: "Coba lagi",
        loadingOnMinimize: "Sedang memuat",
        loading: "Sedang memuat",
        unableToConnect: "Tidak bisa tersambung",
        reconnect: "Sedang mencoba menyambung ulang",
        chatEndedOnExternalWindow: "Tutup jendela untuk memulai obrolan baru",
        externalWindowOpen: "Anda masih memiliki obrolan aktif. Kembali ke jendela tersebut untuk melanjutkan obrolan.",
        unsupportedBrowserMode: "Peramban Anda mungkin dalam modus incognito (penyamaran), atau mungkin peramban Anda memblokir cookie pihak ketiga. Harap buka sesi peramban biasa untuk mengobrol, atau cek pengaturan privasi peramban Anda",
        cannotResumeChat: "Lanjutkan obrolan dari tab di mana interaksi dimulai",
        crossDomainError: "Tidak bisa melanjutkan percakapan, harap kembali ke halaman sebelumnya untuk melanjutkan.",
        chatAuthError: "Kembali ke halaman sebelumnya atau masuk untuk melanjutkan percakapan Anda.",
        confirmMessage: "Menutup percakapan berarti Anda tidak akan dapat melanjutkan sekalipun Anda kembali atau masuk. Anda yakin ingin melanjutkan?",
        startConversationError: "Harap segarkan halaman dan mulailah percakapan baru.",
        connectionUnavailable: "Koneksi tidak tersedia",
        sessionExpired: "Sesi telah berakhir",
        sessionError: "Sesi Anda telah berakhir. Harap tutup jendela ini dan mulailah percakapan baru untuk melanjutkan.",
        sharkSessionExpired: "Harap segarkan halaman dan mulailah percakapan baru.",
        logoAltText: "Logo"
    },
    'Cy-sr-SP' : {
        //Failed to connect page
        error: "Greška",
        couldNotConnect: "Ups - nismo uspeli da se povežemo",
        tryAgain: "Pokušaj ponovo",
        loadingOnMinimize: "Učitavanje",
        loading: "Učitavanje",
        unableToConnect: "Povezivanje nije uspelo",
        reconnect: "Pokušava se ponovno povezivanje",
        chatEndedOnExternalWindow: "Zatvorite prozor da biste započeli novo ćaskanje",
        externalWindowOpen: "Već je u toku drugo ćaskanje. Vratite se u taj prozor da biste nastavili ćaskanje.",
        unsupportedBrowserMode: "Vaš pregledač je možda u inkognito režimu ili blokira kolačiće trećih strana. Otvorite standardnu sesiju u pregledaču da biste ćaskali ili proverite postavke privatnosti pregledača",
        cannotResumeChat: "Nastavite ćaskanje sa kartice gde je interakcija počela",
        crossDomainError: "Nije moguće nastaviti razgovor, vratite se na prethodnu stranicu da biste nastavili.",
        chatAuthError: "Vratite se nazad na prethodnu stranicu ili se prijavite da nastavite razgovor.",
        confirmMessage: "Ako zatvorite razgovor nećete moći da nastavite čak i ako se vratite nazad ili se prijavite. Želite li zaista da nastavite?",
        startConversationError: "Osvežite stranicu i započnite nov razgovor.",
        connectionUnavailable: "Veza nije dostupna",
        sessionExpired: "Sesija je istekla",
        sessionError: "Vaša sesija je istekla. Da biste nastavili, zatvorite ovaj prozor i započnite nov razgovor.",
        sharkSessionExpired: "Osvežite stranicu i započnite nov razgovor.",
        logoAltText: "Logotip"
    },
    'vi-VN' : {
        //Failed to connect page
        couldNotConnect: "ÔI - không thể kết nối",
        tryAgain: "Thử lại",
        loadingOnMinimize: "Đang tải",
        unableToConnect: "Không thể kết nối",
        reconnect: "Cố gắng kết nối lại",
        startConversationError: "Vui lòng làm mới trang và bắt đầu một cuộc hội thoại mới.",
        logoAltText: "Logo"
    },
    'sv-SV' : {
        //Failed to connect page
        error: "Fel",
        couldNotConnect: "Oj - det går inte att ansluta",
        tryAgain: "Försök igen",
        loadingOnMinimize: "Laddar",
        loading: "Laddar",
        unableToConnect: "Det går inte att ansluta",
        reconnect: "Försöker att återansluta",
        chatEndedOnExternalWindow: "Stäng fönstret för att starta en ny chatt",
        externalWindowOpen: "Du har en pågående chatt. Gå tillbaka till det fönstret för att fortsätta chatten.",
        unsupportedBrowserMode: "Din webbläsare kan vara i inkognitoläge, eller den kan blockera cookies från tredje part. Öppna en vanlig webbläsarsession för att chatta, eller kontrollera din webbläsares sekretessinställningar",
        cannotResumeChat: "Återuppta chatt från fliken där interaktionen började",
        crossDomainError: "Kan ej återuppta konversation, återgå till föregående sida för att fortsätta.",
        chatAuthError: "Gå tillbaks till föregående sida eller logga in för att fortsätta din konversation.",
        confirmMessage: "Att stänga konversationen innebär att du inte kan fortsätta även om du går tillbaks eller loggar in. Är du säker du vill fortsätta?",
        startConversationError: "Uppdatera sidan och starta en ny konversation.",
        connectionUnavailable: "Ingen anslutning tillgänglig",
        sessionExpired: "Session slut",
        sessionError: "Din session har gått ut. Stäng detta fönster och starta en ny konversation för att återuppta.",
        sharkSessionExpired: "Uppdatera sidan och starta en ny konversation."
    },
    'hi-IN' : {
        //Failed to connect page
        error: "त्रुटि",
        couldNotConnect: "ओ हो - कनेक्ट करने में अक्षम।",
        tryAgain: "पुनः प्रयास करें",
        loadingOnMinimize: "लोड हो रहा है",
        loading: "लोड हो रहा है",
        unableToConnect: "कनेक्ट करने में अक्षम",
        reconnect: "रीकनेक्ट करने का प्रयास कर रहा है",
        chatEndedOnExternalWindow: "नई चैट शुरु करने के लिए विंडों को बंद कर दें",
        externalWindowOpen: "आपकी एक चैट चल रही है। उस चैट को जारी रखने के लिए विंडो पर वापस जाएं।",
        unsupportedBrowserMode: "आपका ब्राउज़र गुप्त ( incognito) मोड में हो सकता है या तीसरे पक्ष की कुकीस को ब्लॉक कर रहा हो सकता है। कृपया चैट करने के लिए एक नियमित ब्राउज़र सत्र खोलें या अपने ब्राउज़र की निजता सेटिंग की जांच करें",
        cannotResumeChat: "उस टैब से चैट शुरु करें जहां से बातचीत शुरु हुई थी।",
        crossDomainError: "बातचीत फिर से शुरू नहीं की जा सकती है, जारी रखने के लिए कृपया पिछले पेज पर वापस जाएं।",
        chatAuthError: "अपनी बातचीत जारी रखने के लिए पिछले पेज पर वापस जाएं या लॉगिन करें। ",
        confirmMessage: "बातचीत बंद करने का अर्थ है कि आप वापस जाने या लॉगिन करने भी जारी नहीं रख पाएंगे। क्या आप वाकई डिसकनेक्ट करना चाहते हैं?",
        startConversationError: "कृपया यह पेज रीफ्रेश करें व नई बातचीत शुरु करें।",
        connectionUnavailable: "कनेक्शन अनुपलब्ध",
        sessionExpired: "सत्र समाप्त हो गया",
        sessionError: "आपका सत्र समाप्त हो गया है। कृपया इस विंडो को बंद करें और पुनः जारी रखने के लिए एक नयी बातचीत शुरु करें।",
        sharkSessionExpired: "कृपया यह पेज रीफ्रेश करें व नई बातचीत शुरु करें।",
        logoAltText: "लोगो"
    },
    'he-IL' : {
        //Failed to connect page
        couldNotConnect: "אופס – התחברות נכשלה",
        tryAgain: "נסו שוב",
        loadingOnMinimize: "טוען",
        unableToConnect: "כישלון בהתחברות",
        reconnect: "ניסיון התחברות מחדש",
        startConversationError: "רענן את הדף ופתח שיחה חדשה.",
        logoAltText: "לוגו"
    },
    'pa-IN' : {
        //Failed to connect page
        error: "ਐਰਰ",
        couldNotConnect: "ਓਹੋ- ਕੁਨੈਕਟ ਕਰਨ ਵਿੱਚ ਅਸਮਰਥ",
        tryAgain: "ਦੁਬਾਰਾ ਕੋਸ਼ਿਸ਼ ਕਰੋ",
        loadingOnMinimize: "ਲੋਡ ਹੋ ਰਿਹਾ",
        loading: "ਲੋਡ ਹੋ ਰਿਹਾ",
        unableToConnect: "ਕੁਨੈਕਟ ਕਰਨ ਵਿੱਚ ਅਸਮਰਥ",
        reconnect: "ਦੁਬਾਰਾ ਕੁਨੈਕਟ ਕਰਨ ਲਈ ਕੋਸ਼ਿਸ਼ ਕਰ ਰਿਹਾ",
        chatEndedOnExternalWindow: "ਨਿਊ ਚੈਟ ਸ਼ੁਰੂ ਕਰਨ ਲਈ ਵਿੰਡੋ ਬੰਦ ਕਰੋ",
        externalWindowOpen: "ਤੁਹਾਡੀ ਗੱਲਬਾਤ ਚੱਲ ਰਹੀ ਹੈ ਚੈਟ ਜਾਰੀ ਰਖਣ ਲਈ ਵਿੰਡੋ ਤੇ ਜਾਓ",
        unsupportedBrowserMode: "ਤੁਹਾਡਾ ਬ੍ਰਾਉਜ਼ਰ ਇਨਕੋਗਨਿਟੋ ਮੋਡ ਵਿੱਚ ਹੋ ਸਕਦਾ ਹੈ ਜਾਂ ਇਹ ਥਰਡ ਪਾਰਟੀ ਕੂਕੀਜ਼ ਨੂੰ ਬਲਾਕ ਕਰ ਰਿਹਾ ਹੋ ਸਕਦਾ ਹੈ. ਕਿਰਪਾ ਚੈਟ ਕਰਨ ਲਈ ਰੈਗੂਲਰ ਬ੍ਰਾਉਜ਼ਰ ਸੈਸ਼ਨ ਖੋਲੋ ਅਤੇ ਤੁਹਾਡੇ ਬ੍ਰਾਉਜ਼ਰ ਦੀਆਂ ਪ੍ਰਾਈਵੇਸੀ ਸੈਟਿੰਗਜ਼ ਚੈਕ ਕਰੋ",
        cannotResumeChat: "ਜਿਥੋਂ ਇੰਟਰੈਕਸ਼ਨ ਸ਼ੁਰੂ ਹੋਈ ਸੀ ਉਸੇ ਟੈਬ ਤੇ ਚੈਟ ਰਿਸਊਮ ਕਰੋ",
        crossDomainError: "ਬਾਤਚੀਤ ਰਿਸਊਮ ਨਹੀ ਹੋ ਸਕਦੀ, ਕਿਰਪਾ ਜਾਰੀ ਰਖਣ ਲਈ ਪਿਛਲੇ ਪੇਜ ਤੇ ਜਾਓ.",
        chatAuthError: "ਪਿਛਲੇ ਪੇਜ ਤੇ ਵਾਪਸ ਜਾਓ ਜਾਂ ਫਿਰ ਗੱਲਬਾਤ ਜਾਰੀ ਰਖਣ ਲਈ ਲੋਗ ਇਨ ਕਰੋ",
        confirmMessage: "ਗੱਲਬਾਤ ਨੂੰ ਬੰਦ ਕਰਨ ਦਾ ਮਤਲਬ ਹੈ ਕਿ ਤੁਸੀਂ ਜਾਰੀ ਨਹੀਂ ਰੱਖ ਸਕੋਗੇ ਭਾਵੇਂ ਤੁਸੀਂ ਵਾਪਸ ਜਾਓ ਜਾਂ ਲੌਗ ਇਨ ਕਰੋ। ਕੀ ਤੁਸੀਂ ਪੱਕਾ ਅੱਗੇ ਜਾਣਾ ਚਾਹੁੰਦੇ ਹੋ ?",
        startConversationError: "ਕਿਰਪਾ ਪੇਜ ਰੀਫ੍ਰੈਸ਼ ਕਰੋ ਅਤੇ ਨਵੀਂ ਕੰਵਰਸੇਸ਼ਨ ਸ਼ੁਰੂ ਕਰੋ.",
        connectionUnavailable: "ਕਨੈਕਸ਼ਨ ਮੌਜੂਦ ਨਹੀ ਹੈ",
        sessionExpired: "ਸੈਸ਼ਨ ਐਕਸਪਾਇਰ ਹੋ ਗਿਆ",
        sessionError: "ਤੁਹਾਡਾ ਸੈਸ਼ਨ ਐਕਸਪਾਇਰ ਹੋ ਗਿਆ ਹੈ. ਕਿਰਪਾ ਇਹ ਵਿੰਡੋ ਬੰਦ ਕਰੋ ਅਤੇ ਰੀਸਿਊਮ ਕਰਨ ਲਈ ਨਵੀਂ ਕੰਵਰਸੇਸ਼ਨ ਸ਼ੁਰੂ ਕਰੋ .",
        sharkSessionExpired: "ਕਿਰਪਾ ਪੇਜ ਰੀਫ੍ਰੈਸ਼ ਕਰੋ ਅਤੇ ਨਵੀਂ ਕੰਵਰਸੇਸ਼ਨ ਸ਼ੁਰੂ ਕਰੋ.",
        logoAltText: "ਲੋਗੋ"
    },
    'ta-IN' : {
        //Failed to connect page
        error: "பிழை",
        couldNotConnect: "அச்சோ - இணைக்க இயலவில்லை",
        tryAgain: "மீண்டும் முயற்சிக்கவும்",
        loadingOnMinimize: "நினைவேற்றுகிறது",
        loading: "நினைவேற்றுகிறது",
        unableToConnect: "இணைக்க இயலவில்லை",
        reconnect: "மீண்டும் இணைக்க முயற்சிக்கிறது",
        chatEndedOnExternalWindow: "புதிய உரையாடலைத் தொடங்க விண்டோவை மூடுக",
        externalWindowOpen: "நீங்கள் ஒரு உரையாடலில் ஈடுபட்டுக் கொண்டிருக்கிறீர்கள். உரையாடலைத் தொடர, அந்த விண்டோவுக்கு திரும்புக.",
        unsupportedBrowserMode: "உங்கள் உலாவி மறைநிலை பயன்முறையில் இருக்கலாம், அல்லது அது மூன்றாம் தரப்பு குக்கீகளைத் தடுக்கலாம். உரையாடுவதற்கு வழக்கமான உலாவி அமர்வைத் திறக்கவும், அல்லது உங்கள் உலாவி தனியுரிமை அமைப்புகளைச் சரிபார்க்கவும்",
        cannotResumeChat: "தொடங்கிய அதே டேப்-இல் உரையாடலை மீண்டும் தொடருக",
        crossDomainError: "உரையாடலை மீண்டும் தொடரமுடியவில்லை, தொடருவதற்கு முந்தைய பக்கத்துக்குத் திரும்புக.",
        chatAuthError: "உங்கள் உரையாடலைத் தொடர முந்தைய பக்கத்துக்குச் செல்க அல்லது உள்நுழைக.",
        confirmMessage: "உரையாடலை மூடினால், நீங்கள் முந்தைய பக்கத்துக்குச் சென்றாலும் அல்லது உள்நுழைந்தாலும் கூட உங்களால் தொடரமுடியாது. தொடருவதில் உறுதியாக உள்ளீர்களா?",
        startConversationError: "பக்கத்தைப் புதுப்பித்து புதிய உரையாடலைத் தொடங்கவும்.",
        connectionUnavailable: "இணைப்பு கிடைக்கவில்லை",
        sessionExpired: "அமர்வு காலாவதியாகிவிட்டது",
        sessionError: "உங்கள் அமர்வு காலாவதியாகிவிட்டது. மீண்டும் தொடருவதற்கு இந்த விண்டோவை மூடவும் அல்லது புது உரையாடலைத் தொடங்கவும்.",
        sharkSessionExpired: "பக்கத்தைப் புதுப்பித்து புதிய உரையாடலைத் தொடங்கவும்.",
        logoAltText: "லோகோ"
    },
    'te-IN' : {
        //Failed to connect page
        error: "లోపం",
        couldNotConnect: "అయ్యో - కనెక్ట్ చేయడం సాధ్యం కాలేదు",
        tryAgain: "మళ్లీ ప్రయత్నించండి",
        loadingOnMinimize: "లోడ్ అవుతోంది",
        loading: "లోడ్ అవుతోంది",
        unableToConnect: "కనెక్ట్ చేయలేకపోయింది",
        reconnect: "మళ్లీ కనెక్ట్ అయ్యేందుకు ప్రయత్నిస్తోంది",
        chatEndedOnExternalWindow: "కొత్త చాట్ ప్రారంభించడానికి విండోను క్లోజ్ చేయండి",
        externalWindowOpen: "మీరు ఒక కొనసాగే చాట్‌లో ఉన్నారు. చాట్‌ను కొనసాగించడానికి ఆ విండోకు తిరిగి వెళ్లండి.",
        unsupportedBrowserMode: "మీ బ్రౌజర్ అజ్ఞాత మోడ్‌లో ఉండవచ్చు లేదా మూడవ పక్షం కుక్కీలను అది నిరోధిస్తూ ఉండవచ్చు. దయచేసి, చాట్ చేయడానికి సాధారణ బ్రౌజర్ సెషన్‌ను తెరవండి లేదా మీ బ్రౌజర్ గోప్యతా సెట్టింగ్‌లను తనిఖీ చేయండి",
        cannotResumeChat: "పరస్పర చర్య ప్రారంభమైన ట్యాబ్ నుండి చాట్‌ను పునఃప్రారంభించండి",
        crossDomainError: "సంభాషణను పునఃప్రారంభించడం సాధ్యం కాదు, కొనసాగించడం కోసం దయచేసి మునుపటి పేజీకి తిరిగి వెళ్లండి.",
        chatAuthError: "మీ సంభాషణ కొనసాగించడానికి మునుపటి పేజీకి తిరిగి వెళ్లండి లేదా లాగిన్ చేయండి.",
        confirmMessage: "సంభాషణను మూసివేయడం అంటే, మీరు మళ్లీ వెనుకకు వెళ్లినప్పటికీ లేదా లాగిన్ చేసినప్పటికీ దానిని మీరు కొనసాగించలేరని అర్థం. మీరు నిజంగానే కొనసాగించాలనుకుంటున్నారా?",
        startConversationError: "దయచేసి, పేజీని రిఫ్రెష్ చేయండి మరియు కొత్త సంభాషణను ప్రారంభించండి.",
        connectionUnavailable: "కనెక్షన్ అందుబాటులో లేదు",
        sessionExpired: "సెషన్ ముగిసింది",
        sessionError: "మీ సెషన్ గడువు ముగిసింది. దయచేసి, ఈ విండోను మూసివేయండి మరియు పునఃప్రారంభించడానికి కొత్త సంభాషణను ప్రారంభించండి.",
        sharkSessionExpired: "దయచేసి, పేజీని రిఫ్రెష్ చేయండి మరియు కొత్త సంభాషణను ప్రారంభించండి.",
        logoAltText: "లోగో"
    },
    'bn-IN' : {
        //Failed to connect page
        error: "ত্রুটি",
        couldNotConnect: "উপস্‌ - সংযোগ করা যাচ্ছে না",
        tryAgain: "আবার চেষ্টা করুন",
        loadingOnMinimize: "লোড হচ্ছে",
        loading: "লোড হচ্ছে",
        unableToConnect: "সংযোগ করা যাচ্ছে না",
        reconnect: "আবার সংযোগ করার চেষ্টা করা হচ্ছে",
        chatEndedOnExternalWindow: "নতুন চ্যাট শুরু করতে উইন্ডো বন্ধ করুন",
        externalWindowOpen: "আপনার একটি চ্যাট চলছে। চ্যাটটি চালিয়ে যেতে সেই উইন্ডোতে ফিরে যান।",
        unsupportedBrowserMode: "আপনার ব্রাউজার ইনকগনিটো মোডে থাকতে পারে, বা এটি হয়তো তৃতীয় পক্ষের কুকি ব্লক করছে। চ্যাট করতে অনুগ্রহ করে একটি নিয়মিত ব্রাউজার সেশন খুলুন, বা আপনার ব্রাউজারের গোপনীয়তার সেটিংস চেক করুন",
        cannotResumeChat: "যে ট্যাবে আলাপচারিতা শুরু হয়েছিল সেখান থেকে চ্যাট আবার শুরু করুন",
        crossDomainError: "কথোপকথন আবার শুরু করা যাবে না, অনুগ্রহ করে চালিয়ে যেতে আগের পেজে যান।",
        chatAuthError: "আপনার কথোপকথন চালিয়ে যেতে আগের পেজে যান বা লগ ইন করুন।",
        confirmMessage: "কথোপকথন বন্ধ করার মানে হল এই যে আপনি পেছনে গেলে বা লগ ইন করলেও আর চালিয়ে যেতে পারবেন না। আপনি কি নিশ্চিত যে আপনি এগিয়ে যেতে চান?",
        startConversationError: "অনুগ্রহ করে পেজটি রিফ্রেশ করে একটি নতুন কথোপকথন শুরু করুন।",
        connectionUnavailable: "সংযোগ উপলব্ধ নয়",
        sessionExpired: "সেশনের মেয়াদ শেষ হয়েছে",
        sessionError: "আপনার সেশনের মেয়াদ শেষ হয়েছে। অনুগ্রহ করে এই উইন্ডো বন্ধ করুন এবং আবার শুরু করতে একটি নতুন কথোপকথন শুরু করুন।",
        sharkSessionExpired: "অনুগ্রহ করে পেজটি রিফ্রেশ করে একটি নতুন কথোপকথন শুরু করুন।",
        logoAltText: "লোগো"
    },
    'gu-IN' : {
        //Failed to connect page
        error: "ભૂલ",
        couldNotConnect: "અરેરે - કનેક્ટ કરવામાં અસમર્થ",
        tryAgain: "ફરીથી પ્રયાસ કરો",
        loadingOnMinimize: "લોડ કરી રહ્યું છે",
        loading: "લોડ કરી રહ્યું છે",
        unableToConnect: "કનેક્ટ કરવામાં અસમર્થ",
        reconnect: "ફરીથી કનેક્ટ કરવાનો પ્રયાસ કરી રહ્યાં છીએ",
        chatEndedOnExternalWindow: "નવી ચેટ શરૂ કરવા માટે વિન્ડો બંધ કરો",
        externalWindowOpen: "તમારી એક ચેટ ચાલુ છે. ચેટ ચાલુ રાખવા માટે તે વિન્ડો પર પાછા ફરો.",
        unsupportedBrowserMode: "તમારું બ્રાઉઝર છુપા મોડમાં હોઈ શકે છે, અથવા તે તૃતીય પક્ષ કૂકીઝને અવરોધિત કરી રહ્યું હોઈ શકે છે. કૃપા કરીને ચેટ કરવા માટે નિયમિત બ્રાઉઝર સત્ર ખોલો, અથવા તમારી બ્રાઉઝર ગોપનીયતા સેટિંગ્સ તપાસો",
        cannotResumeChat: "જ્યાં વાતચીત શરૂ થઈ હતી તે ટેબમાંથી ચેટ ફરી શરૂ કરો",
        crossDomainError: "વાતચીત ફરી શરૂ કરી શકાતી નથી, ચાલુ રાખવા માટે કૃપા કરીને પાછલા પૃષ્ઠ પર પાછા ફરો.",
        chatAuthError: "પાછલા પૃષ્ઠ પર પાછા જાઓ અથવા તમારી વાતચીત ચાલુ રાખવા માટે લૉગ ઇન કરો.",
        confirmMessage: "વાતચીત બંધ કરવાનો અર્થ એ છે કે જો તમે પાછા જાઓ અથવા લૉગ ઇન કરો તો પણ તમે ચાલુ રાખી શકશો નહીં. શું તમે ખરેખર આગળ વધવા માંગો છો?",
        startConversationError: "કૃપા કરીને પૃષ્ઠને રીફ્રેશ કરો અને નવી વાતચીત શરૂ કરો.",
        connectionUnavailable: "કનેક્શન અનુપલબ્ધ",
        sessionExpired: "સત્ર સમાપ્ત થયું",
        sessionError: "તમારું સત્ર સમાપ્ત થઈ ગયું છે. કૃપા કરીને આ વિન્ડો બંધ કરો અને ફરી શરૂ કરવા માટે નવી વાતચીત શરૂ કરો.",
        sharkSessionExpired: "કૃપા કરીને પૃષ્ઠને રીફ્રેશ કરો અને નવી વાતચીત શરૂ કરો.",
        logoAltText: "લોગો"
    },
    'kn-IN' : {
        //Failed to connect page
        error: "ದೋಷ",
        couldNotConnect: "ಓಹ್ - ಸಂಪರ್ಕಿಸಲು ಸಾಧ್ಯವಾಗುತ್ತಿಲ್ಲ",
        tryAgain: "ಮತ್ತೊಮ್ಮೆ ಪ್ರಯತ್ನಿಸಿ",
        loadingOnMinimize: "ಲೋಡ್ ಆಗುತ್ತಿದೆ",
        loading: "ಲೋಡ್ ಆಗುತ್ತಿದೆ",
        unableToConnect: "ಸಂಪರ್ಕಿಸಲು ಸಾಧ್ಯವಾಗುತ್ತಿಲ್ಲ",
        reconnect: "ಮರುಸಂಪರ್ಕಿಸಲು ಪ್ರಯತ್ನಿಸಲಾಗುತ್ತಿದೆ",
        chatEndedOnExternalWindow: "ಹೊಸ ಚ್ಯಾಟ್ ಆರಂಭಿಸಲು ಕಿಟಕಿಯನ್ನು ಮುಚ್ಚಿ",
        externalWindowOpen: "ನಿಮ್ಮ ಚ್ಯಾಟ್ ಚಾಲ್ತಿಯಲ್ಲಿದೆ ಚ್ಯಾಟ್ ಅನ್ನು ಮುಂದುವರಿಸಲು ಆ ಕಿಟಕಿಗೆ ಹಿಂತಿರುಗಿ.",
        unsupportedBrowserMode: "ನಿಮ್ಮ ಬ್ರೌಸರ್ ಅಜ್ಞಾತ ಮೋಡ್‌ನಲ್ಲಿರಬಹುದು ಅಥವಾ ಅದು ತೃತೀಯ ಪಕ್ಷಗಳ ಕುಕೀಗಳನ್ನು ನಿರ್ಬಂಧಿಸುತ್ತಿರಬಹುದು. ದಯವಿಟ್ಟು ಚ್ಯಾಟ್ ಮಾಡಲು ಸಾಮಾನ್ಯ ಬ್ರೌಸರ್ ಸೆಷನ್‌ವೊಂದನ್ನು ತೆರೆಯಿರಿ ಅಥವಾ ನಿಮ್ಮ ಬ್ರೌಸರ್‌ನ ಗೌಪ್ಯತಾ ಸೆಟ್ಟಿಂಗ್‌ಗಳನ್ನು ಪರಿಶೀಲಿಸಿ",
        cannotResumeChat: "ಸಂವಹನ ಆರಂಭವಾದ ಟ್ಯಾಬ್‌ನಿಂದ ಚ್ಯಾಟ್ ಅನ್ನು ಮುಂದುವರಿಸಿ",
        crossDomainError: "ಸಂಭಾಷಣೆಯನ್ನು ಮುಂದುವರಿಸಲಾಗದು, ಮುಂದುವರಿಸಲು ದಯವಿಟ್ಟು ಹಿಂದಿನ ಪುಟಕ್ಕೆ ಹಿಂತಿರುಗಿ.",
        chatAuthError: "ನಿಮ್ಮ ಸಂಭಾಷಣೆಯನ್ನು ಮುಂದುವರಿಸಲು ಹಿಂದಿನ ಪುಟಕ್ಕೆ ಹಿಂತಿರುಗಿ ಅಥವಾ ಲಾಗ್ ಇನ್ ಮಾಡಿ.",
        confirmMessage: "ಸಂಭಾಷಣೆಯನ್ನು ಮುಚ್ಚಿದರೆ ನೀವು ಹಿಂದೆ ಹೋದರೂ ಅಥವಾ ಲಾಗ್ ಇನ್ ಮಾಡಿದರೂ ಸಹ ನಿಮಗೆ ಮುಂದುವರಿಸಲಾಗದು. ನೀವು ಮುಂದುವರಿಯಲು ಖಚಿತವಾಗಿ ಬಯಸುವಿರಾ?",
        startConversationError: "ದಯವಿಟ್ಟು ಪುಟವನ್ನು ರಿಫ್ರೆಶ್ ಮಾಡಿ ಹಾಗೂ ಹೊಸ ಸಂಭಾಷಣೆಯೊಂದನ್ನು ಆರಂಭಿಸಿ.",
        connectionUnavailable: "ಸಂಪರ್ಕ ಲಭ್ಯವಿಲ್ಲ",
        sessionExpired: "ಸೆಷನ್ ಅವಧಿ ಮೀರಿದೆ",
        sessionError: "ನಿಮ್ಮ ಸೆಷನ್ ಅವಧಿ ಮೀರಿದೆ. ಮುಂದುವರಿಸಲು ದಯವಿಟ್ಟು ಈ ಕಿಟಕಿಯನ್ನು ಮುಚ್ಚಿ ಹಾಗೂ ಹೊಸ ಸಂಭಾಷಣೆಯೊಂದನ್ನು ಆರಂಭಿಸಿ.",
        sharkSessionExpired: "ದಯವಿಟ್ಟು ಪುಟವನ್ನು ರಿಫ್ರೆಶ್ ಮಾಡಿ ಹಾಗೂ ಹೊಸ ಸಂಭಾಷಣೆಯೊಂದನ್ನು ಆರಂಭಿಸಿ.",
        logoAltText: "ಲೋಗೋ"
    },
    'ml-IN' : {
        //Failed to connect page
        error: "പിശക്",
        couldNotConnect: "ക്ഷമിക്കണം - കണക്റ്റ് ചെയ്യാൻ കഴിയുന്നില്ല",
        tryAgain: "വീണ്ടും ശ്രമിക്കുക",
        loadingOnMinimize: "ലോഡ് ചെയ്യുന്നു",
        loading: "ലോഡ് ചെയ്യുന്നു",
        unableToConnect: "കണക്റ്റ് ചെയ്യാൻ കഴിയുന്നില്ല",
        reconnect: "വീണ്ടും കണക്റ്റ് ചെയ്യാൻ ശ്രമിക്കുന്നു",
        chatEndedOnExternalWindow: "പുതിയ ചാറ്റ് ആരംഭിക്കുന്നതിന് വിൻഡോ അടയ്ക്കുക",
        externalWindowOpen: "നിങ്ങളുടെ ഒരു ചാറ്റ് ഇപ്പോഴും നിലനിൽക്കുന്നു ചാറ്റ് തുടരാൻ ആ വിൻഡോയിലേക്ക് മടങ്ങുക.",
        unsupportedBrowserMode: "നിങ്ങളുടെ ബ്രൗസർ ഇൻകൊഗ്നിറ്റോ മോഡിൽ ആയിരിക്കാം, അല്ലെങ്കിൽ അത് മൂന്നാം കക്ഷി കുക്കികളെ തടയുന്നുണ്ടാകാം. ചാറ്റ് ചെയ്യുന്നതിന് ഒരു സാധാരണ ബ്രൗസർ സെഷൻ തുറക്കുക, അല്ലെങ്കിൽ നിങ്ങളുടെ ബ്രൗസർ സ്വകാര്യതാ ക്രമീകരണം പരിശോധിക്കുക",
        cannotResumeChat: "ആശയവിനിമയം ആരംഭിച്ച ടാബിൽ നിന്ന് ചാറ്റ് പുനരാരംഭിക്കുക",
        crossDomainError: "സംഭാഷണം പുനരാരംഭിക്കാനാവില്ല, തുടരുന്നതിന് മുമ്പത്തെ പേജിലേക്ക് മടങ്ങുക.",
        chatAuthError: "നിങ്ങളുടെ സംഭാഷണം തുടരുന്നതിന് മുമ്പത്തെ പേജിലേക്ക് മടങ്ങുക അല്ലെങ്കിൽ ലോഗിൻ ചെയ്യുക.",
        confirmMessage: "സംഭാഷണം അവസാനിപ്പിക്കുക എന്നതിനർത്ഥം നിങ്ങൾ തിരികെ പോയാലും ലോഗിൻ ചെയ്താലും നിങ്ങൾക്ക് തുടരാനാകില്ല എന്നാണ്. നിങ്ങൾക്ക് തുടരണമെന്ന് തീർച്ചയാണോ?",
        startConversationError: "പേജ് പുതുക്കി ഒരു പുതിയ സംഭാഷണം ആരംഭിക്കുക.",
        connectionUnavailable: "കണക്ഷൻ ലഭ്യമല്ല",
        sessionExpired: "സെഷൻ കാലഹരണപ്പെട്ടു",
        sessionError: "നിങ്ങളുടെ സെഷൻ കാലഹരണപ്പെട്ടു. പുനരാരംഭിക്കുന്നതിന് ഈ വിൻഡോ അടച്ച് ഒരു പുതിയ സംഭാഷണം ആരംഭിക്കുക.",
        sharkSessionExpired: "പേജ് പുതുക്കി ഒരു പുതിയ സംഭാഷണം ആരംഭിക്കുക.",
        logoAltText: "ലോഗോ"
    },
    'mr-IN' : {
        //Failed to connect page
        error: "एरर",
        couldNotConnect: "अरेरे - कनेक्ट करता आले नाही",
        tryAgain: "पुन्हा प्रयत्न करा",
        loadingOnMinimize: "लोड करत आहे",
        loading: "लोड करत आहे",
        unableToConnect: "कनेक्ट करता आले नाही",
        reconnect: "पुन्हा कनेक्ट करण्याचा प्रयत्न करत आहे",
        chatEndedOnExternalWindow: "नवीन चॅट सुरू करण्यासाठी विंडो बंद करा",
        externalWindowOpen: "तुमचे एक चॅट चालू आहे. चॅट सुरू करण्यासाठी त्या विंडोवर परत या.",
        unsupportedBrowserMode: "तुमचा ब्राउजर कदाचित इन्कॉग्निटो मोडमध्ये आहे किंवा तो थर्ड पार्टी कूकीजना ब्लॉक करत आहे. कृपया चॅट करण्यासाठी नेहमीचा ब्राउझर उघडा किंवा तुमच्या ब्राउझरच्या गोपनीयता सेटिंग्ज तपासा",
        cannotResumeChat: "परस्परसंवाद जिथून सुरू झाले त्या टॅबवरून चॅट पुढे सुरू ठेवा",
        crossDomainError: "संभाषण पुढे सुरू ठेवू शकत नाही, कृपया पुढे जाण्यासाठी याआधीच्या पेजवर परत जा.",
        chatAuthError: "याआधीच्या पेजवर परत जा किंवा तुमचे संभाषण सुरू ठेवण्यासाठी लॉग इन करा.",
        confirmMessage: "संभाषण बंद करणे म्हणजे तुम्ही मागे गेलात किंवा लॉग इन केलेत तरी सुरू ठेवू शकणार नाही. तुम्हाला नक्की पुढे जायचे आहे का?",
        startConversationError: "कृपया पेज रीफ्रेश करा आणि नवीन संभाषण सुरू करा.",
        connectionUnavailable: "कनेक्शन अनुपलब्ध आहे",
        sessionExpired: "सेशनची मुदत संपली",
        sessionError: "तुमच्या सेशनची मुदत संपली आहे. कृपया ही विंडो बंद करा आणि पुढे सुरू ठेवण्यासाठी एक नवीन संभाषण सुरू करा.",
        sharkSessionExpired: "कृपया पेज रीफ्रेश करा आणि नवीन संभाषण सुरू करा.",
        logoAltText: "लोगो"
    },
    'bho' : {
        //Failed to connect page
        error: "गड़बड़ी",
        couldNotConnect: "ओह - कनेक्ट नइखे हो पावत",
        tryAgain: "फेर से कोसिस करीं",
        loadingOnMinimize: "लोड हो रहल बा",
        loading: "लोड हो रहल बा",
        unableToConnect: "कनेक्ट नइखे हो पावत",
        reconnect: "वापस कनेक्ट होखे के कोसिस जारी बा",
        chatEndedOnExternalWindow: "नया चैट चालू करे खातिर विंडो बंद करीं",
        externalWindowOpen: "राउर एगो चैट चालू बा. चैट जारी राखे खातिर ओही विंडो प लवटीं.",
        unsupportedBrowserMode: "हो सकेला कि राउर ब्राउजर गुप्त मोड में होखे, आ नाहीं त ओकरी पर तिसरे पार्टी के कुकीज ब्लॉक होखे. कृपा कके चैट करे खातिर हमेशा नियमित ब्राउजर सत्र खोलीं, आ नाहीं त आपन ब्राउजर के गोपनीयता सेटिंग जाँचींं",
        cannotResumeChat: "जेनी बातचीत शुरू कइनीं तवने टैब से चैट आगे बढ़ाईं",
        crossDomainError: "बातचीत आगे ना हो सकेला, आगे बढ़े खातिर पछिलका पेज पर लवट आईं.",
        chatAuthError: "आपन बतियावल जारी राखे खातिर पछिलका पेज पर वापस जाईं भा लॉग इन करीं.",
        confirmMessage: "बतियावल बंद कइले के माने कि रउवा वापस लवट के भा लॉग इन कके आगे ना बढ़ पाइब. रउवा सचहुँँओ आगे बढ़ल चाहऽ तानींं?",
        startConversationError: "पेज के रिफ्रेश करीं आ नया बतियावल चालू करीं.",
        connectionUnavailable: "कनेक्शन उपलब्ध नइखे",
        sessionExpired: "सत्र के समय खतम हो गइल",
        sessionError: "राउर सत्र के समय खतम हो गइल. वापस आगे से चालू करे खातिर हई विंडो बंद कके नया बतियावल चालू करीं.",
        sharkSessionExpired: "पेज के रिफ्रेश करीं आ नया बतियावल चालू करीं.",
        logoAltText: "निशान"
    }
};



/****************************************************************/

window.lpTag = window.lpTag || {};
lpTag.taglets = lpTag.taglets || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};

/**
 * This class is responsible understanding the device family, OS in depth, Browser and stating if the page is mobile optimized
 *
 * Dependencies:
 * @link lpTag.device,
 * @link lpTag.unifiedWindow.log,
 * @link lpTag.taglets.lpUtil
 */
lpTag.unifiedWindow.DeviceDetector = lpTag.unifiedWindow.DeviceDetector || function () {

    var name = "DeviceDetector",
        log = lpTag.unifiedWindow.log,
        util = lpTag.taglets.lpUtil,
        device = lpTag.device,
        userAgent = navigator.userAgent,
        appName = navigator.appName,
        appVersion = navigator.appVersion, //CAUTION: use with care as some browsers not support this
        deviceOS = device.os(),
        deviceFamily = device.family(),
        browserFamily = device.browser(),
        osVer = _detectOSVersion(),
        browserVer = _detectBrowserVersion(),
        mobileWebsite = _verifyMobileWebsite(),
        animationSupported,
        animationData,
        transitionData,
        transitionSupported,
        audioSupported;


    _init();

    function isDesktop() {
        return deviceFamily === device.familyEnum.desktop;
    }

    function isMobile() {
        return deviceFamily === device.familyEnum.mobile;
    }

    function isTablet() {
        return deviceFamily === device.familyEnum.tablet;
    }

    function isIPad() {
        //the part after last logical OR is a trick to detect iPad PRO as it's user agent is the same as for desktop Mac
        return ( isTablet() && isIOS() ) || / iPad/i.test(navigator.userAgent) || /Macintosh/.test(navigator.userAgent) && 'ontouchend' in document;
    }

    function isIOS() {
        return deviceOS === device.osEnum.iOS;
    }

    function isAndroid() {
        return deviceOS === device.osEnum.android;
    }

    function isChrome() {
        return browserFamily === device.browserEnum.chrome;
    }

    function isNativeAndroid() {
        return isAndroid() && !isChrome();
    }

    function isAndroidChrome() {
        return isAndroid() && isChrome();
    }

    function isMobileOptimized() {
        return mobileWebsite;
    }

    function isAnimationSupported() {
        return animationSupported;
    }

    function getAnimationData() {
        return animationData;
    }

    function isTransitionSupported() {
        return transitionSupported;
    }

    function isAudioSupported() {
        if (typeof audioSupported === 'boolean') {
            return audioSupported;
        }
        var audioSupportFlag = true;
        try {
            new Audio();
        } catch(e) {
            audioSupportFlag = false;
        }
        return audioSupportFlag;
    }

    function getTransitionData() {
        return transitionData;
    }

    function osVersion() {
        return osVer;
    }

    function browserVersion() {
        return browserVer;
    }

    function isIOS7() {
        if (isIOS()) {
            return _getOsVersion() <= 7 || false;
        }
    }

    function isIOS6() {
        if (isIOS()) {
            return _getOsVersion() <= 6 || false;
        }
    }

    function isIOS8OrAbove() {
        if (isIOS()) {
            return _getOsVersion() >= 8 || false;
        }
    }

    function isIOS13() {
        if (isIOS()) {
            return _getOsVersion() === 13 || false;
        }
    }

    function isIOS15() {
        if (isIOS()) {
            var osV = userAgent.match(/Version\/(.+?)\s/);
            osV = osV && osV.length > 0 ? osV[1] : null;
            return parseInt(osV, 10) >= 15;
        }
    }
    function isOldIOS15() {
        if (isIOS()) {
            var osV = userAgent.match(/Version\/(.+?)\s/);
            osV = osV && osV.length > 0 ? osV[1] : null;
            var checkVersion = (parseFloat(osV,10) === 15) || (parseFloat(osV,10) === 15.1);
            return checkVersion;
        }
    }

    function isWindows() {
        return deviceOS === device.osEnum.windows;
    }

    function isMacOS() {
        return deviceOS === device.osEnum.mac;
    }

    function isIE() {
        return appName === 'Microsoft Internet Explorer' || isIE11Plus();
    }

    function isIE11Plus() {//This is to force us to recognize A version of IE, since IE has dropped appName or any refrernce od
        return userAgent.match(/Trident.*rv[ :]*11\./);
    }

    function isEdge() {
        return browserFamily === device.browserEnum.edge;
    }

    function getDeviceFamilyName() {
        return device.familyName();
    }

    function canAttemptSMSClientLaunch() {
        return isMobile() && !isTablet() && !isIE();
    }

    function isIpadChrome() {
        return browserFamily === device.browserEnum.chromeios && isTablet() && isIOS();
    }

    function _init(){
        var div = document.createElement("DIV");
        _checkAnimationSupport(div);
        _checkTransitionSupport(div);
        div = null;
    }

    function _detectOSVersion() {
        var version;
        if (typeof device.osVersion === 'function') {
            version = device.osVersion();
            if (version) {
                return version;
            }
        }
        
        if (isAndroid()) {
            version = userAgent.match(/Android (\d+)\.(\d+)(?:\.(\d+))?;+/i);
        } else if (isIOS()) {
            version = userAgent.match(/OS (\d+)_(\d+)(?:_(\d+))?\s+/i);
        }
        return version;
    }

    function _detectBrowserVersion() {
        if (typeof device.browserVersion === 'function') {
            return device.browserVersion();
        }

        var version;
        if (isIE()) {
            if (!isIE11Plus()) {
                var regex = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
                try {
                    if (regex.exec(userAgent) != null) {
                        version = parseFloat(RegExp.$1);
                    }
                } catch (e) {
                    //<excludeFromBuild>
                    log.error("_detectBrowserVersion: Could not detect IE version", name);
                    //</excludeFromBuild>
                }
            } else {
                version = 11;//This is the supposed version...it might be higher , but who knows? maybe MS?
            }
        } else if (isSafari()) { //this is taken from: http://www.javascripter.net/faq/browsern.htm
            var verOffset = userAgent.indexOf("Safari");
            if (verOffset > -1) {
                var fullVersion = userAgent.substring(verOffset+7);
                verOffset=userAgent.indexOf("Version");
                if (verOffset > -1) {
                    fullVersion = userAgent.substring(verOffset + 8);
                }

                var ix = fullVersion.indexOf(";");
                if (ix > -1) {
                    fullVersion = fullVersion.substring(0, ix);
                }
                ix = fullVersion.indexOf(" ");
                if (ix > -1) {
                    fullVersion = fullVersion.substring(0, ix);
                }

                var majorVersion = parseInt(''+fullVersion,10);
                if (isNaN(majorVersion)) {
                    majorVersion = parseInt(appVersion,10);
                }
                version = majorVersion;
            }
        }
        return version;
    }

    function isSafari() {
        return device.browser() === device.browserEnum.safari;
    }

    /**
     * When optimizing a webpage for mobile devices, the first step is to add the viewport meta tag to the HEAD section of your page,
     * so that mobile devices refrain from making changes to the zoom level of the webpage unilaterally.
     * In most cases you'll simply want to set the meta tag's content property to "width=device-width",
     * so that no scaling of the page occurs at all, and your CSS media queries will return the actual dimensions of the device,
     * not the "zoomed out" version's.
     * To also prevent the device from zooming in on a webpage when its orientation has been changed from portrait to landscape and visa versa,
     * you can also throw in an initial-scale and maximum-scale property and limit both of them to 1:
     *
     * <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
     *
     * source: http://www.javascriptkit.com/dhtmltutors/cssmediaqueries3.shtml
     */
    function _verifyMobileWebsite() {
        var elements = document.getElementsByName("viewport");
        if (elements.length > 0) {
            for (var i = 0; i < elements.length; i++) {
                var content = _parseContent(elements[i].content);
                if (content.width === 'device-width') {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if animation is supported
     * @private
     */
    function _checkAnimationSupport(elem) {
        animationData = _getPrefixData(elem, "AnimationName");
        if (animationData.supported) {
            animationSupported = true;
        }
    }

    /**
     * Checks if transitions are supported
     * @private
     */
    function _checkTransitionSupport(elem) {
        transitionData = _getPrefixData(elem, "Transition");
        if (transitionData.supported) {
            transitionSupported = true;
        }
    }

    /**
     * Generic function for checking if some newer
     * CSS3 animation/transition features can be used
     * @param elem
     * @param propertyNameCaps - the property as it would appear appended to a prefix, examples: Transition, Animation
     * @returns {{supported: boolean, preFix: *, propertyName: *}}
     */
    function _getPrefixData(elem, propertyNameCaps) {

        var preFixes = {
                "Webkit": "-webkit-",
                "Moz": "-moz-",
                "O": "-o-",
                "ms": "-ms-",
                "Khtml": "-khtml-"
            },
            supported = false,
            prefix,
            propertyNoPrefix = propertyNameCaps ? propertyNameCaps.substring(0,1).toLowerCase() + propertyNameCaps.substr(1) : '',
            cssPropertyName = propertyNoPrefix,
            jsPropertyName = propertyNameCaps;

        if (propertyNoPrefix && typeof elem.style[propertyNoPrefix] !== 'undefined') {
            supported = true;
            prefix = '';
        }
        if(!supported) {
            for (var key in preFixes) {
                if (propertyNameCaps && preFixes.hasOwnProperty(key) &&
                    typeof elem.style[ key + propertyNameCaps ] !== 'undefined') {
                    prefix = preFixes[key];
                    cssPropertyName = prefix + propertyNoPrefix;
                    jsPropertyName = key + propertyNameCaps;
                    supported = true;
                    break;
                }
            }
        }

        return {
            supported: supported,
            preFix: supported ? prefix : '',
            propertyName: supported ? jsPropertyName : '',
            cssPropertyName : supported ? cssPropertyName : ''
        };
    }

    function _parseContent(content) {
        var split = content.split(',');
        var defaultProperties = {};

        var property;
        for (var i = 0; i < split.length; i++) {
            property = split[i].split('=');
            defaultProperties[util.trimAndLower(property[0])] = util.trimAndLower(property[1]);
        }
        return defaultProperties;
    }

    function _getOsVersion() {
        if (typeof device.osVersion === 'function') {
            var ver = device.osVersion();
            if (ver) {
                return isNaN(ver) ? ver : Number(ver);
            }
        }
        return Number(osVer[1]);
    }

    return {
        isDesktop: isDesktop,
        isMobile: isMobile,
        isTablet: isTablet,
        isMobileOptimized: isMobileOptimized,
        isAnimationSupported: isAnimationSupported,
        getAnimationData: getAnimationData,
        isTransitionSupported: isTransitionSupported,
        isAudioSupported: isAudioSupported,
        getTransitionData: getTransitionData,
        isAndroid: isAndroid,
        isIPad: isIPad,
        isNativeAndroid: isNativeAndroid,
        isIOS: isIOS,
        isWindows: isWindows,
        isMacOS: isMacOS,
        getDeviceFamilyName: getDeviceFamilyName,
        osVersion: osVersion,
        browserVersion: browserVersion,
        isIOS6: isIOS6,
        isIOS7: isIOS7,
        isIOS13: isIOS13,
        isIOS15: isIOS15,
        isOldIOS15: isOldIOS15,
        isIOS8OrAbove: isIOS8OrAbove,
        isIE: isIE,
        canAttemptSMSClientLaunch: canAttemptSMSClientLaunch,
        isEdge: isEdge,
        isSafari: isSafari,
        isAndroidChrome: isAndroidChrome,
        isIpadChrome: isIpadChrome
    };

};


/****************************************************************/

/**
 * ***************************************************************
 * Taglet name: lpTag.unifiedWindow.Events
 *
 *  *****************************************************************
 * * Dependencies: @lpTag.Events
 * ******************************************************************
 *
 * ************************** PROPERTIES ****************************
 *
 * lpTag.Events's properties
 *
 */

window.lpTag = window.lpTag || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};

lpTag.unifiedWindow.Events = lpTag.unifiedWindow.Events || function (defaults) {

    var lpTagEvent,
        originalTriggerFunc,
        utils,
        publicEvents;

    init(defaults);

    function init(defaults) {
        lpTagEvent = new lpTag.Events(defaults);
        originalTriggerFunc = lpTagEvent.trigger;
        lpTagEvent.trigger = _trigger;
        utils = lpTag.taglets.lpUtil;
    }

    /**
     * Trigger function for events
     * which also allows global ones
     * @param app
     * @param evName
     * @param data
     * @private
     */
    function _trigger(app, evName, data) {

        originalTriggerFunc(app, evName, data);

        _triggerPublicEvents(app);

    }

    /**
     * Checks if there is a global event to trigger and triggers it
     * @param eventData
     * @private
     */
    function _triggerPublicEvents(eventData) {
        var models,
            newModel,
            newPublicEvents;

        if (!publicEvents) {
            publicEvents = utils.getPropertyFromObject(lpTag, "unifiedWindow.publicEvents");
        }

        eventData = (typeof eventData === "object") ? eventData : null;
        newModel = eventData && publicEvents && (publicEvents[eventData.appName] && publicEvents[eventData.appName][eventData.eventName]);
        // "global" property supported only when app is the event data object.

        if (lpTag.events && eventData &&
            (eventData.global || newModel)) {

            if(eventData.global) {
                eventData.passDataByRef = false;
                eventData.aSync = true;
                lpTag.events.trigger(eventData);
            }

            if (newModel) {
                models = Array.isArray(newModel) ? newModel : [newModel];
                for (var i = 0; i < models.length; i++) {
                    newPublicEvents = _buildNewEvent(eventData, models[i]);
                    lpTag.events.trigger(newPublicEvents);
                }
            }
        }
    }

    /**
     * Creates a new event based on public event configuration
     * Does not fire the original event
     * @param event
     * @param newModel
     * @returns {*}
     * @private
     */
    function _buildNewEvent(event, newModel) {
        var newEvent = utils.clone(newModel);
        newEvent.passDataByRef = false;
        newEvent.aSync = true;
        newEvent.data = _remodel(event, newEvent.data);
        return newEvent;
    }

    /**
     * Gets some data according to configuration
     * @param obj
     * @param modelStructure
     * @returns {{}}
     * @private
     */
    function _remodel(obj, modelStructure) {
        var resultObject = {};

        if(typeof modelStructure === "object") {
            for (var key in modelStructure) {
                resultObject[key] = utils.getPropertyFromObject(obj, modelStructure[key]);
            }
        } else {
            resultObject = utils.getPropertyFromObject(obj, modelStructure);
        }
        return resultObject;
    }

    return lpTagEvent;
};

/****************************************************************/

(function () {

    window.lpTag = window.lpTag || {};
    lpTag.unifiedWindow.language = lpTag.unifiedWindow.language || new _Language();
    /**
     * @param options
     *          isRTL - whether added language is right-to-left
     */
    lpTag.unifiedWindow.addLanguage = function (lang, options) {
        lpTag.unifiedWindow.language.add(lang, options);
    };

    function _Language() {

        /** variables **/

        var languages = {},
            currentLocale,
            tagletConfig = {},
            logger = window.lpTag.unifiedWindow.log,
            DEFAULT_LANG = "en-US";

        var rtlLanguages = {
            'he-IL': true,
            'ar-AE': true
        };

        /** public functions **/
        function getString(key) {
            var str = _getTranslationOverrideIfExists(key);
            if(str && typeof str === "string") {
                return str;
            }

            str = languages[currentLocale] && languages[currentLocale][key];
            return (typeof str === "string") ? str : _getDefaultDictionaryValue(key) || "";
        }

        function getLocaleConfig() {
            var locale =  currentLocale || DEFAULT_LANG;
            if (locale) {
                var defaultDictionary = lpTag.unifiedWindow.defaultDictionary;
                var configKey = '__config__';
                return defaultDictionary && defaultDictionary[locale] && defaultDictionary[locale][configKey];
            }
        }

        function isRTL(lang) {
            return rtlLanguages[lang] === true;
        }

        function setLocale(locale) {
            currentLocale = locale || DEFAULT_LANG;
        }

        function getLocale() {
            return currentLocale;
        }

        function add(dictionaryObj, options) {
            options = options || {};
            languages[options.locale] = languages[options.locale] || {};

            lpTag.taglets.lpUtil.cloneExtend(dictionaryObj, languages[options.locale]);

            if (options.locale === DEFAULT_LANG) {
                lpTag.taglets.lpUtil.cloneExtend(dictionaryObj, lpTag.unifiedWindow.defaultDictionary);
            }
        }

        function setConfig(tagletCfg) {
            tagletConfig = tagletCfg;
        }

        function _getDefaultDictionaryValue(key) {
            var defaultDictionary = lpTag.unifiedWindow.defaultDictionary;

            if (defaultDictionary[currentLocale] && defaultDictionary[currentLocale][key]) {
                return defaultDictionary[currentLocale][key];
            } else {
                return defaultDictionary[key];
            }
        }

        function _getTranslationOverrideIfExists(key) {
            var overrideValue;
            var localeOverrideCfg;

            if(tagletConfig && tagletConfig.translationOverrides) {
                try {
                    if(tagletConfig.translationOverrides.hasOwnProperty(currentLocale)) {
                        localeOverrideCfg = tagletConfig.translationOverrides[currentLocale];
                        
                        if(localeOverrideCfg && localeOverrideCfg.hasOwnProperty(key)) {
                            overrideValue = localeOverrideCfg[key];
                        }
                    }
                }
                catch (ex) {
                    overrideValue = undefined;

                    //There is a chance that the logger is not ready by the time Language() is initialized. This is to retry seting the logger if it already isn't.
                    if(!logger) {
                        logger = window.lpTag.unifiedWindow.log;
                    }

                    if(logger && logger.error) {
                        logger.error("Language ERROR : " + ex.message);
                    } else {
                        window.console.error("Language ERROR : " + ex.message);
                    }
                }
            }

            return overrideValue;
        }

        /** revealing area **/

        return {
            getString: getString,
            getLocaleConfig: getLocaleConfig,
            isRTL: isRTL,
            add: add,
            setLocale: setLocale,
            getLocale: getLocale,
            setConfig: setConfig
        };
    }

})();

/****************************************************************/

window.lpTag = window.lpTag || {};
lpTag.taglets = lpTag.taglets || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};

/**
 * This Object is a log for the whole system
 * It is environment aware, meaning if env is qa/dev log are on by default.
 * Backdoor available for console logging by adding lpDebug=1 to the url as a query param.
 * -- For example, debug level use: lpDebug=2&debugLevel=true
 * 
 * Info level console logging available through configuration 'debug' property below.
 * Persisting logs to Kibana (via Loggos service) is available through 'loggosLogging' configuration below.
 * - init(conf)
 *      conf = {
 *          debug: true/false,
 *          loggosLogging: {
 *              level: [0 - 3] (required)
 *              queueSubmissionIntervalMilliseconds: [> 0], (required)
 *              queueSubmissionMaximum: [> 0],
                samplingPercentage: [<= 1.0]
 *          }
 *      }
 * 
 * Dependencies:
 * @link lpTag.log,
 * @link lpTag.csds,
 * @link lpTag.taglets.lpUtil
 * @link lpTag.taglets.lpUnifiedWindow
 */
lpTag.unifiedWindow.log = lpTag.unifiedWindow.log || (function () {

    var name = "UnifiedWindowLogger",
        util,
        logLevels = { "ERROR" : 1, "INFO" : 2, "DEBUG" : 3 },
        blackList = ["lp_SMT", "lp_monitoringSDK", "LP_OFFER"],
        defaultLogLevel = logLevels.ERROR,
        consoleLogging = { isEnabled: false },
        loggosLogging = { level: 0 },
        loggosUrl = "",
        loggosLogQueue = [],
        events = { APP_STARTED: 'appStarted', APP_ENDED: 'appEnded' },
        isAppStarted = false;

    function init(conf) {
        util = lpTag.taglets.lpUtil;
        loggosLogging =  util.cloneExtend((conf.loggosLogging || {}), loggosLogging, true);
        loggosUrl = "https://" + lpTag.csds.getDomain("loggos") + "/api/loggos/log/";

        var params = util.getURLParams(window.location.search);
        var backdoor = params.lpDebug;
        if (backdoor) {
            consoleLogging.isEnabled = true;
            if (backdoor === "2" && params.debugLevel === "true") {
                setLogLevel("DEBUG");
            } else {
                setLogLevel(Object.keys(logLevels).reduce(function (accum, level) {
                    if (logLevels[level] === +backdoor) {
                        accum = level;
                    }
                    return accum;
                }, defaultLogLevel));
            }
        } else if (conf.debug) {
            consoleLogging.isEnabled = true;
            setLogLevel("INFO");
        }

        _setUpLogs();
    }

    function getTime(){
        var now = new Date();
        return  now.getHours() + ":" +
            (now.getMinutes() < 10 ? "0" + now.getMinutes() : now.getMinutes()) + ":" +
            (now.getSeconds() < 10 ? "0" + now.getSeconds() : now.getSeconds());
    }

    function error(msg, appName) {
        _log(msg, 'ERROR', appName || name);
    }

    function info(msg, appName) {
        _log(msg, 'INFO', appName || name);
    }

    function debug(msg, appName) {
        _log(msg, 'DEBUG', appName || name);
    }

    function setLogLevel(newLevel){
        if(logLevels[newLevel]){
            defaultLogLevel = logLevels[newLevel];
        }
    }

    function triggerEvent(name){
        switch (name) {
            case events.APP_STARTED:
                isAppStarted = true; break;
            case events.APP_ENDED:
                isAppStarted = false; break;
        }
    }

    /*****************
     * PRIVATE SCOPE *
     *****************/

    function _setUpLogs() {
        window.lpTaglogListeners = window.lpTaglogListeners || [];

        if (consoleLogging.isEnabled) {
            window.lpTaglogListeners.push(function (msg, level, app) {
                if (window.console && level && logLevels[level] <= defaultLogLevel) {
                    if (util.indexOf(blackList, app) === -1) {
                        console.log(getTime() + " " + app + " : " + msg + " LEVEL: " + level);
                    }
                }
            });
        }

        // set up Loggos logging if configured
        if (loggosLogging.level > 0) {
            // if a sampling rate is configured, determine if this instance is in the sample
            loggosLogging.inSample = !loggosLogging.samplingPercentage || ((loggosLogging.samplingPercentage * 1000) > new Date().getMilliseconds()) ? true : false; 
            if (loggosLogging.inSample) {
                window.lpTaglogListeners.push(function (msg, level, app) {
                    if (level && logLevels[level] <= loggosLogging.level && isAppStarted) { // only log to Loggos at configured verbosity level and if the UW app is started
                        if (util.indexOf(blackList, app) === -1) {
                            _addToLoggosLogQueue(msg, level, app);
                        }
                    }
                });
                _processLoggosLogQueue();
            }
        }
    }

    // process the Loggos log queue at the configured interval
    function _processLoggosLogQueue() {
        if (loggosLogging.level > 0 &&
            loggosLogging.queueSubmissionIntervalMilliseconds &&
            !isNaN(loggosLogging.queueSubmissionIntervalMilliseconds)) {
            
            var that = this;
            var logsToProcess = loggosLogQueue.splice(0, loggosLogging.queueSubmissionMaximum || loggosLogQueue.length);  // get configured max logs for processing or all
            if (logsToProcess.length > 0) {
                var xhr = new XMLHttpRequest();
                xhr.open("POST", loggosUrl, true);
                xhr.setRequestHeader("Content-Type", "application/json");
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                            // Success
                        } else {
                            // Error: if some failure then put logs back in queue
                            loggosLogQueue = loggosLogQueue.concat(logsToProcess);
                            error("There was an error sending logs to Loggos: " + xhr.statusText, name);
                        }
                        setTimeout(function() { _processLoggosLogQueue.call(that); }, loggosLogging.queueSubmissionIntervalMilliseconds);
                    }
                };
                xhr.send(JSON.stringify(logsToProcess));
            } else {
                setTimeout(function() { _processLoggosLogQueue.call(that); }, loggosLogging.queueSubmissionIntervalMilliseconds);
            }
        }
    }

    function _log(msg, lvl, _name) {
        if (window.lpTag && lpTag.log && msg) {
            lpTag.log(msg, lvl, _name || name);
        }
    }

    function _addToLoggosLogQueue(msg, lvl, appName) {
        var log = {
            accountId: lpTag.site,
            appVersion: lpTag.taglets.lpUnifiedWindow.v,
            context: "webMessaging",
            immediate: true,
            logLevel: lvl,
            msg: lvl + " : " + appName + " : " + msg,
            time: new Date().toISOString(),
            trace: false,
            url: window.location.href
        };
        loggosLogQueue.push(log);
    }

    return {
        init: init,
        error: error,
        info: info,
        debug: debug,
        setLogLevel: setLogLevel,
        logLevels: logLevels,
        events: events,
        triggerEvent: triggerEvent,
        loggosLogging: loggosLogging,
        loggosLogQueue: loggosLogQueue
    };

})();

/****************************************************************/

window.lpTag = window.lpTag || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};

lpTag.unifiedWindow.PKCEManager = lpTag.unifiedWindow.PKCEManager || function () {
    var appContext;
    var secureStorageDomain;
    var log = lpTag.unifiedWindow.log;
    var name = "PKCEManager";
    var pkceCodeVerifierLength = 64;
    var pkceDataName = "pkceData";
    // 2 minutes by default to complete authorisation
    var pkceTtl = 120000;

    function init() {
        secureStorageDomain = lpTag && lpTag.csds && lpTag.csds.getDomain('leCdnDomain');
    }

    function setAppContext(context) {
        appContext = context;
    }

    /**
     * Gets PKCE data from SecureStorage
     * @param successCallback
     * @param errorCallback
     */
    function getPKCEFromSecureStorage(successCallback, errorCallback) {
        var appName = lpTag.unifiedWindow.apps.AUTHENTICATION;
        window.lpTag.taglets.lpSecureStorage.getValue({
            key: pkceDataName,
            site: lpTag && lpTag.site,
            app: appName,
            appName: appName,
            domain: _getSecureStoragePath(secureStorageDomain),
            success: successCallback,
            error: errorCallback,
            firstParty: true
        });
    }

    /**
     * Sets PKCE data into secure storage
     * @param pkce
     * @param engConf
     * @param successCallback
     * @param errorCallback
     */
    function setPKCEToSecureStorage(pkce, engConf, successCallback, errorCallback) {
        var appName = lpTag.unifiedWindow.apps.AUTHENTICATION;
        var customTtl = appContext && appContext.conf && appContext.conf.unifiedConf && appContext.conf.unifiedConf.pkceTtl;
        var ttl = parseInt(customTtl, 10) || pkceTtl;
        window.lpTag.taglets.lpSecureStorage.setValue({
            key: pkceDataName,
            site: lpTag && lpTag.site,
            app: appName,
            appName: appName,
            domain: _getSecureStoragePath(secureStorageDomain),
            success: function () {
                if (typeof successCallback === 'function'){
                    successCallback();
                }
            },
            error: function (error) {
                log.error("Error when setting PKCE code_verifier - " + error, name);
                if (typeof errorCallback === 'function'){
                    errorCallback();
                }
            },
            value: {engConfig: engConf, code_verifier: pkce.code_verifier},
            ttl: ttl,
            firstParty: true
        });
    }

    function removePKCEFromSecureStorage(successCallback, errorCallback) {
        var appName = lpTag.unifiedWindow.apps.AUTHENTICATION;
        window.lpTag.taglets.lpSecureStorage.removeValue({
            key: pkceDataName,
            site: lpTag && lpTag.site,
            app: appName,
            appName: appName,
            domain: _getSecureStoragePath(secureStorageDomain),
            success: function () {
                if (typeof successCallback === "function") {
                    successCallback();
                }
            },
            error: function () {
                if (typeof errorCallback === "function") {
                    errorCallback();
                }
            },
            firstParty: true
        });
    }

    function runPKCE(connector, finalCallback) {
        // Check if we have PKCE in secure storage
        getPKCEFromSecureStorage(function (value) {
            if (!value && appContext.conf.unifiedConf.external) {
                value = localStorage.getItem('cv');
            }
            if(value) {
                log.debug('Successfully retrieved PKCE value from secure storage');
                finalCallback();
            } else {
                generatePKCE(function (pkce) {
                    if (pkce) {
                        connector.code_challenge = pkce.code_challenge;
                        if (appContext.conf.unifiedConf.external) {
                            localStorage.setItem('cv', pkce.code_verifier);
                        }
                        setPKCEToSecureStorage(pkce, appContext.conf.engConf, function () {
                            finalCallback();
                        }, function () {
                            finalCallback();
                        });
                    } else {
                        finalCallback();
                    }
                });
            }
        }, function () {
            log.error('getPKCEFromSecureStorage: PKCE not available in secure storage', name);
            finalCallback();
        });
    }

    function _getIDPPublicKey(publicKeyReceiverCallback) {
        var idpDomain = lpTag && lpTag.csds && lpTag.csds.getDomain("idp");
        var requestUrl = "https://" + idpDomain + "/well-known/jwks";
        if (idpDomain) {
            lpTag.taglets.fetch.issueCall({
                url : requestUrl,
                method : "GET",
                success : function (response) {
                    var keysData = response && response.body;
                    var keys = keysData && keysData.keys || [];
                    if (keys.length) {
                        // returning the first key since as IDP team told the rest are rotations of the first one
                        publicKeyReceiverCallback(keys[0]);
                    }
                },
                error: function () {
                    log.error("PKCE: _getIDPPublicKey: Failed to get keys from IDP", name);
                    publicKeyReceiverCallback(null);
                }
            });
        } else {
            log.error("PKCE: _getIDPPublicKey: CSDS does not have IDP domain", name);
            publicKeyReceiverCallback(null);
        }
    }

    function generatePKCE(pkceReceiverCallback) {
        _getIDPPublicKey(function (key) {
            if (!key) {
                log.error("PKCE: generatePKCE: No key returned from IDP / Server error", name);
                pkceReceiverCallback(null);
                return;
            }
            var importJWKPromise = window.lpTag.pkce.importJWK(key, "RSA-OAEP");
            importJWKPromise.then(function (importedKey) {
                window.lpTag.pkce.getPkce(pkceCodeVerifierLength, function (error, data) {
                    if (error) {
                        log.error("PKCE: generatePKCE: PKCE creation failed " + (error && error.message), name);
                        pkceReceiverCallback(null);
                        return;
                    }

                    log.info("PKCE: generatePKCE: PKCE successfully generated", name);

                    var payload = JSON.stringify({code_verifier: data.verifier});
                    var uintPayload = (new TextEncoder()).encode(payload);

                    new lpTag.pkce.CompactEncrypt(uintPayload)
                        .setProtectedHeader({ alg: "RSA-OAEP", enc: "A256GCM", kid: key.kid })
                        .encrypt(importedKey)
                        .then(function (jwe) {
                            var PKCE = {
                                code_challenge: data.challenge,
                                code_verifier: jwe,
                                code_challenge_method: "S256"
                            };
                            log.info("PKCE: JWE created successfully " + JSON.stringify(PKCE), name);
                            if(pkceReceiverCallback) {
                                pkceReceiverCallback(PKCE);
                            }
                        }, function (err) {
                            var errString = "";
                            if (err) {
                                errString = JSON.stringify(err);
                            }
                            log.error("PKCE: JWE creation failed " + errString, name);
                            pkceReceiverCallback(null);
                        });
                });
            }, function (err) {
                var errString = "";
                if (err) {
                    errString = JSON.stringify(err);
                }
                log.error("PKCE: Key import failed " + errString, name);
                pkceReceiverCallback(null);
            });
        });
    }

    function getExternalWindowURLForPKCE(context) {
        if (appContext) {
            context = appContext;
        }
        var engConf = context.conf.engConf;
        var conf = context.conf.unifiedConf;
        var externalURL = context.appConfigurationManager.getExternalResourceURL(engConf, conf, false, true);
        var originalExternalURL = encodeURIComponent(externalURL);
        var query = context.appConfigurationManager.getQueryString(externalURL);
        var redirectUri = (new window.URLSearchParams(query)).get("redirect_uri");
        return redirectUri + "?originalURL=" + originalExternalURL;
    }

    function _getSecureStoragePath(domain) {
        var secureVersion = window.lpTag.taglets.lpSecureStorage.v;
        return 'https://' + domain + '/le_secure_storage/' + (secureVersion ? secureVersion : '');
    }

    return {
        init: init,
        setAppContext: setAppContext,
        getPKCEFromSecureStorage: getPKCEFromSecureStorage,
        setPKCEToSecureStorage: setPKCEToSecureStorage,
        removePKCEFromSecureStorage: removePKCEFromSecureStorage,
        runPKCE: runPKCE,
        generatePKCE: generatePKCE,
        getExternalWindowURLForPKCE: getExternalWindowURLForPKCE
    };
};

/****************************************************************/

window.lpTag = window.lpTag || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};

/**
 * This Class handle the cookies and sessionId.
 *
 * - init(conf) - Self executing initialization on instantiation.
 *
 *   conf = {
 *          sessionId, //optional
 *          accountId, //mandatory
 *          secureStorageLocation, //mandatory
 *          sessionRefreshTimeout //optional
 *         }
 *
 * - getSessionId - return the UID of the session.
 *
 * - getSessionTime - return the last timestamp on the session entry.
 *
 * - getSession: return the whole session entry.
 *
 * - dispose - dispose the existing session entry.
 *
 * - refresh - refresh the timestamp on the session entry.
 *
 * Dependencies:
 * @link lpTag.taglets.lpUtil,
 * @link lpTag.unifiedWindow.log
 */

lpTag.unifiedWindow.SessionManager = lpTag.unifiedWindow.SessionManager || function (conf) {

    var name = "SessionManager",
        appName = "SessionState",
        util = lpTag.taglets.lpUtil,
        log = lpTag.unifiedWindow.log,
        secureStorage = lpTag.taglets.lpSecureStorage,
        sessions,
        sessionsPriority,
        // get parent domain to support cross sub-domain navigation
        sessionRefreshTimeoutId,
        sessionRefreshTimeout,
        DEFAULT_SESSION_REFRESH_TIMEOUT = 5000,
        disposed = false,
        events,
        accountId,
        sessionId,
        external,
        secureStorageLocation,
        clickedSession,
        currentSession,
        sessionTimeout,
        echoedSessionTimeout, // session timeout in seconds
        APP = lpTag.unifiedWindow.apps.UNIFIED_WINDOW,
        STORAGE_SELECTED_EVENT = "STORAGE_SELECTED";

    // execution
    init(conf);
    _bindToEvents();


    // public functions
    function init(conf) {
        if (typeof conf === "object" && conf.accountId && conf.secureStorageLocation && typeof conf.accountId === "string") {
            accountId = conf.accountId;
            sessionId = conf.sessionId;
            events = conf.events;
            external = conf.external;
            secureStorageLocation = conf.secureStorageLocation;
            sessionRefreshTimeout = conf.sessionRefreshTimeout || DEFAULT_SESSION_REFRESH_TIMEOUT;
            echoedSessionTimeout = conf.echoedSessionTimeout;
            sessions = conf.sessions;
            sessionsPriority = conf.sessionsPriority;
            setClickedSession(conf.clickedSession);
        } else {
            //<excludeFromBuild>
            log.error("init: no conf was provided", name);
            //</excludeFromBuild>
        }
    }

    /**
     * The function sends the getValues passing the sessionsPriority array with the channels. If Secure Storage returns
     * data, it calls _getSessionData to choose the channel (session name), then _setSession to renew the data and on
     * success runs the initially provided cb and optCb and returns the chosen sessionId.
     * @param cb
     * @param optCb
     */
    function getSessionId(cb, optCb) {
        //<excludeFromBuild>
        log.info("getSessionId - Current session: " + (currentSession ? currentSession.sessionKey : "no session"), name);
        //</excludeFromBuild>
        secureStorage.getValues({
                keys: sessionsPriority,
                site: accountId,
                app: APP,
                success: _onGetSessionsSuccess.bind(this, cb, optCb),
                error: function _onError(data) {
                    //<excludeFromBuild>
                    log.error("getSessionId - ERROR: " + data, name);
                    //</excludeFromBuild>

                    events.trigger({
                        appName: lpTag.taglets.lpUnifiedWindow.name,
                        eventName: STORAGE_SELECTED_EVENT,
                        global: true
                    });
                },
                appName: appName,
                domain: secureStorageLocation,
                firstParty: true
            }
        );
    }

    function getSessionTime(cb) {
        var timestamp;
        var sessionLS = _getLSSession(accountId + currentSession.sessionKey);
        secureStorage.getValue({
                key: currentSession.sessionKey,
                site: accountId,
                app: APP,
                success: function _onSuccess(session) {
                    if (session) {
                        timestamp = session.timestamp;
                    } else {
                        if (sessionLS) {
                            timestamp = sessionLS.timestamp;
                        }
                    }
                    util.runCallback(cb, null, timestamp);
                },
                error: function _onError(data) {
                    //<excludeFromBuild>
                    log.error("getSessionTime - ERROR: " + data, name);
                    //</excludeFromBuild>
                },
                appName: appName,
                domain: secureStorageLocation,
                firstParty: true
            }
        );
    }

    /**
     * this function returns sessionTimeout and in case of external checks whether defined in location hash
     * @returns {*}
     */
    function getSessionTimeout() {
        return sessionTimeout;
    }

    function getSession(cb) {
        var sessionLS = _getLSSession(accountId + currentSession.sessionKey);
        secureStorage.getValue({
                key: currentSession.sessionKey,
                app: APP,
                site: accountId,
                success: function _onSuccess(session) {
                    if (session || sessionLS) {
                        util.runCallback(cb, null, session || sessionLS);
                    }
                },
                error: function _onError(data) {
                    //<excludeFromBuild>
                    log.error("getSession - ERROR: " + data, name);
                    //</excludeFromBuild>
                },
                appName: appName,
                domain: secureStorageLocation,
                firstParty: true
            }
        );
    }

    function refresh(cb) {
        if (!external) {
            disposed = false;
            getSessionId(_refreshSession, cb);
        }
        else {
            util.runCallback(cb);
        }
    }

    function dispose(keepSession) {
        clearTimeout(sessionRefreshTimeoutId); // make sure cookie is not rewritten following its removal
        _unbindEvents();
        sessionId = null;
        disposed = true;
        if (keepSession !== true && !external) {
            if (_isSafariIOS()) {
                window.localStorage.removeItem(accountId + currentSession.sessionKey);
            }
            secureStorage.removeValue({
                    key: currentSession.sessionKey,
                    site: accountId,
                    app: APP,
                    appName: appName,
                    success: _emptyCb,
                    error: _emptyCb,
                    domain: secureStorageLocation,
                    firstParty: true
                }
            );
        }
    }

    /**
     * Gets the currently selected session key
     * @returns {*} The current session
     */
    function getCurrentSessionKey() {
        return currentSession.sessionKey;
    }

    /**
     * Sets the clicked session and resets the current session accordingly.
     * @param session - The clicked session. Can be null/undefined.
     */
    function setClickedSession(session) {
        clickedSession = sessions[session];
        currentSession = clickedSession && sessions[clickedSession.sessionKey];
    }

    // private functions

    /**
     * The function is the success callback for getSessionId. If there's data for any of the channels in Secure Storage,
     * it will be passed to here as data. According to this data the function calls _getSessionData to choose between the
     * channels, sets the currentSession variable to it, calls _setSession to renew the data in Secure Storage. If there
     * is no data in Secure Storage for any of the channels, just runs the provided callbacks.
     * @param cb
     * @param optCb
     * @param data
     * @private
     */
    function _onGetSessionsSuccess(cb, optCb, data) {
        var currentTime,
            sessionData;

        sessionData = _getSessionData(data);

        if (sessionData.session) {
            currentSession = sessions[sessionData.sessionKey];
            currentTime = sessionData.session.timestamp || "null";
            sessionId = sessionId ? sessionId : sessionData.session.sid;
        }
        if (sessionData.session || _isClickedSession()) {
            // we're staying with the current session
            _setSession(sessionData.session, currentTime, cb, optCb);
        } else {
            // call _initByStorage and deliver storage type to the taglet when there's no session yet
            util.runCallback(cb, null);
            util.runCallback(optCb);
        }
    }

    /**
     * The function chooses a session according to priorities
     * @param data
     * @returns {{session: *, sessionKey: *}}
     * @private
     */
    function _getSessionData(data) {
        var session,
            sessionKey,
            sessionLS;

        if (data && typeof data === 'object') {
            for (var i = 0; i < sessionsPriority.length; i++) {
                sessionKey = sessionsPriority[i];
                sessionLS = _getLSSession(accountId + sessionKey);
                if (data[sessionKey] || sessionLS) {
                    session = data[sessionKey] || sessionLS;
                    break;
                }
            }
        } else {
            // the case of no data
            session = data;
        }

        return {
            session: session,
            sessionKey: sessionKey
        };
    }

    /**
     * Checks if the session was requested directly (clicked)
     * @returns {boolean} True if the session was requested directly (clicked)
     */
    function _isClickedSession() {
        return !!clickedSession;
    }

    function _getCurrentSessionTimeout(session) {
        return echoedSessionTimeout || session && session.sessionTimeout && parseInt(session.sessionTimeout, 10) || currentSession.sessionTimeout;
    }

    function _setSession(session, currentTime, cb, optCb) {
        if (!sessionTimeout) {
            sessionTimeout = _getCurrentSessionTimeout(session);
        }

        if (!sessionId || sessionId === "null") {
            sessionId = util.getUID();
        }
        if (!external) {
            var dataToSet = {sid: sessionId, timestamp: currentTime || "null", sessionTimeout: sessionTimeout || "null"};
            if (_isSafariIOS()) {
                window.localStorage.setItem(accountId + currentSession.sessionKey, JSON.stringify(dataToSet));
            } 
            secureStorage.setValue({
                key: currentSession.sessionKey,
                site: accountId,
                app: APP,
                value: dataToSet,
                ttl: currentSession.sessionTimeout * 1000,
                success: function _onSucess() {
                    util.runCallback(cb, null, sessionId);
                    util.runCallback(optCb);
                },
                error: function _onError(data){
                    //<excludeFromBuild>
                    log.error("_setSession - setValue - ERROR: " + data, name);
                    //</excludeFromBuild>
                },
                appName: appName,
                domain: secureStorageLocation,
                firstParty: true
            });
        } else {
            util.runCallback(cb, null, sessionId);
        }
    }

    function _bindToEvents() {
        events.bind({
            appName: "ChatStateManager",
            eventName: "startChatInfo",
            func: _updateChatTimeout
        });
    }

    function _unbindEvents() {
        events.unbind({
            appName: "ChatStateManager",
            eventName: "startChatInfo",
            func: _updateChatTimeout
        });
    }

    function _updateChatTimeout(data) {
        if (data.chatTimeout) {
            //<excludeFromBuild>
            log.info("_updateChatTimeout : echoed chatTimeout = " + data.chatTimeout, name);
            //</excludeFromBuild>
            sessionTimeout = data.chatTimeout;
        }
    }

    //// TODO: Implementation using "touchValue" instead of "_setSession". Once "touchValue" works, we should use it.
    function _refreshSession() {
       //<excludeFromBuild>
       log.info("_refreshSession : disposed = " + disposed, name);
       //</excludeFromBuild>
       if (sessionRefreshTimeoutId) {
           clearTimeout(sessionRefreshTimeoutId);
       }

       if (!disposed && !external) {
           var now = (new Date()).getTime();
           //<excludeFromBuild>
           log.info("Refresh Session: timestamp = " + now, name);
           //</excludeFromBuild>
           secureStorage.touchValue({
               key: currentSession.sessionKey,
               site: accountId,
               ttl: currentSession.sessionTimeout * 1000,
               success: function _onSucess() {
                   sessionRefreshTimeoutId = setTimeout(_refreshSession, sessionRefreshTimeout);
               },
               error: function _onError(data) {
                   //<excludeFromBuild>
                   log.error("_refreshSession - touchValue - ERROR: " + data, name);
                   //</excludeFromBuild>
                   disposed = true;
               },
               app: APP,
               appName: appName,
               domain: secureStorageLocation,
               firstParty: true
           });
       }

    }

    function _emptyCb() {}

    /**
     * Detect if running on iOS Safari
     */
    function _isSafariIOS() {
        var device = window.lpTag.device;
        var os = device && device.os && device.os();
        var browser = device && device.browser && device.browser();
        return os === 3 && browser === 2;
    }

    /**
     * Gets a session from local storage for Safari on iOS only
     * @param key - key in local storage to get data from
     * @returns {string|any}
     * @private
     */
    function _getLSSession (key) {
        var sessionLS;
        if (_isSafariIOS()) {
            try {
                sessionLS = window.localStorage.getItem(key);
                sessionLS = sessionLS && JSON.parse(sessionLS);
            }
            catch (e) {
                log.error("Error parsing session from local storage", name);
            }
        }
        return sessionLS;
    }

    return {
        dispose: dispose,
        refresh: refresh,
        getCurrentSessionKey: getCurrentSessionKey,
        setClickedSession: setClickedSession,
        getSessionId: getSessionId,
        getSessionTime: getSessionTime,
        getSession: getSession,
        getSessionTimeout : getSessionTimeout
    };

};


/****************************************************************/

window.lpTag = window.lpTag || {};
window.lpTag.unifiedWindow = window.lpTag.unifiedWindow || {};

lpTag.unifiedWindow.settingsIDs = lpTag.unifiedWindow.settingsIDs || {
  FILE_SHARING_ENALBED : "messaging.file.sharing.enabled",
  BLUR_THUMBNAILS : "messaging.file.sharing.blurThumbnails",
  FILE_SHARING_IMAGE_RESIZE_SIZE: "messaging.agent.photo.size",
  BLOCK_CONSUMER : "unauth.messaging.block.consumer.history",
  EXTERNAL_FALLBACK : "unified.window.fallback.to.external",
  COBROWSE_CONTROLLER_BOT_PREFERRED_FOR_SYSTEM_MESSAGES: "le.site.cobrowse.controllerBotPreferredForSystemMessages",
  HISTORY_LAZYLOAD: "le.campaign.window.history.lazyload",
  UMS_CONNECTION_TIMEOUT: "le.window.ums.connection.timeout.enabled",
  OTK_RETRIES: "le.site.otk.number.of.uses",
  OTK_DURATION: "le.site.otk.duration",
  CONTACT_INFO: "le.site.account.contactInfo"
};


/****************************************************************/

window.lpTag = window.lpTag || {};
lpTag.taglets = lpTag.taglets || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};

/**
 * This Class understands the application state and calls a callback with the current state.
 *
 * -init(conf) - Self executing initialization on instantiation.
 *      conf = {
 *          storageKey, //mandatory
 *          accountId, //mandatory
 *          sessionManager, //mandatory
 *          secureStorageLocation, //mandatory
 *          disableSessionTimeout, //optional
 *          sessionTimeout //optional
 *      }
 *
 * - getState(onSuccess, onError) - analyzes the state and calls the callback functions
 *      callback = function (data, state);
 *
 * - state - exposes the state enumeration:{
 *           NOT_STARTED: 0,
 *           IN_SESSION: 1,
 *           INVALID: 2,
 *           EXPIRED: 3
 *       }
 *
 * Dependencies:
 * @link lpTag.taglets.lpSecureStorage,
 * @link lpTag.unifiedWindow.log,
 * @link lpTag.taglets.lpUtil,
 * @link lpTag.unifiedWindow.SessionManager
 */
lpTag.unifiedWindow.StateAnalyzer = lpTag.unifiedWindow.StateAnalyzer || function (conf, sessionMngr) {

    var name = "StateAnalyzer",
        appName = "UIState",
        log = lpTag.unifiedWindow.log,
        util = lpTag.taglets.lpUtil,
        secureStorage = lpTag.taglets.lpSecureStorage,
        sessionManager,
        storageKey,
        accountId,
        secureStorageLocation,
        disableSessionTimeout,
        state = {
            NOT_STARTED: 0,
            IN_SESSION: 1,
            INVALID: 2,
            EXPIRED: 3
        },
        APP = lpTag.unifiedWindow.apps.UNIFIED_WINDOW;

    function init(conf) {
        if (typeof conf === "object" && sessionMngr && conf.storageKey && conf.accountId && conf.secureStorageLocation) {
            sessionManager = sessionMngr;
            storageKey = conf.storageKey;
            accountId = conf.accountId;
            disableSessionTimeout = !!conf.disableSessionTimeout || false;
            secureStorageLocation = conf.secureStorageLocation;
        } else {
            //<excludeFromBuild>
            log.error("init: no conf was provided", name);
            //</excludeFromBuild>
        }
    }

    init(conf);

    function getState(onSuccess, onError) {
        //<excludeFromBuild>
        log.info("getState", name);
        //</excludeFromBuild>
        secureStorage.getValue({
                key: storageKey,
                site: accountId,
                app: APP,
                success: _createSuccess(onSuccess),
                error: _createError(onError),
                appName: appName,
                domain: secureStorageLocation,
                firstParty: true
            }
        );
    }

    /**
     * This function gets session time from Session Manager and returns its state:
     * if no timestamp has been defined in the cookie (for example: in popped out window) - return NOT_STARTED
     * If timeout hasn't expired yet - return IN_SESSION
     * If timeout has expired - return EXPIRED
    */
    function _getSessionState(cb) {
        var now = new Date().getTime(),
            sessionTimeout = sessionManager.getSessionTimeout() * 1000, // for calculation purposes we need the value in milliseconds
            sessionState = null;

        sessionManager.getSessionTime(_handleSessionState.bind(this, cb, now, sessionTimeout, sessionState));
    }

    function _handleSessionState(cb, now, sessionTimeout, sessionState, sessionTime){
        if (typeof sessionTime === "undefined" || sessionTime === "null") {
            sessionState = state.NOT_STARTED;
        } else if (disableSessionTimeout || (now - sessionTime) <= sessionTimeout) {
            sessionState = state.IN_SESSION;
        } else {
            sessionState = state.EXPIRED;
        }

        //<excludeFromBuild>
        log.info("_getSessionState: now=" + now + " sessionTime=" + sessionTime + " sessionTimeout=" + sessionTimeout + " sessionState=" + sessionState, name);
        //</excludeFromBuild>
        cb(sessionState);
    }

    /**
     * This function gets data from Secure Storage and returns a callback function by Analyzer's new state:
     * if there's data but the session has expired - return EXPIRED
     * if there's data and the session hasn't expired yet - return IN_SESSION
     * If there's no data but there's still an active session - return INVALID
     * Otherwise - return NOT_STARTED
     */
    function _createSuccess(callback) {
        return function _success(data) {
            //<excludeFromBuild>
            log.info("_success: data = " + JSON.stringify(data), name);
            //</excludeFromBuild>
            _getSessionState(_handleState.bind(this, callback, data, state.NOT_STARTED));
        };
    }

    function _handleState(callback, data, analyzerState, sessionState) {
        if (data && sessionState === state.EXPIRED) {
            analyzerState = state.EXPIRED;
        } else if (data && _isNotEmpty(data)) {
            analyzerState = state.IN_SESSION;
        } else if (sessionState === state.IN_SESSION) {
            analyzerState = state.INVALID;
        }

        //<excludeFromBuild>
        log.info("_success: data = " + JSON.stringify(data) + " analyzerState=" + analyzerState, name);
        //</excludeFromBuild>
        util.runCallback(callback, null, data, analyzerState);
    }

    function _isNotEmpty(obj) {
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                return true;
            }
        }
        return false;
    }

    function _createError(callback) {
        return function _error(data) {
            //<excludeFromBuild>
            log.info("_error: data = " + JSON.stringify(data), name);
            //</excludeFromBuild>
            util.runCallback(callback, null, data, state.NOT_STARTED);
        };
    }

    return {
        getState: getState,
        state: util.clone(state)
    };

};


/****************************************************************/

window.lpTag = window.lpTag || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};

/**
 * This Class handle the window configuration management.
 *
 *  - init(conf) - will be called on instantiation.
 *      conf = {
 *           storageKey, //mandatory
 *           accountId, //mandatory
 *           secureStorageLocation, //mandatory
 *           domain, //mandatory
 *           windowId //optional
 *      }
 *
 *  - getConf (callback)
 *      callback = function(conf);
 *
 * Dependencies:
 * @link lpTag.taglets.lpUtil,
 * @link lpTag.unifiedWindow.log,
 * @link lpTag,taglets.lpSecureStorage,
 * @link lpTag.taglets.jsonp
 * @link lpTag.taglets.fetch
 */

lpTag.unifiedWindow.WindowConfigurationManager = lpTag.unifiedWindow.WindowConfigurationManager || function (conf) {

    var name = "WindowConfigurationManager",
        appName = "UIConf",
        log = lpTag.unifiedWindow.log,
        util = lpTag.taglets.lpUtil,
        secureStorage = lpTag.taglets.lpSecureStorage,
        accountId,
        secureStorageLocation,
        domain,
        key,
        windowId,
        currentConf,
        initialConf,
        isFetchEnabled,
        fetchCacheMode,
        APP = lpTag.unifiedWindow.apps.UNIFIED_WINDOW;

    function init(conf) {
        if (typeof conf === "object" && conf.storageKey && conf.accountId && conf.secureStorageLocation && conf.domain) {
            accountId = conf.accountId;
            secureStorageLocation = conf.secureStorageLocation;
            domain = conf.domain;
            windowId = conf.windowId;
            key = conf.storageKey + appName;
            initialConf = conf.initialConf || {};
            var currentEnv = (typeof lpTag.getEnv === "function" && lpTag.getEnv());
            isFetchEnabled = ((initialConf.isFetchEnabled !== undefined) ? JSON.parse(initialConf.isFetchEnabled) : currentEnv === 'alpha');
            fetchCacheMode = initialConf.fetchCacheMode;
        } else {
            //<excludeFromBuild>
            log.error("init: no configuration given", name);
            //</excludeFromBuild>
        }
    }

    init(conf);

    function getConf(callback) {
        //<excludeFromBuild>
        log.info("getConf", name);
        //</excludeFromBuild>

        if (currentConf) {
            util.runCallback(callback, null, currentConf);
            return;
        }

        secureStorage.getValue({
                key: key,
                site: accountId,
                app: APP,
                success: _createCallback(callback),
                error: _createCallback(callback),
                appName: appName,
                domain: secureStorageLocation,
                firstParty: true
            }
        );
    }

    function clear() {
        secureStorage.removeValue({
                key: key,
                site: accountId,
                app: APP,
                appName: appName,
                success: _emptyCb,
                error: _emptyCb,
                domain: secureStorageLocation,
                firstParty: true
            }
        );
    }

    function _setConf(conf) {
        //<excludeFromBuild>
        log.info("_setConf", name);
        //</excludeFromBuild>
        secureStorage.setValue({
                key: key,
                site: accountId,
                app: APP,
                value: {conf: conf, windowId: windowId},
                success: _setCallback,
                error: _setCallback,
                appName: appName,
                domain: secureStorageLocation,
                expires: 60 * 1000 * 180, //3 hour
                firstParty: true
            }
        );
    }

    function _setCallback(data) {
        //<excludeFromBuild>
        log.info("_setCallback: data=" + JSON.stringify(data), name);
        //</excludeFromBuild>
    }

    function _createCallback(callback) {
        return function _confCallback(conf) {
            if (callback) {
                if (conf) {
                    currentConf = conf.conf;
                    windowId = conf.windowId;
                    util.runCallback(callback, null, currentConf);
                } else { //No conf in storage - Go fetch
                    _getConfiguration(callback);
                }
            }
        };

    }

    function _getConfiguration(callback) {
        var ACCDNConfig;
        //<excludeFromBuild>
        log.info("_getConfiguration", name);
        //</excludeFromBuild>
        var isRequestDefaultEnabled = initialConf.enableToRequestDefaultWinConfig;
        var targetIdPart = '/' + windowId;
        var transport = isFetchEnabled ? lpTag.taglets.fetch : lpTag.taglets.jsonp;
        if (!windowId && isRequestDefaultEnabled) {
            targetIdPart = "-default";
        }
        if (!windowId && !isRequestDefaultEnabled) {
            //<excludeFromBuild>
            log.error("_getConfiguration: No windowId provided, fallback to default configuration", name);
            //</excludeFromBuild>
            util.runCallback(callback, null, {});
            return;
        }
        ACCDNConfig = "https://" + domain + "/api/account/" + accountId + "/configuration/engagement-window/window-confs" + targetIdPart;
        transport.issueCall({
            url: ACCDNConfig,
            timeout: 5000,
            retries: 0,
            credentials: isFetchEnabled ? 'omit' : undefined,
            cache: (isFetchEnabled && fetchCacheMode) ? fetchCacheMode : undefined,
            success: function (response) {
                var data = isFetchEnabled ? (response && response.body) : response;
                var defaultConfFiltered;
                if (!windowId && isRequestDefaultEnabled) {
                    if (data && data.length) {
                        defaultConfFiltered = data.filter(function (el) {return !!el.isUserDefault;});
                        if (defaultConfFiltered.length > 0) {
                            data = defaultConfFiltered[0];
                        }
                        else {
                            data = data[0];
                        }
                    }
                    else {
                        windowConfError(callback);
                        return;
                    }
                }
                if (data && data.json && !data.error) {
                    //<excludeFromBuild>
                    log.info("_getConfiguration - got configuration: " + JSON.stringify(data.json), name);
                    //</excludeFromBuild>
                    currentConf = data.json;
                    util.runCallback(callback, null, currentConf);
                    _setConf(currentConf);
                } else {
                    windowConfError(callback);
                }
            },
            error: function () {
                windowConfError(callback);
            }
        });
    }
    function windowConfError(callback) {
        //<excludeFromBuild>
        log.info("_getConfiguration - ERROR FROM SERVER", name);
        //</excludeFromBuild>
        util.runCallback(callback);
    }
    function _emptyCb() {}

    return {
        getConf: getConf,
        clear: clear
    };
};


/****************************************************************/

window.lpTag = window.lpTag || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};

/**
 * This module is responsible for the creation of the chat wrapper window
 * Dependencies: @link lpTag.taglets.lpUtil, @link lpTag.unifiedWindow.log,  @link lpTag.unifiedWindow.wrapperWindowConfiguration
 */

lpTag.unifiedWindow.WrapperWindow = lpTag.unifiedWindow.WrapperWindow || function (_config, _deviceDetector, _browserStateManager, events, _disposeCallback) {

    /**** variables ****/

    var name = 'WrapperWindow',
        unifiedWindow = lpTag.unifiedWindow,
        configuration = {

            STYLE_TAG_ID: 'lpChatStyle',
            EMBEDDED_STYLE_TAG_ID: 'lpStyle',

            WRAPPER_DIV_ID: 'lpChat',
            WRAPPER_CLASS_NAME: 'lp-window-root',

            WRAPPER_DIV_CSS_CLASS_PREFIX: 'lp_',

            MOBILE_CSS_CLASS: 'mobile',
            TABLET_CSS_CLASS: 'tablet',
            DESKTOP_CSS_CLASS: 'desktop',
            DEVICE_CLASS : "lpdv",
            ANDROID_CSS_CLASS: 'android',
            IOS_CSS_CLASS: 'ios',
            IOS6_CSS_CLASS: 'ios6',
            IOS8_OR_ABOVE_CSS_CLASS: 'ios8_or_above',
            MAC_OSX_CSS_CLASS: 'mac_osx',

            NATIVE_CSS_CLASS: 'native_android',

            EXTERNAL_CSS_CLASS: 'lp_external-window',
            HIDE_TOP_BAR_CSS_CLASS: 'lp_no-top',
            WEBVIEW_CSS_CLASS: 'lp_webview-window',

            PORTRAIT_CSS_CLASS: 'portrait',
            LANDSCAPE_CSS_CLASS: 'landscape',

            MINIMIZED_VIEW_IFRAME_RENDERING: false,
            MAXIMIZED_VIEW_IFRAME_RENDERING: false,

            MINIMUM_INNER_WIDTH: 372, // For browsers that mess up the inner/outer width for small sizes (Edge)
            WAIT_INDICATION_DELAY: 250,

            LARGE: 'lp_maximized_large',
            FLOATING: 'lp_floating',
            MINIMIZED_LARGE: 'lp_minimized_large'

        },
        deviceDetector,
        browserStateManager,
        language = unifiedWindow.language,
        inError,
        lastMessageType,
        util = lpTag.taglets.lpUtil,
        log = unifiedWindow.log,
        SystemMessages,
        currentMessage,
        currentTitle,
        Messages,
        wrapperDomEl,
        deviceDetectorWrapperDomEl,
        style,
        minimizedWrapperDomEl,
        maximizedWrapperDomEl,
        bufferStripDomEl,
        minimizedDocument,
        minimizedBody,
        maximizedDocument,
        maximizedBody,
        closeButton,
        sliderButton,
        widgetNotificationContainer,
        widgetNotificationText,
        titleDiv,
        chattingWithIcon,
        minimizedButton,
        topMenuButton,
        popButton,
        waitIndicationTimer,
        isRendered = false,
        disposed = false,
        disposeCallback,
        config = {
            isMaximized: true
        };

    /**** execution ****/

    _init(_config, _deviceDetector, _browserStateManager, _disposeCallback);
    _bindToEvents();
    
    function _setWindowPosition(position) {
        var rightPosition;
        if (position && deviceDetector.isDesktop()) {
            if (position.right >= 0) {
                rightPosition = position.right > document.body.clientWidth ? document.body.clientWidth - 280 : position.right;
                minimizedWrapperDomEl.style.right = rightPosition + "px";
                maximizedWrapperDomEl.style.right = rightPosition + "px";
            }
        }
        //<excludeFromBuild>
        log.debug("_setWindowPosition: offset=" + position.right, name);
        //</excludeFromBuild>
    }

    function _setWindowSize(size) {
        //<excludeFromBuild>
        log.info("_setWindowSize");
        //</excludeFromBuild>
        size = size ? size.toUpperCase() : 'SMALL';
        if(configuration[size]) {
          maximizedWrapperDomEl.classList.add(configuration[size]);
          if(size == 'LARGE'){
            minimizedWrapperDomEl.classList.add(configuration.MINIMIZED_LARGE);
          }
        }
    }

    function _setFloatingState(floating) {
        if(!!floating) {
            maximizedWrapperDomEl.classList.add(configuration.FLOATING);
        }
    }

    function _setUIState(uiState) {
        if (uiState) {
            if (!_isExternalWindow()) { // no need to adjust position in external windows
                _setFloatingState(uiState.floating);
                _setWindowPosition(uiState.position);
                _setWindowSize(uiState.size);
            }
            setMaximizedState(uiState.maximized);
            _setEmbeddedState(uiState.embedded, config.external, config.poppedOut);
        } else {
            setMaximizedState(config.isMaximized);
        }
    }

    /**** public functions ****/

    /**
     * toggles minimized/maximized views
     * @param maximize
     */
    function setMaximizedState(maximize) {
        if (maximize) {
            //<excludeFromBuild>
            log.debug('maximizing', name);
            //</excludeFromBuild>
            minimizedWrapperDomEl.style.display = 'none';
            maximizedWrapperDomEl.style.display = 'block';
        } else {
            //<excludeFromBuild>
            log.debug('minimizing', name);
            //</excludeFromBuild>
            minimizedWrapperDomEl.style.display = 'block';
            maximizedWrapperDomEl.style.display = 'none';
        }
    }

    function _setEmbeddedState(embedded, external, poppedOut) {
        if (!embedded && !external && !poppedOut) {
            minimizedWrapperDomEl.style.display = 'none';
            maximizedWrapperDomEl.style.display = 'none';
        }
    }

    /**
     * Show a system message on window
     * @param type
     */
    function setMessage(type, maximize) {
        _clearTimeouts();

        if (maximize) {
            _maximize();
        }


        var messageData = SystemMessages[type];

        if (messageData && messageData !== currentMessage) {
            if (type !== Messages.CONFIRMATION) {
              lastMessageType = type;
            }
            inError = messageData.error;
            var shouldShowClose = inError && !config.connectorsSfConfig;
            showClose(shouldShowClose);
            if (deviceDetector.isDesktop()) {
                closeButton.focus();
            }

            if (messageData.title) {
                setTitle(messageData.title);
            } else if (messageData.text) {
                setTitle(messageData.text);
            }

            _message(messageData, type);
            currentMessage = messageData;
        }
    }

    /**
     * Changes the title of the window
     * @param titleText
     */
    function setTitle(titleText, titleTextEllispsis) {
        if (currentTitle !== titleText) {
            //<excludeFromBuild>
            log.info('setting title to: "' + titleText + '"', name);
            //</excludeFromBuild>
            var titles = wrapperDomEl.querySelectorAll('[data-lp-point="headerText"]');
            
            titleTextEllispsis = titleTextEllispsis || titleText;
            for (var i = 0; i < titles.length; i++) {
                titles[i].innerHTML = lpTag.HtmlSanitizerUtils ? lpTag.HtmlSanitizerUtils.sanitizeHtml(titleTextEllispsis).cleanText : titleTextEllispsis;
            }
            currentTitle = titleText;
        }
    }

    function show() {
        if (_isRendered()) {
            //<excludeFromBuild>
            log.info('showing', name);
            //</excludeFromBuild>
            wrapperDomEl.style.display = 'block';
        }
    }

    function hide() {
        if (_isRendered()) {
            //<excludeFromBuild>
            log.info('hiding', name);
            //</excludeFromBuild>
            wrapperDomEl.style.display = 'none';
        }
    }

    function render(uiState, callback) {
        disposed = false;
        if (!_isRendered()) {
            util.waitForBody(function () {
                _render(uiState);
                _bindDomEvents();
                util.runCallback(callback);
            });
        } else {
            util.runCallback(callback);
        }
    }

    function getMainWindowElement() {
        return wrapperDomEl;
    }

    function getMinimizedElement() {
        return minimizedWrapperDomEl;
    }

    function getBufferStripElement() {
        return bufferStripDomEl;
    }

    function getMaximizedElement() {
        return maximizedWrapperDomEl;
    }

    function getChatWrapperElement() {
        return deviceDetectorWrapperDomEl;
    }

    function getSliderButton() {
        return sliderButton;
    }

    function getWidgetNotificationContainer() {
        return widgetNotificationContainer;
    }

    function getWidgetNotificationText() {
        return widgetNotificationText;
    }

    function getTitleDiv() {
        return titleDiv;
    }

    function getChattingWIthIcon() {
        return chattingWithIcon;
    }

    function showClose(show) {
        if (show) {
            util.removeClass(closeButton, 'lp_hidden');
        } else {
            util.addClass(closeButton, 'lp_hidden');
        }
    }

    function showMinimized(show) {
        if (show) {
            util.removeClass(minimizedButton, 'lp_hidden');
        } else {
            util.addClass(minimizedButton, 'lp_hidden');
        }
    }

    function showTopMenu(show) {
        util[show ? "removeClass" : "addClass"](topMenuButton, 'lp_hidden');
    }

    function adjustConfigStyle(themer){
        //<excludeFromBuild>
        log.info('applyConfigStyle', name);
        //</excludeFromBuild>
        if(themer){
            _adjustBorderRadius(themer);
            if((deviceDetector.isMobile() || deviceDetector.isTablet()) && !_isExternalWindow()){
                _adjustMobileOpacity(themer);
            }
        }
    }

    /**
     * removes the wrapper window from the DOM
     */
    function dispose() {
        if (!disposed) {
            //<excludeFromBuild>
            log.info('disposing', name);
            //</excludeFromBuild>
            _unbindEvents();

            currentMessage = null;
            currentTitle = null;
            _setRenderState(false);

            if (deviceDetectorWrapperDomEl.remove) {
                deviceDetectorWrapperDomEl.remove();
            } else {
                document.body.removeChild(deviceDetectorWrapperDomEl);
            }

            disposed = true;

            util.runCallback(disposeCallback);
        }
    }

    function getWrapperElementId() {
        return configuration.WRAPPER_DIV_ID;
    }

    function _setRenderState(rendered) {
        isRendered = rendered;
    }

    function _isRendered() {
        return isRendered === true;
    }

    function _minimize() {
        //<excludeFromBuild>
        log.info('_minimize', name);
        //</excludeFromBuild>
        if (!inError) {
            setMaximizedState(false);
        }
    }

    function _maximize() {
        //<excludeFromBuild>
        log.info('_maximize', name);
        //</excludeFromBuild>
        setMaximizedState(true);
    }

    /**** private functions ****/

    function _unbindEvents() {
        //<excludeFromBuild>
        log.info('unbinding dom events', name);
        //</excludeFromBuild>
        unbindDomEvents();
        browserStateManager.off(browserStateManager.EVENT_NAME.ORIENTATION_CHANGE, _setOrientationClass);
    }

    function unbindDomEvents() {
      var confirmButton = maximizedWrapperDomEl.querySelector(['[data-lp-point="confirm_button"]']);
      var cancelButton = maximizedWrapperDomEl.querySelector(['[data-lp-point="cancel_button"]']);

      util.unregisterEvent(minimizedWrapperDomEl, 'click', _maximize);
      util.unregisterEvent(closeButton, 'click', dispose);

      if (cancelButton) {
        util.unregisterEvent(cancelButton, 'click', _handleCancel);
      }
      if (confirmButton) {
        util.unregisterEvent(confirmButton, 'click', dispose);
      }
    }

    function _bindDomEvents() {
        util.registerEvent(closeButton, 'click', dispose);
    }

    function removeMessage(keepTitle) {
        _clearTimeouts();
        //<excludeFromBuild>
        log.info('removing current message', name);
        //</excludeFromBuild>
        var messageDomEl = maximizedBody.querySelector('[data-lp-point="message"]');
        if (messageDomEl) {
            if (messageDomEl.remove) {
                messageDomEl.remove();
            } else {
                maximizedBody.removeChild(messageDomEl);
            }
            if (!keepTitle) {
                setTitle('');
            }
            _removeCentralizeContent();
        }
    }

    function getIconRepository() {
        return config.iconsRepository;
    }

    function _message(messageData, type) {
        var sanitizeHTML = lpTag.HtmlSanitizerUtils && lpTag.HtmlSanitizerUtils.sanitizeHtml;
        var text = sanitizeHTML ? sanitizeHTML(messageData.text).cleanText : _escapeHTML(messageData.text);
        var imageUrl = sanitizeHTML ? sanitizeHTML(messageData.imgUrl).cleanText : _escapeHTML(messageData.imgUrl);
        var imageAltText = sanitizeHTML ? sanitizeHTML(messageData.imgAltText).cleanText : _escapeHTML(messageData.imgAltText);
        show();
        removeMessage();
        //<excludeFromBuild>
        log.info('setting message to: ' + type, name);
        //</excludeFromBuild>

        var messageHTML;
        if (type === Messages.WAIT) {
            messageHTML = '<div class="lp_message" data-lp-point="message"><div class="lp_skeleton-window-body"><div class="lp_skeleton-header"><div class="lp_skeleton-box"></div></div><div class="lp_skeleton-message lp_skeleton-agent"><div class="lp_skeleton-box"></div></div><div class="lp_skeleton-message lp_skeleton-visitor"><div class="lp_skeleton-box"></div></div><div class="lp_skeleton-input"><div class="lp_skeleton-box"></div></div></div></div>';
        } else {
            messageHTML = '<div class="lp_message" data-lp-point="message" aria-labelledby="lp_alert_message"><table class="lp_centralizer"><tbody><tr><td><img src="{{imagesRepository}}/{{imageUrl}}"><div id="lp_alert_message" class="lp_text">{{text}}</div><div class="lp_buttons_area lp_hidden"><button class="lp_cancel_button" data-lp-point="cancel_button" data-lp-cust-id="cancel_button">{{cancel}}</button> <button class="lp_confirm_button" data-lp-point="confirm_button" data-lp-cust-id="button">{{confirm}}</button></div></td></tr></tbody></table></div>';
        }

        messageHTML = _envTextInjection(messageHTML);
        messageHTML = messageHTML.replace('{{text}}', text);
        messageHTML = messageHTML.replace('{{imageUrl}}', imageUrl);
        messageHTML = messageHTML.replace('{{loading}}', imageAltText || '');
        messageHTML = messageHTML.replace('{{cancel}}', language.getString('closeWindowCancelBtn'));
        messageHTML = messageHTML.replace('{{confirm}}', language.getString('closeWindowOkBtn'));

        if (messageData.showConfirm) {
          messageHTML = messageHTML.replace('lp_hidden', '');
        }

        if (messageData.needConfirmation) {
          util.unregisterEvent(closeButton, 'click', dispose);
          util.registerEvent(closeButton, 'click', _handleCloseConfirm);
        }

        if (messageData.deleteSession) {
            util.unregisterEvent(closeButton, 'click', dispose);
            util.registerEvent(closeButton, 'click', _endApplication);
        }

        maximizedBody.innerHTML += messageHTML;

        _confirmationBinding(messageData.showConfirm);

        // This solves accessibility alert issue (The alert message is not announced the second time it display)
        setTimeout(function(){
            maximizedBody.firstChild.setAttribute("role", "alert");
        }, 0);
    }

    function _confirmationBinding(showConfirm) {
        if (showConfirm) {
          var cancelButton = maximizedWrapperDomEl.querySelector(['[data-lp-point="cancel_button"]']);
          var confirmButton = maximizedWrapperDomEl.querySelector(['[data-lp-point="confirm_button"]']);
          util.registerEvent(cancelButton, 'click', _handleCancel);
          util.registerEvent(confirmButton, 'click', _endApplication);
        }
    }

    function _handleCloseConfirm() {
        setMessage(Messages.CONFIRMATION);
        util.unregisterEvent(closeButton, 'click', _handleCloseConfirm);
        util.registerEvent(closeButton, 'click', _endApplication);
    }

    function _endApplication(){
      events.trigger({
        appName: '*',
        eventName: 'knockout'
      });
    }
    function _bindToEvents() {
        events.bind({
            appName: "*",
            eventName: "translatorReady",
            func: _translateLabels
        });
    }
    function _handleCancel(){
      util.unregisterEvent(closeButton, 'click', _handleCloseConfirm);
      util.registerEvent(closeButton, 'click', dispose);
      setMessage(lastMessageType);
    }

    function _envTextInjection(text) {
        text = text.replace(/\{\{iconsRepository\}\}/g, getIconRepository());
        text = text.replace(/\{\{imagesRepository\}\}/g, config.imagesRepository);
        return text;
    }

    function _removeCentralizeContent() {
        util.removeClass(maximizedBody, 'lp_centered');
    }

    function _setConfig(key, value) {
        if (typeof key === 'object') {
            for (var prop in key) {
                config[prop] = key[prop];
            }
        } else {
            config[key] = value;
        }
    }

    function _init(config, dd, bsm, disposeCb) {
        deviceDetector = dd;
        browserStateManager = bsm;
        disposeCallback = disposeCb;
        language.setConfig(config);
        _setConfig(config);
        _setSystemMessages();
    }

    function _setSystemMessages(lang) {
        if (lang) {
            language.setLocale(lang);
        }

        SystemMessages = {
            CONNECTION_UNAVAILABLE: {
                title: language.getString('couldNotConnect'),
                imgUrl: 'connect-error-dark.png',
                text: language.getString('connectionUnavailable'),
                error: true
            },
            RIP: {
                title: language.getString('error'),
                imgUrl: 'connect-error-dark.png',
                text: language.getString('chatEndedOnExternalWindow'),
                error: true
            },
            EXTERNAL_OPEN: {
                title: language.getString('error'),
                imgUrl: 'connect-error-dark.png',
                text: language.getString('externalWindowOpen'),
                error: true
            },
            UNSUPPORTED: {
                title: language.getString('error'),
                imgUrl: 'connect-error-dark.png',
                text: language.getString('unsupportedBrowserMode'),
                error: true
            },
            IN_SESSION: {
                title: language.getString('error'),
                imgUrl: 'connect-error-dark.png',
                text: language.getString('cannotResumeChat'),
                error: true
            },
            AUTH_ERROR: {
                title: language.getString('error'),
                imgUrl: 'thank-you-dark.png',
                text: language.getString('chatAuthError'),
                error: true,
                needConfirmation: false,
                deleteSession: true
            },
            CONFIRMATION: {
                title: language.getString('error'),
                imgUrl: 'thank-you-dark.png',
                text: language.getString('confirmMessage'),
                error: true,
                showConfirm: true
            },
            FAILED_START_CONVERSATION_ERROR: {
                title: language.getString('error'),
                imgUrl: 'connect-error-dark.png',
                text: language.getString('startConversationError'),
                error: true
            },
            SESSION_EXPIRED: {
                title: language.getString('sessionExpired'),
                imgUrl: 'embedded-error.png',
                text: language.getString('sessionError'),
                error: true
            },
            WAIT: {
                title: language.getString('loading'),
                imgUrl: 'loader_on_warmGray5_75.gif',
                imgAltText: language.getString('loading')
            },
            PKCE_START: {
                title: language.getString('pkceAuthTitle'),
                imgUrl: 'loader_on_warmGray5_75.gif',
                text: language.getString('pkceAuthStarted')
            }
        };

        Messages = util.objectKeys(SystemMessages);
    }

    function _setDeviceFamilyClass() {
        var touchPointClass = configuration.WRAPPER_DIV_CSS_CLASS_PREFIX;
        if (deviceDetector.isMobile()) {
            touchPointClass += configuration.MOBILE_CSS_CLASS;
            util.addClass(deviceDetectorWrapperDomEl,  configuration.DEVICE_CLASS);
        } else if (deviceDetector.isTablet()) {
            touchPointClass += configuration.TABLET_CSS_CLASS;
            util.addClass(deviceDetectorWrapperDomEl, configuration.DEVICE_CLASS);
        } else {
            touchPointClass += configuration.DESKTOP_CSS_CLASS;
        }
        util.addClass(deviceDetectorWrapperDomEl, touchPointClass);
        return touchPointClass;
    }

    function _setBrowserVersionClass() {
        if(deviceDetector.isNativeAndroid()){
            util.addClass(deviceDetectorWrapperDomEl, configuration.WRAPPER_DIV_CSS_CLASS_PREFIX + configuration.NATIVE_CSS_CLASS);
        }

        var browserVersion = configuration.WRAPPER_DIV_CSS_CLASS_PREFIX;
        if (deviceDetector.isIE()) {
            browserVersion += 'ie' + deviceDetector.browserVersion();
        } else if (deviceDetector.isIOS()) {
            browserVersion += configuration.IOS_CSS_CLASS;
            if(deviceDetector.isIOS6()){
                browserVersion += ' ' + configuration.IOS6_CSS_CLASS;
            } else if(deviceDetector.isIOS8OrAbove()) {
                browserVersion += ' ' + configuration.WRAPPER_DIV_CSS_CLASS_PREFIX + configuration.IOS8_OR_ABOVE_CSS_CLASS;
            }
        } else if (deviceDetector.isAndroid()) {
            browserVersion += configuration.ANDROID_CSS_CLASS;
        } else if (deviceDetector.isMacOS()) {
            browserVersion += configuration.MAC_OSX_CSS_CLASS;
        } else {
            return; // handle later other options
        }

        util.addClass(deviceDetectorWrapperDomEl, browserVersion);
        return browserVersion;
    }

    function _createMinimized() {
        var minimized = '<div class="lp_minimized lpc_window lpc_window_minimized {{deviceClass}}" data-lp-point="minimized" data-lp-cust-id="minimized" role="region"><div class="lp_main" data-lp-point="main"><div class="lp_header lpc_minimized-header {{deviceClass}}" data-lp-point="header" data-lp-cust-id="top"><div tabindex="0" class="lp_notification_number lpc_minimized-header__notification-counter {{deviceClass}} lpHide" data-lp-point="notification_counter"><span class="lp_notification_text" role="alert" data-lp-point="notification_text">{{notification_number}}</span></div><div class="lp_header-content-wrapper"><div class="lp_title lpc_minimized-header__text-wrapper {{deviceClass}}" role="heading" aria-level="2"><div class="lp_chatting-with-icon lpc_minimized-header__icon {{deviceClass}} lpHide" data-lp-type="icon" data-lp-point="chattingWithIcon"><img class="lpc_minimized-header__icon-asset {{deviceClass}}" src="{{iconsRepository}}/sprites_v1.png" alt="" data-lp-cust-id="topBarIcon" draggable="false"></div><span data-lp-point="headerText" data-lp-cust-id="top_text" class="lp_top-text lpc_minimized-header__text {{deviceClass}}" data-studio-click="true">{{windowTitle}}</span></div><div class="lp_extended_title lpc_minimized-extended-header__text-wrapper lpHide {{deviceClass}}" role="heading"><div class="lp_brand-logo lpc_minimized-extended-header__logo-wrapper {{deviceClass}}"><img class="lp_brand-logo-asset lpc_minimized-extended-header__logo-asset {{deviceClass}}" alt="{{logoAltText}}" draggable="false"></div><div class="lp_headers-text-container"><span data-lp-point="titleText" data-lp-cust-id="top_text" class="lp_title-text lpc_minimized-extended-header__title-text {{deviceClass}}" data-studio-click="true">{{windowTitle}}</span> <span data-lp-point="headerText" data-lp-cust-id="sub_text" class="lp_top-text lpc_minimized-extended-header__top-text {{deviceClass}}" data-studio-click="true">{{windowTitle}}</span></div></div><div class="lp_header-buttons-container"><button title="{{tooltip_Maximize}}" class="lp_maximize lpc_minimized-header__maximize-button {{deviceClass}}" data-lp-point="maximize" role="button"><span class="lp_maximize-icon" data-lp-type="icon"><img class="lpc_minimized-header__maximize-button-asset {{deviceClass}}" src="{{iconsRepository}}/sprites_v1.png" alt="{{tooltip_Maximize}}" aria-hidden="true" draggable="false"></span></button> <button title="{{tooltip_Close}}" class="lp_close lpc_minimized-header__close-button {{deviceClass}}" data-lp-point="close" role="button"><span class="lp_close-icon" data-lp-type="icon"><img class="lpc_minimized-header__close-button-asset {{deviceClass}}" src="{{iconsRepository}}/sprites_v1.png" alt="{{tooltip_Close}}" aria-hidden="true" draggable="false"></span></button></div></div></div></div></div>';
        minimized = _envTextInjection(minimized);
        minimized = minimized.replace(/\{\{tooltip_Close\}\}/g, language.getString('tooltip_Close'));
        minimized = minimized.replace(/\{\{deviceClass\}\}/g, lpTag.unifiedWindow.customization.deviceClass);
        minimized = minimized.replace(/\{\{logoAltText\}\}/g, language.getString('logoAltText'));
        wrapperDomEl.innerHTML += minimized;
    }

    function _createViews() {
        _createMinimized();
        _createMaximized();
        _getDomEls();
    }

    function _createMaximized() {
        var maximized = '<div class="lp_maximized lpmx lpc_window lpc_window_maximized {{deviceClass}}" data-lp-point="maximized" data-lp-cust-id="maximizedWindow" role="dialog" aria-label="{{windowRegionLabel}}"><div class="lp_header lpc_maximized-header {{deviceClass}}" data-lp-point="header" data-lp-cust-id="top" data-studio-click="true"><div class="lp_header-content-wrapper"><button title="{{tooltip_open_widgets}}" class="lp_hidden lp_slider lpc_maximized-header__slider-button {{deviceClass}}" data-lp-point="widget_sdk"><span class="lp-slider-icon" data-lp-type="icon"><img class="lpc_maximized-header__slider-button-asset {{deviceClass}}" src="{{iconsRepository}}/sprites_v1.png" alt="" aria-hidden="true"></span></button><div class="lp_notification_number wsdkNotification lpHide" data-lp-point="widgetNotificationContainer"><span class="lp_notification_text" data-lp-point="widgetNotificationText" role="alert" aria-live="assertive">0</span></div><div class="lp_title lpc_maximized-header__text-wrapper {{deviceClass}}" data-lp-point="maximizedTitleContainer"><div class="lp_chatting-with-icon lpc_maximized-header__icon lpc_maximized-header__icon {{deviceClass}} lpHide" data-lp-type="icon" data-lp-point="chattingWithIcon"><img class="lpc_maximized-header__icon-asset {{deviceClass}}" src="{{iconsRepository}}/sprites_v1.png" alt="" aria-hidden="true" data-lp-cust-id="topBarIcon"></div><span data-lp-point="headerText" data-lp-cust-id="top_text" class="lp_top-text lpc_maximized-header__text {{deviceClass}}" data-studio-click="true" aria-live="polite" aria-atomic="true" role="heading" aria-level="2">{{windowTitle}}</span></div><div class="lp_extended_title lpc_maximized-extended-header__text-wrapper lpHide {{deviceClass}}" data-lp-point="maximizedExtendedTitleContainer"><div class="lp_brand-logo lpc_maximized-extended-header__logo-wrapper {{deviceClass}}"><img class="lp_brand-logo-asset lpc_maximized-extended-header__logo-asset {{deviceClass}}" alt="{{logoAltText}}"></div><div class="lp_headers-text-container"><span data-lp-point="titleText" data-lp-cust-id="top_text" class="lp_title-text lpc_maximized-extended-header__title-text {{deviceClass}}" data-studio-click="true" aria-live="polite" aria-atomic="true" role="heading" aria-level="2">{{windowTitle}}</span> <span data-lp-point="headerText" data-lp-cust-id="sub_text" class="lp_top-text lpc_maximized-extended-header__top-text {{deviceClass}}" data-studio-click="true" aria-live="polite" aria-atomic="true" role="heading" aria-level="2">{{windowTitle}}</span></div></div><div class="lp_header-buttons-container"><div tabindex="0" role="button" class="lp_menu-top-btn lpc_maximized-header__menu-button {{deviceClass}}" data-lp-cust-id="top_menu_button" data-lp-point="menu-top-btn" data-studio-click="true" aria-label="{{tooltip_ExpandActionMenu}}"><div class="lp_menu-top-icon" data-lp-type="icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 23 23" class="lpc_maximized-header__menu-button-asset {{deviceClass}}" aria-hidden="true"><g fill="none" fill-rule="evenodd"><path fill="#848586" d="M6.5 11a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm6 0a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm6 0a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/></g></svg></div></div><div tabindex="0" role="button" title="{{tooltip_Minimize}}" class="lp_minimize lpc_maximized-header__minimize-button {{deviceClass}}" data-lp-point="minimize"><span class="lp_minimize-icon" data-lp-type="icon" data-lp-point="minimize_icon"><img class="lpc_maximized-header__minimize-button-asset {{deviceClass}}" src="{{iconsRepository}}/sprites_v1.png" alt="{{tooltip_Minimize}}" aria-hidden="true" draggable="false"></span></div><div tabindex="0" role="button" title="{{tooltip_Close}}" class="lp_close lpc_maximized-header__close-button {{deviceClass}}" data-lp-point="close"><span class="lp_close-icon" data-lp-type="icon"><img class="lpc_maximized-header__close-button-asset {{deviceClass}}" src="{{iconsRepository}}/sprites_v1.png" alt="{{tooltip_Close}}" aria-hidden="true" draggable="false"></span></div></div></div></div><div class="lp_main lpc_body {{deviceClass}}" data-lp-point="main" data-lp-cust-id="mainArea"></div></div><div data-lp-point="buffer-strip" class="lp_buffer-strip"><div class="lp_buffer-strip-container" data-lp-cust-id="mainArea"></div></div>';
        maximized = _envTextInjection(maximized);
        maximized = maximized.replace(/\{\{tooltip_Close\}\}/g, language.getString('tooltip_Close'));
        maximized = maximized.replace(/\{\{deviceClass\}\}/g, lpTag.unifiedWindow.customization.deviceClass);
        maximized = maximized.replace(/\{\{windowRegionLabel\}\}/g, language.getString('windowRegionLabel'));
        maximized = maximized.replace(/\{\{headerRegionLabel\}\}/g, language.getString('headerRegionLabel'));
        maximized = maximized.replace(/\{\{logoAltText\}\}/g, language.getString('logoAltText'));
        wrapperDomEl.innerHTML += maximized;
    }
    
    function _translateLabels() {
        var minimizedLabel = language.getString('minimizedChatWindowLabel');
        document.querySelector('[data-lp-point="maximized"]').setAttribute('aria-label', language.getString('windowRegionLabel'));
        document.querySelector('[data-lp-point="minimized"]').setAttribute('aria-label', minimizedLabel);
        document.querySelector('[data-lp-point="header"]').setAttribute('aria-label', language.getString('headerRegionLabel'));
        document.querySelector('[title="{{tooltip_open_widgets}}"]').title = language.getString('tooltip_open_widgets');
        events.unbind({
            appName: "*",
            eventName: "translatorReady",
            func: _translateLabels
        });
    }

    function _getDomEls() {
        minimizedWrapperDomEl = wrapperDomEl.querySelector('[data-lp-point="minimized"]');
        maximizedWrapperDomEl = wrapperDomEl.querySelector('[data-lp-point="maximized"]');
        bufferStripDomEl = wrapperDomEl.querySelector('[data-lp-point="buffer-strip"]');
    }

    function _createWrapping(siteId) {
        wrapperDomEl = document.createElement('div');
        if (configuration.WRAPPER_DIV_ID) {
            wrapperDomEl.id = configuration.WRAPPER_DIV_ID;
            util.addClass(wrapperDomEl, configuration.WRAPPER_CLASS_NAME);
            util.addClass(wrapperDomEl, siteId);
        }
        wrapperDomEl.setAttribute("role", "region");
        wrapperDomEl.setAttribute("aria-label", language.getString('windowRegionLabel'));
        deviceDetectorWrapperDomEl = document.createElement('div');
        deviceDetectorWrapperDomEl.appendChild(wrapperDomEl);
        document.body.appendChild(deviceDetectorWrapperDomEl);
    }

    function _render(initUIState) {
        //<excludeFromBuild>
        log.info('rendering', name);
        //</excludeFromBuild>
        var uiState = initUIState && initUIState.window,
            lang = initUIState && initUIState.engConf && initUIState.engConf.lang,
            siteId = initUIState && initUIState.engConf && initUIState.engConf.site || lpTag.site;

        if (lang) {
            _setSystemMessages(lang);
        }
        disposed = false;

        _fixMinimumWidth();
        _createWrapping(siteId);
        _createViews();

        // rendering iFrames to facilitate content in each

        var minimizedMain = minimizedWrapperDomEl.querySelector('[data-lp-point="main"]');
        util.addClass(minimizedWrapperDomEl, "lpHide");

        if (configuration.MINIMIZED_VIEW_IFRAME_RENDERING) {
            minimizedDocument = _renderDocument(minimizedMain);
            minimizedBody = minimizedDocument.body;
            util.addClass(minimizedBody, 'lp_main');
        } else {
            minimizedBody = minimizedMain;
        }

        var maximizedMain = maximizedWrapperDomEl.querySelector('[data-lp-point="main"]');

        if (configuration.MAXIMIZED_VIEW_IFRAME_RENDERING) {
            maximizedDocument = _renderDocument(maximizedMain);

            maximizedBody = maximizedDocument.body;
            util.addClass(maximizedBody, 'lp_main');
            util.addClass(maximizedBody, 'lpc_body');
        } else {
            maximizedBody = maximizedMain;
        }

        sliderButton = maximizedWrapperDomEl.querySelector(['[data-lp-point="widget_sdk"]']);
        widgetNotificationContainer = maximizedWrapperDomEl.querySelector(['[data-lp-point="widgetNotificationContainer"]']);
        widgetNotificationText = maximizedWrapperDomEl.querySelector(['[data-lp-point="widgetNotificationText"]']);
        titleDiv = maximizedWrapperDomEl.querySelector(['[data-lp-point="maximizedTitleContainer"]']);
        chattingWithIcon = maximizedWrapperDomEl.querySelector(['[data-lp-point="chattingWithIcon"]']);
        closeButton = maximizedWrapperDomEl.querySelector(['[data-lp-point="close"]']);
        minimizedButton = maximizedWrapperDomEl.querySelector(['[data-lp-point="minimize"]']);
        topMenuButton = maximizedWrapperDomEl.querySelector(['[data-lp-point="menu-top-btn"]']);
        popButton =  maximizedWrapperDomEl.querySelector(['[data-lp-point="popicon"]']);

        if (popButton) {
            util.addClass(popButton, config.poppedOut ? 'lp_pop-in-icon' : 'lp_pop-out-icon');
        }

        if (_isExternalWindow()) {
            _setExternalClass();
            _setTopBarClass();
            _setDocumentLang(config.engConf.lang);
            _setNativeSDKClass();
        }

        showMinimized(false);
        showClose(false);
        showTopMenu(false);

        _setUIState(uiState);

        _applyStyle();
        _setWaitMessage();
        _setRenderState(true);
        _applyDeviceClasses();

    }

    function _isExternalWindow() {
        return config.poppedOut || config.external;
    }

    function _setWaitMessage() {
        waitIndicationTimer = setTimeout(function () {
            setMessage(Messages.WAIT);
        }, configuration.WAIT_INDICATION_DELAY);
    }

    function _applyDeviceClasses() {
        _setDeviceFamilyClass();
        _setBrowserVersionClass();
        if (deviceDetector.isMobile() || deviceDetector.isTablet()) {
            _setOrientationClass({landscape: browserStateManager.isLandscape()});
            browserStateManager.on(browserStateManager.EVENT_NAME.ORIENTATION_CHANGE, _setOrientationClass);
        }
    }

    function _applyStyle() {
        //<excludeFromBuild>
        log.info('applying style', name);
        //</excludeFromBuild>
        var addedInitialStyleEl = document.getElementById(configuration.STYLE_TAG_ID);
        var addedEmbeddedStyleEl = document.getElementById(configuration.EMBEDDED_STYLE_TAG_ID);
        if (!addedInitialStyleEl && !addedEmbeddedStyleEl && !config.enableStrictCspMode) {
            style = util.addStyleTag('.lp-window-root .lp_close-icon{position:relative;display:inline-block;vertical-align:middle;overflow:hidden}.lp-window-root .lp_close-icon img{top:0;left:-480px;position:absolute}.lp-window-root .lp_menu-top-icon{position:relative;display:inline-block;vertical-align:middle;overflow:hidden}.lp-window-root .lp_menu-top-icon img{top:0;left:-480px}.lp-window-root .lp_minimize-icon{display:none}.lp-window-root .lp_chevron-icon{display:none}.lp_desktop .lp-window-root .lp_close-icon,.lp_desktop .lp-window-root .lp_close{width:24px;height:24px}.lpdv .lp-window-root .lp_close-icon,.lpdv .lp-window-root .lp_close{width:24px;height:24px}.lp-window-root *{-webkit-box-sizing:border-box;box-sizing:border-box;font-weight:normal;letter-spacing:0;font-family:inherit;opacity:1;filter:alpha(opacity=100);max-width:none;direction:inherit;text-align:inherit;outline:none}.lp-window-root *::-moz-focus-inner{border:0}.lp-window-root table,.lp-window-root tbody,.lp-window-root td,.lp-window-root span,.lp-window-root tr,.lp-window-root table,.lp-window-root div,.lp-window-root button,.lp-window-root img{margin:0;padding:0;border:0;background:inherit;background:initial;position:static;position:initial;width:auto;height:auto;text-shadow:none;box-shadow:none;-webkit-box-shadow:initial;line-height:normal}.lp-window-root img{vertical-align:bottom;background:inherit;color:#000}.lp-window-root table,.lp-window-root tbody,.lp-window-root td,.lp-window-root span,.lp-window-root tr,.lp-window-root table,.lp-window-root div,.lp-window-root button{vertical-align:baseline;background:inherit;color:inherit;font-size:inherit}.lp-window-root button{font-size:1em;border-radius:0}.lp-not-selectable{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.lp-not-selectable *{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.lp-window-root{font-family:"Arial"}.lp-window-root .lp_header{background-color:#f0f0f0;border:1px solid #d6d6d6;border-radius:5px 5px 0 0;font-size:1.1em;z-index:2;width:100%;position:absolute}.lp-window-root .lp_main{padding:0;z-index:1;height:100%;width:100%;position:absolute;right:0;bottom:0}.lp-window-root .lp_main .lp_wait{position:absolute;top:0;bottom:0;left:0;right:0}.lp-window-root .lp_main .lp_wait table{height:100%;width:100%}.lp-window-root .lp_main .lp_wait td{text-align:center;vertical-align:middle}.lp-window-root .lp_main>.lp_message{text-align:center;width:100%;height:100%}.lp-window-root .lp_main>.lp_message .lp_text{padding:10px 4px 0 4px;text-align:center}.lp-window-root .lp_main>.lp_message .lp_buttons_area{position:relative;text-align:center;padding:0 5%;height:40px;margin-top:5px}.lp-window-root .lp_main>.lp_message .lp_buttons_area button{padding:9px 6px;width:45%;float:left;font-size:.9em;border:none;text-align:center;cursor:pointer;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.lp-window-root .lp_main>.lp_message .lp_buttons_area .lp_confirm_button{color:#fff;background-color:#0363ad;margin-left:10%;border-radius:2px}.lp-window-root .lp_main>.lp_message .lp_buttons_area .lp_confirm_button:disabled{opacity:.5;cursor:default}.lp-window-root .lp_main>.lp_message .lp_buttons_area .lp_confirm_button:hover,.lp-window-root .lp_main>.lp_message .lp_buttons_area .lp_confirm_button:focus{background-color:#025487}.lp_lpIos .lp-window-root .lp_main>.lp_message .lp_buttons_area .lp_cancel_button:hover,.lp_lpIos .lp-window-root .lp_main>.lp_message .lp_buttons_area .lp_cancel_button:focus{background:#f2f2f2}.lp-window-root .lp_main>.lp_message .lp_buttons_area .lp_cancel_button{background:rgba(0,0,0,0);color:#6d6e70}.lp-window-root .lp_main>.lp_message .lp_buttons_area .lp_single_button{float:none;margin-left:0}.lp-window-root .lp_header-content-wrapper{width:100%;height:100%}.lp-window-root .lp_header-content-wrapper .lp_title,.lp-window-root .lp_header-content-wrapper .lp_subtitle{direction:ltr}.lp-window-root .lp_header-content-wrapper .lp_title>*,.lp-window-root .lp_header-content-wrapper .lp_subtitle>*{vertical-align:middle}.lp-window-root .lp_header-content-wrapper .lp_top-text,.lp-window-root .lp_header-content-wrapper .lp_title-text{overflow:hidden;text-overflow:ellipsis;display:inline-block;margin-left:8px;max-width:150px;white-space:nowrap}.lp-window-root .lp_header-content-wrapper button{background:none;position:absolute;cursor:pointer}.lp-window-root>.lpmx{border-radius:5px 5px 0 0;-webkit-box-shadow:0 0 16px 3px rgba(0,0,0,.2);box-shadow:0 0 16px 3px rgba(0,0,0,.2);color:#000}.lp-window-root>.lpmx>.lp_main{background-color:#fff}.lp-window-root>.lpmx.lp_external-window{border-radius:0;position:fixed;left:0;right:0;bottom:0;top:0;width:100%;height:100%;overflow:hidden}.lp-window-root>.lpmx.lp_external-window.lp_no-top>.lp_header{display:none}.lp-window-root>.lpmx.lp_external-window.lp_no-top>.lp_main{top:0}.lp-window-root button:focus{outline:#3a61d4 solid 2px}.lp-window-root button:focus:not(:focus-visible){outline:none}.lp-window-root .lp_text:empty,.lp-window-root img[src=""]{display:none}.lp-window-root .lpHide,.lp-window-root .lp_hidden{display:none !important}.lp-window-root .lp_disable_select{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.lp-window-root table.lp_centralizer{height:100%;width:100%}.lp-window-root table.lp_centralizer td{text-align:center;vertical-align:middle}.lp-window-root .lp_rotator-container{position:relative;display:inline-block;width:100px;height:100px}.lp-window-root .lp_rotator-container-bg{position:absolute;top:0;right:0;bottom:0;left:0;background-color:rgba(0,0,0,0);opacity:.92;border-radius:10px}.lp-window-root .lp_rotator{padding-top:12px;text-align:center;position:absolute;top:0;right:0;bottom:0;left:0}.lp-window-root .lp_skeleton-window-body{width:100%;height:100%;display:block}.lp-window-root .lp_skeleton-header{width:90%;height:94px;border-radius:12px;margin:6% auto 0 auto}.lp-window-root .lp_skeleton-message{width:30%;height:36px;margin-top:10%}.lp-window-root .lp_skeleton-agent{width:44%;margin-left:10%;border-radius:14px 14px 14px 0px}.lp-window-root .lp_skeleton-visitor{margin-left:61%;border-radius:14px 14px 0px 14px}.lp-window-root .lp_skeleton-input{position:absolute;bottom:2%;left:3%;width:94%;height:38px;border-radius:12px}.lp-window-root .lp_skeleton-box{display:inline-block;width:100%;height:100%;position:relative;overflow:hidden;background-color:#dddbdd;border-radius:inherit}.lp-window-root .lp_skeleton-box::after{position:absolute;top:0;right:0;bottom:0;left:0;-webkit-transform:translateX(-100%);transform:translateX(-100%);background-image:-webkit-gradient(linear, left top, right top, color-stop(0, rgba(255, 255, 255, 0)), color-stop(20%, rgba(255, 255, 255, 0.2)), color-stop(60%, rgba(255, 255, 255, 0.5)), to(rgba(255, 255, 255, 0)));background-image:linear-gradient(90deg, rgba(255, 255, 255, 0) 0, rgba(255, 255, 255, 0.2) 20%, rgba(255, 255, 255, 0.5) 60%, rgba(255, 255, 255, 0));-webkit-animation:shimmer 2s infinite;animation:shimmer 2s infinite;content:""}@-webkit-keyframes shimmer{100%{-webkit-transform:translateX(100%);transform:translateX(100%)}}@keyframes shimmer{100%{-webkit-transform:translateX(100%);transform:translateX(100%)}}.lp_desktop .lp-window-root{font-size:13px}.lp_desktop .lp-window-root>*{width:280px;z-index:99999999;position:fixed;right:20px;bottom:0}.lp_desktop .lp-window-root>* .lp_header{height:36px;padding:0 5px}.lp_desktop .lp-window-root>* .lp_header button,.lp_desktop .lp-window-root>* .lp_header div[role=button]{z-index:99999999;top:6px}.lp_desktop .lp-window-root>* .lp_header button:focus,.lp_desktop .lp-window-root>* .lp_header div[role=button]:focus{outline:#fff solid 2px}.lp_desktop .lp-window-root>* .lp_header button:focus:not(:focus-visible),.lp_desktop .lp-window-root>* .lp_header div[role=button]:focus:not(:focus-visible){outline:none}.lp_desktop .lp-window-root>.lpmx{height:400px;max-height:100%}.lp_desktop .lp-window-root>.lpmx>.lp_header .lp_title{float:left;padding-top:9px;padding-left:3px}.lp_desktop .lp-window-root>.lpmx>.lp_main{height:auto;top:36px}.lp_desktop .lp-window-root>.lpmx .lp_header-content-wrapper .lp_header-buttons-container{float:right;direction:ltr;font-size:0}.lp_desktop .lp-window-root>.lpmx .lp_header-content-wrapper button{position:relative;display:inline-block}.lp_desktop .lp-window-root>.lpmx .lp_header-content-wrapper button:focus{outline:#fff solid 2px}.lp_desktop .lp-window-root>.lpmx .lp_header-content-wrapper button:focus:not(:focus-visible){outline:none}.lp_desktop .lp-window-root>.lpmx .lp_header-content-wrapper .lp_cancel_button:hover,.lp_desktop .lp-window-root>.lpmx .lp_header-content-wrapper .lp_cancel_button:focus{background:#f2f2f2}.lp_desktop .lp-window-root>.lp_maximized_large{width:340px;height:580px;max-height:100%}.lp_desktop .lp-window-root>.lp_minimized_large{width:340px;max-width:100%}.lp_desktop .lp-window-root>.lp_floating{margin-bottom:20px;max-height:calc(100% - 20px)}.lpdv .lp-window-root .lp_header-content-wrapper{text-align:center;display:table;border-collapse:collapse}.lpdv .lp-window-root .lp_header-content-wrapper>*{vertical-align:middle;display:table-cell}.lpdv .lp-window-root .lp_header-content-wrapper .lp_header-buttons-container{display:table}.lpdv .lp-window-root>.lpmx{z-index:99999999;opacity:.95;position:fixed;top:0;right:0;bottom:0;left:0;border-radius:0}.lpdv .lp-window-root>.lpmx>.lp_header{direction:ltr;height:8%;min-height:40px}.lpdv .lp-window-root>.lpmx>.lp_header .lp_title{width:100%;text-align:center}.lpdv .lp-window-root>.lpmx>.lp_header .lp_top-text{text-align:center}.lpdv .lp-window-root>.lpmx>.lp_header button{top:0;right:0;height:100%;width:40px;text-align:center;position:absolute}.lpdv .lp-window-root>.lpmx>.lp_header .lp_close{right:0}.lpdv .lp-window-root>.lpmx>.lp_main{height:92%}.lpdv .lp-window-root>.lpmx>.lp_main .lp_buttons_area{margin-top:3%}.lpdv .lp-window-root>.lpmx>.lp_main .lp_buttons_area button{font-size:1.2em}.lpdv .lp-window-root.lp_landscape .lp-window-root>.lpmx .lp_header{display:none}.lpdv .lp-window-root.lp_landscape .lp-window-root>.lpmx>.lp_main{padding-top:0;top:0;height:100%}.lp_mobile .lp-window-root{font-size:14px}.lp_tablet .lp-window-root{font-size:18px}.lp_tablet .lp-window-root>.lpmx .lp_header-content-wrapper .lp_title .lp_top-text{max-width:250px}', {id: configuration.STYLE_TAG_ID});
        }
    }

    /**
     * render an iframe into provided dom el
     * @param parentDomEl
     * @returns the iframe document
     */
    function _renderDocument(parentDomEl) {
        var iframe = document.createElement('iframe');
        parentDomEl.appendChild(iframe);
        return iframe.contentWindow.document;
    }

    function _clearTimeouts() {
        clearTimeout(waitIndicationTimer);
    }

    function _setOrientationClass(data) {
        var pfx = configuration.WRAPPER_DIV_CSS_CLASS_PREFIX;
        if (data.landscape) {
            util.removeClass(deviceDetectorWrapperDomEl, pfx + configuration.PORTRAIT_CSS_CLASS);
            util.addClass(deviceDetectorWrapperDomEl, pfx + configuration.LANDSCAPE_CSS_CLASS);
        } else {
            util.removeClass(deviceDetectorWrapperDomEl, pfx + configuration.LANDSCAPE_CSS_CLASS);
            util.addClass(deviceDetectorWrapperDomEl, pfx + configuration.PORTRAIT_CSS_CLASS);
        }
    }

    function _setExternalClass() {
        util.addClass(maximizedWrapperDomEl, configuration.EXTERNAL_CSS_CLASS);
    }

    function _setTopBarClass() {
        if (config.hideTopBar) {
            util.addClass(maximizedWrapperDomEl, configuration.HIDE_TOP_BAR_CSS_CLASS);
        }
    }

    function _setNativeSDKClass() {
        if(config.NativeSDK) {
            util.addClass(maximizedWrapperDomEl, configuration.WEBVIEW_CSS_CLASS);
        }
    }

    function _setDocumentLang(lang) {
        document.documentElement.setAttribute("lang", lang);
    }

    function _adjustBorderRadius(themer) {
        var borderRadiusTop = themer.getStyle('top', 'border-radius');
        var borderRadiusBottom = themer.getStyle('input', 'border-radius');

        if (borderRadiusTop && borderRadiusBottom) {
            var borderRadiusTopTokens = borderRadiusTop.split(' ').slice(0,2);
            var borderRadiusBottomTokens = borderRadiusBottom.split(' ').slice(2);
            var borderRadius = borderRadiusTopTokens[0] + ' ' + borderRadiusTopTokens[1] + ' ' +  borderRadiusBottomTokens[0] + ' ' + borderRadiusBottomTokens[1];
            minimizedWrapperDomEl.style.borderRadius = borderRadiusTop;
            maximizedWrapperDomEl.style.borderRadius = borderRadius;
        } else if (!borderRadiusTop && borderRadiusBottom) {
            maximizedWrapperDomEl.style.borderRadius = borderRadiusBottom;
        } else {
            minimizedWrapperDomEl.style.borderRadius = borderRadiusTop;
            maximizedWrapperDomEl.style.borderRadius = borderRadiusTop;
        }
    }

    //Define whether the embedded window on mobile will be solid or slightly transparent.
    function _adjustMobileOpacity(themer) {
        var mobileOpacity = themer.getStyle('mobileOpacity', 'text');
        if (mobileOpacity && (mobileOpacity === 'true')) { // If true ('Yes' in LE chat studio), the window will be solid (opacity: 1). If false ('No' in LE chat studio), the window will be slightly transparent (opacity: 0.95 - this is the default opacity set in css).
            maximizedWrapperDomEl.style.opacity = 1;
        }
    }

    /**
     * Fix the minimum width for Browsers (Edge) that clip the window under a certain width
     * @private
     */
    function _fixMinimumWidth() {
        // In Edge, we saw that under 372px width the outerWidth is less than the innerWidth, which causes the UI to look clipped
        if (window.outerWidth < window.innerWidth && window.outerWidth < configuration.MINIMUM_INNER_WIDTH) {
            window.resizeTo(configuration.MINIMUM_INNER_WIDTH, window.outerHeight);
        }
    }

    /**
     * Escapes html special characters such as gt, lt, quotes and ampersand
     * @param {string} text text string potentially containing html
     * @returns {string} escaped text
     * @private
     */
    function _escapeHTML(text) {
        if (!text) {
            return "";
        }
        return text
            .replace(/>/g, "&gt;")
            .replace(/</g, "&lt;")
            .replace(/'/g, "&#39;")
            .replace(/"/g, "&quot;")
            .replace(/&/g, "&amp;");
    }

    function _showPKCEStartMessage() {
        setMessage("PKCE_START");
    }

    /**** reveal area ****/

    return {
        render: render,
        show: show,
        hide: hide,
        message: setMessage,
        removeMessage: removeMessage,
        unbindDomEvents: unbindDomEvents,
        setTitle: setTitle,
        Messages: Messages,
        getMinimizedElement: getMinimizedElement,
        getBufferStripElement: getBufferStripElement,
        getMaximizedElement: getMaximizedElement,
        getMainWindowElement: getMainWindowElement,
        getChatWrapperElement: getChatWrapperElement,
        getSliderButton:getSliderButton,
        getWidgetNotificationContainer: getWidgetNotificationContainer,
        getWidgetNotificationText: getWidgetNotificationText,
        getTitleDiv: getTitleDiv,
        getChattingWIthIcon: getChattingWIthIcon,
        dispose: dispose,
        showClose: showClose,
        showMinimized: showMinimized,
        showTopMenu : showTopMenu,
        getIconRepository: getIconRepository,
        adjustConfigStyle: adjustConfigStyle,
        getWrapperElementId: getWrapperElementId
    };

};


/****************************************************************/

/**
 * This taglet orchestrate between the different classes and understands the logic of the bootstrap.
 *
**/
window.lpTag = window.lpTag || {};
lpTag.taglets = lpTag.taglets || {};
lpTag.unifiedWindow = lpTag.unifiedWindow || {};
lpTag.unifiedWindow.apps = lpTag.unifiedWindow.apps || {
    UNIFIED_WINDOW: "lpUnifiedWindow"
};

lpTag.unifiedWindow.staticConfig = lpTag.unifiedWindow.staticConfig || {
    secureForms : {
        isDesktopSupported : true
    },
    passSiteSettings: true
};

lpTag.unifiedWindow.customization = lpTag.unifiedWindow.customization || {
    deviceClass : null
};

lpTag.engagementClickEventsSeen = lpTag.engagementClickEventsSeen || 0;

lpTag.taglets.lpUnifiedWindow = lpTag.taglets.lpUnifiedWindow || function () {

        var CONSTS = {
            stepUpInWaitingState: {
                appName: "stepUpInWaitingState",
                storageKey: "-stepUpDataInWaitingState"
            }
        };

        var name = "lpUnifiedWindow",
            v = "10.39.0-release_1402625749",
            unifiedWindow = lpTag.unifiedWindow,
            log = unifiedWindow.log,
            util = lpTag.taglets.lpUtil,
            settingsID = lpTag.unifiedWindow.settingsIDs,
            events,
            secureStorage,
            selectedStorageType,
            cacheBusterVer = "?version=" + (v || new Date().getTime().toString()),
            defaultUIState = {
                window: {
                    maximized: true,
                    position: {
                        right: "20px", bottom: 0
                    },
                    sound: true,
                    notificationCount: 0,
                    actionsVisible: false,
                    emojisVisible: false,
                    embedded: true
                }
            },
            endedState = 3,
            conf = {},
            stateAnalyzer,
            appConfigurationManager,
            pkceManager,
            wrapperWindow,
            browserStateManager,
            deviceDetector,
            sessionManager,
            windowConfigurationManager,
            windowConfig,
            accountSettingsManager,
            accountSettings = [],
            wrapperWindowRendered = false,
            lpWindowTranslatedError = null,
            application,
            appFilesReady = false,
            errorTimeout = 5000,
            wrapperWindowErrorTimeoutId,
            currentState,
            CHAT_ENDED = "applicationEnded",
            CSDS = {
                ADMIN_AREA: "adminArea",
                ALL: "ALL",
                LECDN: "leCdnDomain",
                ACCDN: "acCdnDomain",
                ACCDN_CONSUMER_SDK: "acCdnDomainConsumerSdk",
                ASYNC_MESSAGING: "asyncMessagingEnt",
                MESSAGING_HISTORY: "msgHist",
                IDP: "idp",
                SMS_API: "smsConnector",
                SHIFT_STATUS: "shiftstatus"
            },
            domainWhitelist = {
                LECDN: ['lpsnmedia.net', 'liveperson.net', 'liveperson.com', 'lprnd.net'],
                ACCDN: ['lpsnmedia.net', 'liveperson.net', 'liveperson.com', 'lprnd.net']
            },
            APP = unifiedWindow.apps.UNIFIED_WINDOW,
            requestedAPIs = {
                "UMSClientAPI": false,
                "lpChatV3": false
            },
            tagDomain,
            queryParams = util.getURLParams(window.location.search),
            parent_window = null,
            externalOrigin = null,
            parentWindowOrigin = null,
            derivedParentWindowOriginInExternalWindow = (queryParams && queryParams.parentWindowOrigin && queryParams.parentWindowOrigin !== '') ? queryParams.parentWindowOrigin : null,
            appStarted = false,
            closeCallback = _seppuku,
            STORAGE_SELECTED_EVENT = "STORAGE_SELECTED",
            EXTERNAL_TARGET = {
                POPOUT: "popout",
                TAP_TO_TEXT: "tapToText"
            },
            EXTERNAL_TARGET_ID = {
                SMS: 0
            },
            HOOKS = {
                ON_EXTERNAL_LAUNCH: 'ON_EXTERNAL_LAUNCH'
            },
            initUIStateCommon,
            externalConfIfFailed,
            windowConfIfExternalFailed,
            stylesAttached = false,
            initialStylesAttached = false,
            stylesLoaded = false,
            scriptsNumberToLoadAsync = 3,
            scriptsAsyncLoaded = 0,
            isRestartForStepUpInProgress = false,
            artificialClick = false,
            isStartingApplicationFromStorageState = false,
            isApplicationRestartingInWaitingState,
            isStepUpDuringWaitingStateEnabled = false,
            isFetchEnabled = false,
            fetchCacheMode,
            monitoringSDK = lpTag.taglets.lp_monitoringSDK;

        var LPCssCustomizationClasses = {
            NAMESPACE: 'lpc',
            MOBILE_CSS_CLASS: 'mobile',
            TABLET_CSS_CLASS: 'tablet',
            DESKTOP_CSS_CLASS: 'desktop'
        };

        // cfg is taglet configuration excepting on dev
        function init(cfg) {
            var configErrorType;
            //<excludeFromBuild>
            log.setLogLevel("DEBUG");
            //</excludeFromBuild>
            _initConfig(cfg);
            _setSiteAndDebug(conf);

            log.init({
                debug: conf.debug,
                loggosLogging: conf.loggosLogging
            });
            log.info("init", name);

            secureStorage = window.lpTag.taglets.lpSecureStorage;
            secureStorage.isStepUpEnabled = conf && conf.isStepUpEnabled;
            
            deviceDetector = new unifiedWindow.DeviceDetector();

            if(window && window.opener){
                parent_window = window.opener;
            }

            if (conf) {
                isStepUpDuringWaitingStateEnabled = conf.isStepUpDuringWaitingStateEnabled;
                var currentEnv = (typeof lpTag.getEnv === "function" && lpTag.getEnv());
                isFetchEnabled = ((conf.isFetchEnabled !== undefined) ? JSON.parse(conf.isFetchEnabled) : currentEnv === 'alpha');
                fetchCacheMode = conf.fetchCacheMode;
            }

            window.lpTag.unifiedWindow.customization.deviceClass = _getDeviceClass(deviceDetector);

            appConfigurationManager = new lpTag.unifiedWindow.AppConfigurationManager({
                lpTag: lpTag,
                utils: lpTag.taglets.lpUtil,
                deviceDetector: deviceDetector,
                queryParams: queryParams
            });

            pkceManager = new lpTag.unifiedWindow.PKCEManager();
            pkceManager.init();

            _initDefaultValues(conf, defaultUIState);

            if (conf.enableStrictCspMode && !initialStylesAttached) {
                _loadInitialStyles();
            }

            if (conf.engConf && conf.engConf.offsiteEngContext) {
                conf.clickedChannel = appConfigurationManager.getClickedChannel(conf.engConf, true);
            }

            browserStateManager = new unifiedWindow.BrowserStateManager(deviceDetector);

            events = new lpTag.unifiedWindow.Events({eventBufferLimit: 0, cloneEventData: false});

            //<excludeFromBuild>
            log.info("init: initial configuration: " + JSON.stringify(conf), name);
            //</excludeFromBuild>

            _initWrapperWindow();

            _bindToEvents();

            configErrorType = _getConfigError(conf);
            if (configErrorType) {
                _showWrapperWindowError(configErrorType, true);
                return;
            }
            if (lpTag.features.getFeature('Common.Multiple_Consumer_IDP')) {
                _getAllConnectors(function (connectors) {
                    if (connectors && connectors.length) {
                        conf.connectors = connectors;
                    }
                    _configureSecureStorage();
                });
            } else {
                _configureSecureStorage();
            }

            if (!_isPreloadDisabled()) {
                _loadFrameworkAsync();
            }
        }

        /**
        * This is a lifecycle function being called by tag.js on SPA newPage
        * before making the actual navigation.
        * In our case it will allow to dispose of the window in a new page (logout purpose in SPA)
        * @param options = { dispose: true/false }
        */
        function onBeforeNavigation(options) {
            options = options || {};
            if (options.dispose) {
              _seppuku();
            }
        }

        /**
         * This is a lifecycle function being called by tag.js on SPA newPage
         * after making the actual navigation.
         * In our case it will allow to check authentication in a new page (logout purpose in SPA)
         */
        function reinit() {
            // Trigger an authentication error so that we will re-authenticate.
            // If we're on an authenticated page - all is well. If we're not - we show the authentication error.
            var getClickedChannel = appConfigurationManager && appConfigurationManager.getClickedChannel;
            var authChannel = getClickedChannel && getClickedChannel({async: true});
            var channel = conf.clickedChannel;
            if ( channel && authChannel &&
                (channel === authChannel || conf.isConvoSteppedUp) &&
                !conf.poppedOut && !conf.external
            ) {
                events.trigger({
                    appName: '*',
                    eventName: lpTag.unifiedWindow.events.chat.AUTHENTICATION_ERROR,
                    data: {
                        error: lpTag.unifiedWindow.consts.authErrorsTypes.LOGOUT
                    }
                });
            } else {
                _resetIfStepUp();
            }
        }

        function _configureSecureStorage() {
            var secureStorageConf = {
                debug: conf.debug
            };

            secureStorageConf[APP] = {
                site: conf.accountId,
                env: conf.env,
                app: APP,
                url: conf.secureStorageLocation,
                firstParty: true,
                disableFirstPartyGlobalConfig: conf.disableFirstPartyGlobalConfig,
                chosenStorageHandler: _onStorageConfigured
            };
            secureStorage.configure(secureStorageConf);
        }


        function _getConfigError(conf) {
            var errorType;
            if (conf.invalidAuthConnector) {
                errorType = wrapperWindow.Messages.SESSION_EXPIRED;
            } else if (conf.JsLoadingFailure) {
                errorType = wrapperWindow.Messages.CONNECTION_UNAVAILABLE;
            } else if (window.location.hash === "#RIP") {
                errorType = wrapperWindow.Messages.RIP;
            }
            return errorType;
        }

        function _initConfig(cfg) {

            //if we are on external, take the configuration from the url params
            if (lpTag.getExternalConfig) {
                conf = lpTag.getExternalConfig();
            }

            _convertTagletConfig(cfg);
        }


        function _convertTagletConfig(cfg) {
            if (cfg && cfg.constructor === Array) {
                try {
                    util.convertConfig(cfg, conf);
                } catch (ex) {
                    //<excludeFromBuild>
                    log.error("Failed to parse taglet configuration", name);
                    //</excludeFromBuild>
                }

                conf.displayShortlyMessage = _displayShortlyMessage();
            } else if (cfg) {
                // on dev environment conf object is passed
                conf = util.cloneExtend(conf, cfg, true);
            }
        }

        function _displayShortlyMessage() {
            var displayShortlyMessage = conf.textCustomization && conf.textCustomization[0] && conf.textCustomization[0].displayShortlyMessage;
            return displayShortlyMessage === true || displayShortlyMessage === "true";
        }

        function _onStorageConfigured(storageName) {
            //<excludeFromBuild>
            log.info("storage configured: " + JSON.stringify(storageName), name);
            //</excludeFromBuild>
            _initSessionManager(storageName, _initByStorage.bind(this, storageName));

        }

        function startFlow(engConf) {

            //This is a hack to prevent from lpPersistenceModel to duplicate acrValues data
            //TODO: check why this is happening
            engConf = _removeAcrValuesIfExist(engConf);

            //<excludeFromBuild>
            log.info("started flow: " + JSON.stringify(engConf), name);
            //</excludeFromBuild>
            artificialClick = true;
            if (engConf.redirect || typeof conf.embeddedSupported !== "undefined") { //UW redirect page or secure storage initialised.
                clicked(engConf);
            } else {
                conf.startedEngConf = engConf;
                // Add the channel for offsite engagement - so the session manager knows which channel/timeout to use
                conf.clickedChannel = appConfigurationManager.getClickedChannel(engConf, true);
            }
        }

        function clicked(engConf) {
            var engagementChannelType,
                currentChannel,
                externalTarget,
                allowedToMaximize;
            //<excludeFromBuild>
            log.info("clicked: " + JSON.stringify(engConf), name);
            //</excludeFromBuild>

            //This is a hack to prevent from lpPersistenceModel to duplicate acrValues data
            //TODO: check why this is happening
            engConf = _removeAcrValuesIfExist(engConf);

            // preChat convertion to object. lpmodel bug - cant save arrays. to be removed
            if (engConf && engConf.preChatLines) {
                engConf.preChatLines = _convertPreChatToObject(engConf.preChatLines);
            }

            conf.clickedChannel = appConfigurationManager.getClickedChannel(engConf);

            if (engConf.accountSettings) {
                accountSettings = engConf.accountSettings;
            }
            // need to reset values if consumer clicked on engagement except
            // UW is already opened and consumer clicks engagement in background
            if (conf.isStepUpDuringWaitingStateEnabled) {
                if (!artificialClick && !appStarted) {
                    conf.isConvoSteppedUp = false;
                    conf.wasAuthConnectorAppliedForStepUp = false;
                    _setWaitingStateStepUpData({
                        wasAuthConnectorAppliedForStepUp: false,
                        isConvoSteppedUp: false
                    });
                    isStartingApplicationFromStorageState = false;
                }
                artificialClick = false;
            }

            if (appStarted && !initUIStateCommon.engConf.externalFailed) {
                allowedToMaximize = !initUIStateCommon || !initUIStateCommon.window || initUIStateCommon.window.maximized;
                if (unifiedWindow.Application && _isAppNotDisposed() && allowedToMaximize) {
                    events.trigger({
                        appName: name,
                        eventName: "maximize"
                    });
                }
                currentChannel = sessionManager.getCurrentSessionKey();
                if (conf.clickedChannel !== currentChannel) {
                    // Show the message to close/reopen the window
                    engagementChannelType = appConfigurationManager.getEngagementTypeByChannel(currentChannel);
                    events.trigger({
                        appName: name,
                        eventName: lpTag.unifiedWindow.events.chat.MULTIPLE_CHANNELS_REQUESTED,
                        data: {
                            channelType: engagementChannelType
                        }
                    });
                }
            } else if (browserStateManager.isConnected()) {
                if (_isAppDisposed()) {
                    _endApplication();
                }

                externalTarget = _getValidExternalTarget(engConf);

                if (externalTarget) {
                    _openWindowForExternalLaunch(engConf, externalTarget);
                } else if (conf.browserModeUnSupported) {
                    _initWrapperWindow();
                    lpWindowTranslatedError = wrapperWindow.Messages.UNSUPPORTED;
                    _analyzeState(_clickStateCallbackError.bind(this, engConf));
                } else {
                    _initWrapperWindow();
                    _analyzeState(_clickStateCallback.bind(this, engConf));
                }
            } else {//No connection
                _initWrapperWindow();
                lpWindowTranslatedError = wrapperWindow.Messages.CONNECTION_UNAVAILABLE;
                _analyzeState(_clickStateCallbackError.bind(this, engConf));
            }
        }

        function _analyzeState(cb, focus) {
            if (focus) {
                _initWrapperWindow();
            }

            _initSessionManager(null, function () {
                stateAnalyzer.getState(cb, cb);
            });
        }

        function inspect() {
            //<excludeFromBuild>
            log.info("inspect", name);
            //</excludeFromBuild>

            return {
                conf: util.clone(conf)
            };
        }

        function _initByStorage(storageName) {
            if (typeof storageName !== 'object') {
                conf.secureStorageType = storageName;
            } else if (storageName && storageName.error) {
                conf.browserModeUnSupported = true;
            }
            selectedStorageType = storageName; // save selected storage for future use
            // We only support popout in case we have a valid secure storage and not session storage
            conf.popoutSupported = conf.secureStorageType &&
                conf.secureStorageType !== secureStorage.storageTypes.SESSIONSTORAGE &&
                browserStateManager.visibilitySupported();
            // We only support embedded state in case we have a valid secure storage
            conf.embeddedSupported = !!conf.secureStorageType;

            events.trigger({
                appName: name,
                eventName: STORAGE_SELECTED_EVENT,
                global: true
            });
            _manage();
        }

        function _initWrapperWindow() {
            if (!wrapperWindow) {
                wrapperWindow = new unifiedWindow.WrapperWindow(conf, deviceDetector, browserStateManager, events, _onWindowClose);
                conf.wrapperElementId = wrapperWindow.getWrapperElementId();
            }
        }

        function _initSessionManager(name, cb) {
            if (!sessionManager) {
                sessionManager = _createSessionManager();
            }

            if (conf.clickedChannel) {
                sessionManager.setClickedSession(conf.clickedChannel);
            }

            sessionManager.getSessionId(_initStateAnalyzer.bind(this, name, cb));
        }

        function _createSessionManager() {
            return new unifiedWindow.SessionManager({
                accountId: conf.accountId,
                sessionId: conf.sessionId,
                external: conf.external,
                events: events,
                sessionsPriority: appConfigurationManager.getChannelsPriority(conf),
                sessions: appConfigurationManager.getChannels(conf),
                clickedSession: conf.clickedChannel,
                secureStorageLocation: conf.secureStorageLocation,
                echoedSessionTimeout: conf.sessionTimeout
            });
        }

        function _initStateAnalyzer(name, cb, sid) {
            if (sid) {
                conf.sessionId = sid;
                if (!stateAnalyzer) {
                    stateAnalyzer = new unifiedWindow.StateAnalyzer({
                        storageKey: conf.sessionId,
                        accountId: conf.accountId,
                        disableSessionTimeout: conf.disableSessionTimeout,
                        secureStorageLocation: conf.secureStorageLocation
                    }, sessionManager);
                }
            } else {
                if (!_isExternal() && pkceManager) {
                    pkceManager.getPKCEFromSecureStorage(function (value) {
                        if(value && value.code_verifier && value.engConfig) {
                            log.debug('Successfully retrieved PKCE value from secure storage');
                            clicked(value.engConfig);
                        }
                    });
                }
            }
            util.runCallback(cb, null, name);
        }

        function _openWindowForExternalLaunch(engConf, externalTarget) {
            windowConfIfExternalFailed = engConf.windowConf;
            switch(externalTarget.type) {
                case EXTERNAL_TARGET.TAP_TO_TEXT:
                    _openWindowForSMSClientLaunch(engConf, externalTarget.target);
                    break;
                case EXTERNAL_TARGET.POPOUT:
                    _openWindow(engConf);
                    break;
                default:
                    _openWindow(engConf);
                    break;
            }

            if (!conf.openedExternal && conf.showMinimizedIfExternalBlocked) {
                engConf.minimiseOnStart = true;
                engConf.externalFailed = true;
                engConf.externalConfIfFailed = externalConfIfFailed;
                _initWrapperWindow();
                _analyzeState(_clickStateCallback.bind(this, engConf));
                return;
            }
            engConf.externalFailed = false;
            if (lpTag.hooks && lpTag.hooks.exec) {
                lpTag.hooks.exec({
                    name: HOOKS.ON_EXTERNAL_LAUNCH,
                    data: {
                        type: externalTarget.type,
                        engConf: engConf,
                        externalTarget: externalTarget
                    }
                });
            }
        }

        function _openWindowForSMSClientLaunch(engConf, tapToTextConf) {

            //<excludeFromBuild>
            log.info("_openWindowForSMSClientLaunch", name);
            //</excludeFromBuild>

            var strWindowFeatures = "menubar=no, location=no, resizable=false, scrollbars=no, status=yes, width=280px, height=400px, modal=true",
                url = "";

            var smsConf = {
                launchProperties: _getSMSClientLaunchProperties(tapToTextConf),
                smsAPI: lpTag.csds.getDomain(CSDS.SMS_API)
            };

            url = appConfigurationManager.getSMSClientLaunchResourceURL(engConf, conf, smsConf);

            externalConfIfFailed = {
                url: url
            };
            conf.openedExternal = window.open(url, engConf.target + "POP", strWindowFeatures);
        }

        function _openWindow(engConf) {
            //<excludeFromBuild>
            log.info("_openWindow", name);
            //</excludeFromBuild>
            try {
                var externalWindowUrlCodeRepo = conf.staticCodeRepository + (engConf.resource || "/index.html");
                var externalOriginDetails = appConfigurationManager.getURLBreakdownInfo(externalWindowUrlCodeRepo);
                var parentOriginDetails = appConfigurationManager.getURLBreakdownInfo(window.location.href);
                externalOrigin = (("https://" + externalOriginDetails.hostname) + ((externalOriginDetails && externalOriginDetails.port && externalOriginDetails.port !== "") ? ":" + externalOriginDetails.port : ""));
                parentWindowOrigin = (("https://" + parentOriginDetails.hostname) + ((parentOriginDetails && parentOriginDetails.port && parentOriginDetails.port !== "") ? ":" + parentOriginDetails.port : ""));
            } catch (e) {
                //<excludeFromBuild>
                log.error("_openWindow", "Error while getting externalWindowOrigin continuing");
                //</excludeFromBuild>
            }

            if (engConf.redirect || (_isStarted() && _isMobileNotOptimized())) {
                window.location.href = appConfigurationManager.getExternalResourceURL(engConf, conf, false);
            } else {
                //This flag indicates not to open an embedded window when external is already open - will hold only until refresh
                // Appending parent window origin params to the external window for security
                var urlWithParentWindowOriginParam = ((appConfigurationManager.getExternalResourceURL(engConf, conf, false)) + ((parentWindowOrigin && parentWindowOrigin !== '') ? "&parentWindowOrigin=" + parentWindowOrigin :''));
                externalConfIfFailed = {
                    url: urlWithParentWindowOriginParam
                };

                if (engConf.connector && engConf.connector.configuration && engConf.connector.configuration.pkceEnabled) {
                    var originalExternalURL = encodeURIComponent(urlWithParentWindowOriginParam);
                    var query = appConfigurationManager.getQueryString(urlWithParentWindowOriginParam);
                    var redirectUri = (new window.URLSearchParams(query)).get("redirect_uri");
                    conf.openedExternal = appConfigurationManager.openExternal(engConf, redirectUri + "?originalURL=" + originalExternalURL);
                } else {
                    conf.openedExternal = appConfigurationManager.openExternal(engConf, urlWithParentWindowOriginParam);
                }
            }
        }

        function _getValidExternalTarget(engConf) {
            if(engConf.externalTargets) {
                var externalTarget = engConf.externalTargets[EXTERNAL_TARGET_ID.SMS];
                if(externalTarget && externalTarget.brandIdentifier && deviceDetector.canAttemptSMSClientLaunch() &&
                    externalTarget.deflectionTargetProperties && externalTarget.deflectionTargetProperties.tapToText) {

                    return { type: EXTERNAL_TARGET.TAP_TO_TEXT, target: externalTarget };
                }
            }

            if(_isExternalRequired(engConf)) {
                return { type: EXTERNAL_TARGET.POPOUT, target: engConf };
            }
        }

        function _isExternalRequired(engConf) {
            return (!conf.embeddedSupported || engConf.isPopOut || _isMobileNotOptimized() || appConfigurationManager.isRecaptchaEnabled() || _isExternalFallback(engConf));
        }

        function _isExternalFallback(engConf) {
            return _isSessionStorage() && _isExternalFallbackConfigured(engConf) && deviceDetector.isDesktop();
        }

        function _isExternalFallbackConfigured() {
            return _checkSetting(settingsID.EXTERNAL_FALLBACK, "true", "false");
        }

        function _checkSetting(id, value, defaultValue) {
            var feature = accountSettings && accountSettings.filter(function (setting) {
                return setting.id === id;
            });
            return feature && feature.length > 0 && util.getPropertyFromObject(feature[0], "propertyValue.value", defaultValue) === value;
        }

        function _isSessionStorage() {
            return secureStorage.getStorageType(conf.secureStorageLocation)[APP] === secureStorage.storageTypes.SESSIONSTORAGE;
        }

        function _isExternal() {
            return conf.poppedOut || conf.external;
        }

        function _isMobileNotOptimized() {
            return !deviceDetector.isMobileOptimized() && !deviceDetector.isDesktop();
        }

        // the function checks if the click should be forced
        function _isStarted() {
            return conf.startedEngConf;
        }

        function _manage() {
            //<excludeFromBuild>
            log.info("_manage", name);
            //</excludeFromBuild>
            _getWaitingStateStepUpData(function (data) {
                if (data) {
                    conf.wasAuthConnectorAppliedForStepUp = data.wasAuthConnectorAppliedForStepUp;
                    conf.isConvoSteppedUp = data.isConvoSteppedUp;
                }
            });
            if (stateAnalyzer) {
                stateAnalyzer.getState(_startStateCallback, _startStateCallback);
            } else {
                _updateStepUpCheckedStatus(false);
            }
        }

        function _resolveProperStates(data, state, engConf) {
            if (_isExternalOpen()) {
                //<excludeFromBuild>
                log.info("_clickStateCallback: external / popped out window is open", name);
                //</excludeFromBuild>
                _showWrapperWindowError(wrapperWindow.Messages.EXTERNAL_OPEN, true);

            } else {

                if (conf.poppedOut) {
                    // StateAnalyzer might mistakenly return EXPIRED state, due to an old cookie,
                    // so state should be IN_SESSION in order to prevent the disposal of the window.
                    state = stateAnalyzer.state.IN_SESSION;
                }

                currentState = state;

                switch (state) {
                    case stateAnalyzer.state.INVALID:
                        //<excludeFromBuild>
                        log.info("_clickStateCallback: is INVALID state, nothing to do", name);
                        //</excludeFromBuild>
                        _dispose();
                        return;
                    case stateAnalyzer.state.IN_SESSION:
                        return {uiState: data}; //No configuration - resume session
                    case stateAnalyzer.state.NOT_STARTED:
                        return engConf ? {engConf: engConf} : void 0;
                    case stateAnalyzer.state.EXPIRED:
                        _dispose();
                        return null;
                }

                //<excludeFromBuild>
                log.error("_resolveProperStates: BUG - undefined state", name);
                //</excludeFromBuild>
            }
        }

        function _isExternalOpen() {
            if (conf.openedExternal) {
                if (!conf.openedExternal.closed) {
                    return true;
                }
                else {
                    conf.openedExternal = void 0;
                    delete conf.openedExternal;
                }
            }
            return false;
        }

        function _getSMSClientLaunchProperties(configuration) {

            var props = {};

            props.phoneNumber = configuration.brandIdentifier;

            if( configuration.deflectionTargetProperties &&
                typeof configuration.deflectionTargetProperties.message === 'string' &&
                configuration.deflectionTargetProperties.message !== "")
            {
                var message = decodeURIComponent(configuration.deflectionTargetProperties.message);
                if(deviceDetector.isIOS()) {
                    if(deviceDetector.isIOS8OrAbove()) {
                        props.message = '&body=' + message;
                    }
                    else {
                        props.message = ';body=' + message;
                    }
                }
                else {
                    props.message = '?body=' + message;
                }
            }
            else {
                props.message = "";
            }

            return props;
        }

        function _startStateCallback(data, state) {
            //<excludeFromBuild>
            log.info("_startStateCallback", name);
            //</excludeFromBuild>
            var resolvedStates = _resolveProperStates(data, state);

            if (conf.external) {
                if (resolvedStates && resolvedStates.uiState && resolvedStates.uiState.chat && resolvedStates.uiState.chat.state === CHAT_ENDED) {
                    resolvedStates.uiState = {engConf: resolvedStates.uiState.engConf};
                }

                _startApplication(resolvedStates || conf);
                return;
            }

            if (resolvedStates) {
                isStartingApplicationFromStorageState = true;
                if (!conf.engConf && resolvedStates && resolvedStates.uiState && resolvedStates.uiState.engConf) {
                    conf.clickedChannel = appConfigurationManager.getClickedChannel(resolvedStates.uiState.engConf, true);
                }
                if (browserStateManager.isConnected()) {
                    _startApplication(resolvedStates);
                } else {
                    _showWrapperWindowError(wrapperWindow.Messages.CONNECTION_UNAVAILABLE);
                }
                return;
            }

            if (_isStarted()) {
                clicked(conf.startedEngConf);
                return;
            }

            // check PKCE data, if config found call clicked with conf
            if (!_isExternal() && pkceManager) {
                pkceManager.getPKCEFromSecureStorage(function (value) {
                    if(value && value.code_verifier && value.engConfig) {
                        log.debug('Successfully retrieved PKCE value from secure storage');
                        clicked(value.engConfig);
                    }
                });
            }

            _updateStepUpCheckedStatus(false);
        }

        function _clickStateCallback(engConf, data, state) {
            //<excludeFromBuild>
            log.info("_clickStateCallback", name);
            //</excludeFromBuild>
            var resolvedStates = _resolveProperStates(data, state, engConf);
            if (resolvedStates) {
                _startApplication(resolvedStates);
            } else {
                _updateStepUpCheckedStatus(false);
            }
        }

        function _clickStateCallbackError(engConf, data, state) {
            //<excludeFromBuild>
            log.info("_clickStateCallbackError", name);
            //</excludeFromBuild>
            var resolvedStates = _resolveProperStates(data, state, engConf);

            if (resolvedStates) {
                _startApplication(resolvedStates,true,lpWindowTranslatedError);
            }
        }

        function _loadingCompleted(initUIState) {
            /** the application check is to avoid duplicate application instantiation **/
            initUIStateCommon = initUIState;
            if (windowConfig && accountSettings && true === appFilesReady && wrapperWindowRendered && !application) {
                var configs = {
                    window: windowConfig,
                    unified: conf,
                    uiState: initUIState,
                    accountSettings: accountSettings
                };
                //<excludeFromBuild>
                log.info("_loadingCompleted, config: " + JSON.stringify(configs), name);
                //</excludeFromBuild>

                // Start the session touch - refresh
                sessionManager.refresh(_initApplication.bind(this, configs));
            } else {
                //<excludeFromBuild>
                log.info("_loadingCompleted: still missing data/files", name);
                //</excludeFromBuild>
            }
        }

        function _initApplication(configs) {
            _waitUntilAsyncFrameworkLoaded(function () {
                _createApplication(configs);
            });
        }

        function _createApplication(configs) {
            if (_shouldAuthConnectorBeAppliedForStepUp(configs)) {
                    isApplicationRestartingInWaitingState = false;
                    _getConnectorsAndApplyAuth(configs, function () {
                        _createApplicationInstance(configs);
                    });
            } else {
                _createApplicationInstance(configs);
            }
        }

        /**
         * Checks if all conditions are met to replace unauth connector with auth one. That is needed to
         * step up before conversation started in waiting state
         * @param configs - configuration store with all configs we operate with in UW. uiState.chat.state and
         * uiState.engConf.connector from there are used in this function.
         * @returns {boolean|*|boolean} true if all conditions satisfied
         * @private
         */
        function _shouldAuthConnectorBeAppliedForStepUp(configs) {
            if (!isStepUpDuringWaitingStateEnabled) {
                return false;
            }
            var isWaitingState = configs && configs.uiState && configs.uiState.chat && configs.uiState.chat.state === "waiting";
            var connector = configs.uiState && configs.uiState.engConf && configs.uiState.engConf.connector;
            var startMatch = ((isStartingApplicationFromStorageState && isWaitingState) || isApplicationRestartingInWaitingState || conf.isConvoSteppedUp);
            var isConnectorUnauth = connector && !_isAuthConnector(connector);
            return isStepUpDuringWaitingStateEnabled && startMatch && isConnectorUnauth && (_stepUpIdentities() || conf.wasAuthConnectorAppliedForStepUp);
        }

        function _createApplicationInstance (configs) {
            application = unifiedWindow.Application(configs, {
                appConfigurationManager: appConfigurationManager,
                pkceManager: pkceManager,
                browserStateManager: browserStateManager,
                sessionManager: sessionManager,
                deviceDetector: deviceDetector,
                wrapperWindow: wrapperWindow,
                events: events
            });
        }

        function _windowConfigLoaded(initUIState, cb, windowConf) {
            //<excludeFromBuild>
            log.info("_windowConfigLoaded", name);
            //</excludeFromBuild>

            if (!windowConf || windowConf.error) {
                _showWrapperWindowError(wrapperWindow.Messages.CONNECTION_UNAVAILABLE);
                //<excludeFromBuild>
                log.error("_windowConfigLoaded: Cannot load configuration", name);
                //</excludeFromBuild>
                return;
            }

            windowConfig = windowConf;
            if (windowConfig.windowSize) {
                initUIState.window.size = windowConfig.windowSize;
            }
            if (windowConfig.floatingWindow) {
                initUIState.window.floating = windowConfig.floatingWindow;
            }
            cb(initUIState);
        }

        function _accountSettingsLoaded(initUIState, settings) {
            //<excludeFromBuild>
            log.info("_accountSettingsLoaded", name);
            //</excludeFromBuild>

            accountSettings = settings;
            _loadingCompleted(initUIState);
        }

        function _appLoaded(initUIState, error) {
            //<excludeFromBuild>
            log.info("_appLoaded", name);
            //</excludeFromBuild>
            if (error) {
                _showWrapperWindowError(wrapperWindow.Messages.CONNECTION_UNAVAILABLE);
                _dispose();
                //<excludeFromBuild>
                log.error("_appLoaded: Cannot load application", name);
                //</excludeFromBuild>
                return;
            }
            appFilesReady = true;
            _loadingCompleted(initUIState);
        }

        function _startApplication(options,isErrorType,_message,keepError) {
            //<excludeFromBuild>
            log.info("_startApplication", name);
            //</excludeFromBuild>
            var initUIState;

            if (appStarted) {
                return;
            }
            appStarted = true;
            log.triggerEvent(log.events.APP_STARTED);

            windowConfig = options && options.engConf && options.engConf.windowConf;
            accountSettings = options && options.engConf && options.engConf.accountSettings;

            if (Array.isArray(accountSettings) && accountSettings.length > 0) {
                delete options.engConf.accountSettings;
            } else {
                accountSettings = null;
            }

            var opts = {
                storageKey: conf.sessionId,
                accountId: conf.accountId,
                secureStorageLocation: conf.secureStorageLocation,
                domain: isFetchEnabled ? conf.acCdnDomainConsumerSdk : conf.acCdnDomain,
                initialConf: conf
            };

            if (options.uiState) {
                initUIState = options.uiState;
                initUIState.engConf.sessionKey = sessionManager.getCurrentSessionKey();
                if (initUIState.engConf && typeof (initUIState.engConf.lewid) !== "undefined") {
                    opts.windowId = initUIState.engConf.lewid;
                    if(initUIState.engConf.subscription && initUIState.engConf.subscription.provideraccountid) {
                        opts.accountId = initUIState.engConf.subscription.provideraccountid;
                    }
                }
                windowConfigurationManager = new unifiedWindow.WindowConfigurationManager(opts);
                windowConfigurationManager.getConf(_windowConfigLoaded.bind(this, initUIState, _loadingCompleted));
                _renderWrapperWindow.call(this, initUIState, isErrorType, _message, keepError);
            } else {
                initUIState = util.cloneExtend(defaultUIState);
                initUIState.engConf = options.engConf;
                initUIState.engConf.sessionKey = sessionManager.getCurrentSessionKey();
                if (initUIState.engConf && typeof (initUIState.engConf.lewid) !== "undefined") {
                    opts.windowId = initUIState.engConf.lewid;
                    if(initUIState.engConf.subscription && initUIState.engConf.subscription.provideraccountid) {
                        opts.accountId = initUIState.engConf.subscription.provideraccountid;
                    }
                }
                if (options.engConf && options.engConf.minimiseOnStart) {
                    initUIState.window.maximized = false;
                }
                windowConfigurationManager = new unifiedWindow.WindowConfigurationManager(opts);
                if (windowConfig) {
                    delete options.engConf.windowConf;
                    if (windowConfig.windowSize) {
                        initUIState.window.size = windowConfig.windowSize;
                    }
                    if (windowConfig.floatingWindow) {
                        initUIState.window.floating = windowConfig.floatingWindow;
                    }

                    _windowConfigLoaded.call(this, initUIState, _loadingCompleted, windowConfig);
                    _renderWrapperWindow.call(this, initUIState, isErrorType, _message, keepError);
                } else {
                    if (initUIState.engConf && typeof (initUIState.engConf.lewid) !== "undefined") {
                        opts.windowId = initUIState.engConf.lewid;
                    }
                    windowConfigurationManager.getConf(_windowConfigLoaded.bind(this, initUIState, function(state) {
                        _renderWrapperWindow.call(this, state, isErrorType, _message, keepError);
                    }));
                }
            }

            accountSettingsManager = new unifiedWindow.AccountSettingsManager(opts);

            if (accountSettings) {
                _accountSettingsLoaded.call(this, initUIState, accountSettings);
            } else {
                accountSettingsManager.getSettings(_accountSettingsLoaded.bind(this, initUIState));
            }

            _loadFramework(_appLoaded.bind(this, initUIState), initUIState);

        }

        function _renderWrapperWindow(initUIState, isErrorType, _message, keepError) {
            if(isErrorType){
                wrapperWindow.render(initUIState, function () {
                    wrapperWindow.message(_message, true);
                }, true);
            } else {
                wrapperWindow.render(initUIState, function () {
                    wrapperWindowRendered = true;
                    wrapperWindow.message(wrapperWindow.Messages.WAIT);

                    _loadingCompleted(initUIState);
                }, true);
            }
            if(isErrorType){
                if (!keepError && !_isExternal()) {
                    wrapperWindowErrorTimeoutId = setTimeout(function () {
                        if (wrapperWindow) {
                            wrapperWindow.dispose();
                        }
                    }, errorTimeout);
                }
            }
        }

        function _getDeviceClass (deviceDetector) {
            var touchPointClass = LPCssCustomizationClasses.NAMESPACE + '_';
            if (deviceDetector.isMobile()) {
                touchPointClass += LPCssCustomizationClasses.MOBILE_CSS_CLASS;
            } else if (deviceDetector.isTablet()) {
                touchPointClass += LPCssCustomizationClasses.TABLET_CSS_CLASS;
            } else {
                touchPointClass += LPCssCustomizationClasses.DESKTOP_CSS_CLASS;
            }

            return touchPointClass;
        }

        function _configureFrameworkLocations(engConf) {
            conf.isMessaging = !!engConf.async;
            var loadObj = {};
            var apiLocation = conf.isMessaging ? "UMSClientAPI" : "lpChatV3";

            if (!unifiedWindow.Application) {
                loadObj = conf.loadObj || {};
                loadObj.api = conf.codeRepository + "/" + apiLocation + ".min.js" + cacheBusterVer;
                // if preload is disabled, then "framework" and "unified" need to be loaded now
                if (_isPreloadDisabled()) {
                    var deviceFamilyName = deviceDetector.getDeviceFamilyName().toLowerCase();
                    loadObj.framework = conf.codeRepository + "/ui-framework.js" + cacheBusterVer;
                    loadObj.surveyLogic = conf.codeRepository + "/surveylogicinstance.min.js" + cacheBusterVer;
                    loadObj.unified = {
                        dependency: ["framework", "api", "surveyLogic"],
                        url: conf.codeRepository + "/" + deviceFamilyName + "Embedded.js" + cacheBusterVer
                    };
                }
                requestedAPIs[apiLocation] = true;
            } else if (!application && !requestedAPIs[apiLocation]) {
                loadObj = conf.loadObj || {api: conf.codeRepository + "/" + apiLocation + ".min.js" + cacheBusterVer};
            }

            if (_isExternal()) {
                tagDomain = _getTagDomain();
                lpTag.ovr = lpTag.ovr || {domain: tagDomain};
                lpTag.debug = conf.debug ? "2" : "1";
            }

            if (engConf && engConf.lang && engConf.lang.toLowerCase() !== "en-us") {
                loadObj.lang = conf.langRepository + "/" + engConf.lang + ".js" + cacheBusterVer;
            }

            if (!_isExternalRequired(engConf) && appConfigurationManager.isAuthenticatedEnabled(engConf)) {
                loadObj.xhr = conf.codeRepository + "/xhr.js" + cacheBusterVer;
            }

            if (conf.widgetSDK) {
                loadObj.widgetSDK = "https://" + conf.leCdnDomain + "/unifiedwindow/widgetSDK.min.js" + cacheBusterVer;
            }

            return loadObj;
        }

        function _startLoadFramework(loadObj, callback) {
            //<excludeFromBuild>
            log.info("_startLoadFramework, loading: " + JSON.stringify(loadObj), name);
            //</excludeFromBuild>

            if (util.isEmpty(loadObj)) {
                //<excludeFromBuild>
                log.info("_startLoadFramework: Application exists, starting", name);
                //</excludeFromBuild>
                util.runCallback(callback);
            } else {
                //<excludeFromBuild>
                log.info("_startLoadFramework: Loading files", name);
                //</excludeFromBuild>
                lpTag.taglets.jsLoader.loadJS({
                    loadObj: loadObj,
                    success: function () {
                        //<excludeFromBuild>
                        log.info("_startLoadFramework: Files loaded", name);
                        //</excludeFromBuild>
                        _waitUntilAsyncFrameworkLoaded(function () {
                            util.runCallback(callback);
                        });
                    },
                    error: function (errorData) {
                        //<excludeFromBuild>
                        log.error("_startLoadFramework: Error Loading files " + JSON.stringify(errorData), name);
                        //</excludeFromBuild>
                        _waitUntilAsyncFrameworkLoaded(function () {
                            util.runCallback(callback, null, errorData || {});
                        });
                    }
                });
            }
        }

        function _loadFramework(callback, initUIState) {
            //<excludeFromBuild>
            log.info("_loadFramework", name);
            //</excludeFromBuild>

            var loadObj = _configureFrameworkLocations(initUIState.engConf);

            if (!stylesAttached) {
                _loadStyles();
            }

            if (!lpTag.tagletsPrecomputed && lpTag.loadTaglets && !_isExternal()) {
                _loadTagletsFromService(loadObj, callback);
            } else if (lpTag.tagletsPrecomputed && lpTag.load && !_isExternal()) {
                _loadTagletsFromCdn(loadObj, callback);
            } else {
                _startLoadFramework(loadObj, callback);
            }
        }

        function _loadTagletsFromCdn(loadObj, callback) {
            var url = lpTag.protocol + "//" + ((lpTag.ovr && lpTag.ovr.domain) ? lpTag.ovr.domain : "cdn.lpsnmedia.net") + "/api/account/" + lpTag.site + "/taglets/scopes/unifiedwindow/onwindowload";
            try {
                lpTag.load(url, "UTF-8", lpTag.cfg.scriptPrefix + lpTag.cfg.count);
                //<excludeFromBuild>
                log.info("_loadFramework: Precomputed taglets loaded from CDN", name);
                //</excludeFromBuild>
                _startLoadFramework(loadObj, callback);
            } catch (errorData) {
                //<excludeFromBuild>
                log.error("_loadFramework: Error Loading taglets" + JSON.stringify(errorData), name);
                //</excludeFromBuild>
                util.runCallback(callback, null, errorData || {});
            }
        }

        function _loadTagletsFromService(loadObj, callback) {
            lpTag.loadTaglets({
                scp: conf.scp,
                excludeWhitelist: true,
                success: function () {
                    //<excludeFromBuild>
                    log.info("_loadFramework: Taglets loaded from LPTag service", name);
                    //</excludeFromBuild>
                    _startLoadFramework(loadObj, callback);
                },
                error: function (errorData) {
                    //<excludeFromBuild>
                    log.error("_loadFramework: Error Loading taglets" + JSON.stringify(errorData), name);
                    //</excludeFromBuild>
                    util.runCallback(callback, null, errorData || {});
                }
            });
        }

        function _loadFrameworkAsync() {
            _addAsyncScript(conf.codeRepository + "/ui-framework.js" + cacheBusterVer, 'lp-ui-framework');
            _addAsyncScript(conf.codeRepository + "/surveylogicinstance.min.js" + cacheBusterVer, 'lp-survey-logic');
        }

        function _waitUntilAsyncFrameworkLoaded (callback) {
            var waitDelay = 50;
            var waitInterval;
            if ((_isPreloadDisabled() || scriptsAsyncLoaded === scriptsNumberToLoadAsync) && stylesLoaded) {
                callback();
            } else {
                waitInterval = setInterval(function () {
                    if ((scriptsAsyncLoaded === scriptsNumberToLoadAsync || _isPreloadDisabled()) && stylesLoaded) {
                        clearInterval(waitInterval);
                        callback();
                    }
                }, waitDelay);
            }
        }

        function _addAsyncScript(src, scriptID) {
            var existingScript = document.getElementById('#' + scriptID);
            if (existingScript) {
                return;
            }
            var script = document.createElement('script');
            script.async = true;
            script.id = scriptID;
            script.src = src;
            script.setAttribute('charset', 'utf-8');
            document.querySelector('head').appendChild(script);
            script.onload = function () {
                scriptsAsyncLoaded++;
                if (scriptID === 'lp-ui-framework') {
                    //uiframework is a dependency for [mobile|desktop]Embedded.js so loading embedded only after the framework
                    var deviceFamilyName = deviceDetector.getDeviceFamilyName().toLowerCase();
                    _addAsyncScript(conf.codeRepository + "/" + deviceFamilyName + "Embedded.js" + cacheBusterVer, 'lp-uw-embedded');
                }
            };
            script.onerror = function () {
                scriptsAsyncLoaded++;
            };
        }

        function _setSiteAndDebug(conf) {
            //<excludeFromBuild>
            log.info("_setSiteAndDebug: " + JSON.stringify(conf), name);
            //</excludeFromBuild>

            conf.accountId = "" + (conf.accountId || lpTag.site);

            conf.domain = lpTag.csds.getDomain(CSDS.ADMIN_AREA) || lpTag.csds.getDomain(CSDS.ALL);
            conf.domain = conf.domain === "hc1" ? "hc1.dev.lprnd.net" : conf.domain;

            conf.env = conf.env || _getEnv();

            conf.asyncMessagingDomain = lpTag.csds.getDomain(CSDS.ASYNC_MESSAGING);
            conf.idpDomain = lpTag.csds.getDomain(CSDS.IDP);
            conf.shiftStatusDomain = lpTag.csds.getDomain(CSDS.SHIFT_STATUS);
            conf.messagingHistoryDomain = lpTag.csds.getDomain(CSDS.MESSAGING_HISTORY);

            conf.debug = _isDebug();
        }

        function _getEnv() {
            return (typeof lpTag.getEnv === "function" && lpTag.getEnv());
        }

        function _getTagDomain() {
            return (typeof lpTag.getTagDomain === "function" && lpTag.getTagDomain(conf.env));
        }

        function _isDebug() {
            return conf.debug ||
                conf.accountId && (conf.accountId.indexOf("qa") === 0 || conf.accountId.indexOf("le") === 0) ||
                conf.domain && conf.domain.indexOf("hc1") === 0;
        }

        /**
         * Initializes the default values for the configuration
         * @private
         */
        function _initDefaultValues(conf, data) {
            var path,
                unifiedWindowLocation,
                staticLocation,
                secureStorageLocation;

            //<excludeFromBuild>
            log.info("_initDefaultValues: " + JSON.stringify({conf: conf, data: data}), name);
            //</excludeFromBuild>

            conf.leCdnDomain = _isDomainSafe(conf.leCdnDomain, domainWhitelist.LECDN) ? conf.leCdnDomain : lpTag.csds.getDomain(CSDS.LECDN);
            conf.acCdnDomain = _isDomainSafe(conf.acCdnDomain, domainWhitelist.ACCDN) ? conf.acCdnDomain : lpTag.csds.getDomain(CSDS.ACCDN);
            conf.acCdnDomainConsumerSdk = _isDomainSafe(conf.acCdnDomainConsumerSdk, domainWhitelist.ACCDN) ? conf.acCdnDomainConsumerSdk : lpTag.csds.getDomain(CSDS.ACCDN_CONSUMER_SDK);

            path = "https://" + conf.leCdnDomain + "/";
            staticLocation = "le_unified_window";
            unifiedWindowLocation = staticLocation + appConfigurationManager.getUWDir(conf, v);
            secureStorageLocation = path + "le_secure_storage/" + (secureStorage.v ? secureStorage.v + "/" : "");

            conf.staticCodeRepository = path + (conf.codeRepository ? conf.codeRepository : staticLocation);
            conf.codeRepository = path + (conf.codeRepository ? conf.codeRepository : unifiedWindowLocation);
            conf.imagesRepository = path + (conf.imagesRepository ? conf.imagesRepository : unifiedWindowLocation + "/resources");
            conf.iconsRepository = path + (conf.iconsRepository ? conf.iconsRepository : unifiedWindowLocation + "/resources/icons") + '/' + deviceDetector.getDeviceFamilyName().toLowerCase();
            conf.audioRepository = path + (conf.audioRepository ? conf.audioRepository : unifiedWindowLocation + "/resources/audio");
            conf.langRepository = path + (conf.langRepository ? conf.langRepository : unifiedWindowLocation + "/resources/i18n");
            conf.agentImageRepository = path + (conf.agentImageRepository ? conf.agentImageRepository : unifiedWindowLocation + "/resources/agentImages");
            conf.secureStorageLocation = conf.external ? secureStorage.sessionStorageStaticDomain : conf.secureStorageLocation || secureStorageLocation;
            conf.jsRepository = path + (conf.jsRepository ? conf.jsRepository : unifiedWindowLocation + "/resources/js");

            if (deviceDetector.isMobile() || deviceDetector.isTablet()) {
                data.position = {
                    right: 0
                };
            }

            data.window.embedded = !conf.external;

            function receiveMessage(event) {
                if (event && event.data && (typeof event.data === 'string') && (event.data.indexOf("LPExternalWindowClosed") > -1) && (event.origin && event.origin === externalOrigin)) {
                    _onWindowClose();
                }
            }
            window.addEventListener("message", receiveMessage, false);

            if(!data.window.embedded) {
                //THIS IS == on purpose, DO NOT CHANGE IT TO ===
                conf.NativeSDK = (queryParams.sdk == "1");
                conf.IOS = (queryParams.ios == "1");
            }

            conf.supportBlockCCPattern = !!lpTag.taglets.cleanCCPatterns;
            conf.scp = conf.scp || "uw";
        }

        function _isDomainSafe(domain, whitelist) {
            try {
                if (!domain || domain.length === 0) { return false; }
                if (domain.indexOf("https://") !== 0) {
                    domain = "https://" + domain; // protocol is required for using URL()
                }
                var baseDomain = new URL(domain).hostname.split(".").slice(-2).join(".");
                if ((whitelist || []).indexOf(baseDomain) < 0) {
                    log.info("Configured domain '" + domain + "' is not in whitelist.", name);
                    return false;
                }
            } catch (e) {
                log.error("Error checking if configured domain '" + domain + "' is in whitelist. Error message: " + e , name);
                return false;
            }
            return true;
        }

        function _showWrapperWindowError(_message, keepError) {
            if (wrapperWindowErrorTimeoutId) {
                clearTimeout(wrapperWindowErrorTimeoutId);
            }
            wrapperWindow.render(null, function showMessage() {
                wrapperWindow.message(_message, true);
            });

            if (!keepError && !_isExternal()) {
                wrapperWindowErrorTimeoutId = setTimeout(function () {
                    if (wrapperWindow) {
                        wrapperWindow.dispose();
                    }
                }, errorTimeout);
            }
        }

        function _bindToEvents() {
            browserStateManager.on(browserStateManager.EVENT_NAME.FOCUS_CHANGE, _analyzeStateOnFocus);
            events.bind({appName: "ChatStateManager", eventName: "ended", func: _dispose});
            events.bind({appName: "ConversationManager", eventName: "ended", func: _endApplication});
            events.bind({appName: "Application", eventName: "appEnded", func: _endApplication});
            events.bind({appName: "*", eventName: "doHaraKiri(Seppuku)", func: _disposeWrapperWindow});
            events.bind({appName: "SessionManager", eventName: "sessionChanged", func: _analyzeStateOnSessionChanged});
            events.bind({appName: "ChatAPIV3", eventName: "error", func: _handleError}); // todo: Remove this binding once messaging in master (and ChatAPIV3 event no longer fired)
            events.bind({appName: "API", eventName: "error", func: _handleError});
            events.bind({appName: "API", eventName: "error", func: _handleCloseCallback});
            events.bind({appName: "ChatStateManager", eventName: "startChatInfo", func: _updateChatTimeout});

            events.bind({ appName: "*", eventName: 'forgetMe', func: _dispose });
            events.bind({ appName: "*", eventName: 'knockout', func: _finishApp });
        }

        function _updateChatTimeout(data) {
            if (data.chatTimeout) {
                //<excludeFromBuild>
                log.info("_updateChatTimeout : updating configuration with echoed chatTimeout = " + data.chatTimeout, name);
                //</excludeFromBuild>
                conf.sessionTimeout = data.chatTimeout;
            }
        }

        function _handleError(data) {
            var message = wrapperWindow.Messages[data && data.errorType] || wrapperWindow.Messages.CONNECTION_UNAVAILABLE;
            _showWrapperWindowError(message, data && data.keepError);
        }

        function _handleCloseCallback(data) {
            closeCallback = (data && data.errorType === lpTag.unifiedWindow.consts.errorTypes.AUTH_ERROR) ? _endApplication : closeCallback;
        }

        function _analyzeStateOnFocus(data) {
            if (data.focus) { //Got Focus
                if (currentState === endedState) { //We already disposed
                    _createSessionManagerOnFocus();
                }
            }
        }

        function _createSessionManagerOnFocus() {
            sessionManager = sessionManager || _createSessionManager();
            sessionManager.setClickedSession(conf.clickedChannel);

            sessionManager.getSession(_handleStateOnFocus);
        }

        function _handleStateOnFocus(session){
            if (session && session.sid && session.sid !== "null") {
                sessionManager = null;
                _analyzeState(_analyzeStateCallback, true);
            }
        }

        function _analyzeStateOnSessionChanged() {
            //<excludeFromBuild>
            log.info("_analyzeStateOnSessionChanged", name);
            //</excludeFromBuild>
            if (sessionManager) {
                sessionManager.getSession(_handleStateOnSessionChanged);
            }
        }

        function _handleStateOnSessionChanged(session) {
            if (session && session.sid && session.sid !== "null") {
                _dispose(true);
                _initWrapperWindow();
                _analyzeState(_analyzeStateCallback);
            } else {
                _dispose();
            }
        }

        function _analyzeStateCallback(data, state) {
            currentState = state;
            switch (state) {
                case stateAnalyzer.state.INVALID:
                    //<excludeFromBuild>
                    log.info("_clickStateCallback: is INVALID state, nothing to do", name);
                    //</excludeFromBuild>
                    _showWrapperWindowError(wrapperWindow.Messages.IN_SESSION);
                    break;
                case stateAnalyzer.state.IN_SESSION:
                    _restartApplication(data.engConf);
                    break;
                case stateAnalyzer.state.NOT_STARTED:
                    _endApplication();
                    break;
            }
        }

        function _restartApplication(engConf, avoidNewPage) {
            _endApplication(avoidNewPage);
            artificialClick = true;
            clicked(engConf);
        }

        function _onWindowClose() {
            //<excludeFromBuild>
            log.info("_onWindowClose", name);
            //</excludeFromBuild>
            if(parent_window && derivedParentWindowOriginInExternalWindow){
                parent_window.postMessage('LPExternalWindowClosed',derivedParentWindowOriginInExternalWindow);
                parent_window = null;
            }

            conf.clickedChannel = null;
            util.runCallback(closeCallback);
        }

        window.addEventListener('beforeunload', function (e) {
            if(parent_window && derivedParentWindowOriginInExternalWindow){
                parent_window.postMessage('LPExternalWindowClosed',derivedParentWindowOriginInExternalWindow);
                parent_window = null;
            }
        });

        function _seppuku() {
            //<excludeFromBuild>
            log.info("_seppuku", name);
            //</excludeFromBuild>
            if (isRestartForStepUpInProgress) {
                return;
            }
            _dispose();
            _endApplication();
        }

        /**
         * Dispose of applicative state
         * @param keepSession - do not delete the session cookie
         * @private
         */
        function _dispose(keepSession) {
            appStarted = false;
            log.triggerEvent(log.events.APP_ENDED);
            if (wrapperWindowErrorTimeoutId) {
                clearTimeout(wrapperWindowErrorTimeoutId);
            }
            currentState = endedState;
            if (sessionManager) {
                sessionManager.dispose(keepSession);
                sessionManager = null;
            }

            windowConfig = null;
            if (windowConfigurationManager) {
                windowConfigurationManager.clear();
                windowConfigurationManager = null;
            }
            if(accountSettingsManager) {
                accountSettingsManager = null;
            }
            conf.sessionId = null;
            delete conf.sessionId;
            stateAnalyzer = null;
        }

        /**
         * Dispose wrapper window from a function and not directly because when binding directly
         * the previous wrapper window stay alive although it's reference already null
         */
        function _disposeWrapperWindow() {
            if(wrapperWindow) {
                wrapperWindow.dispose();
            }
        }

        /**
         * Dispose of the application UI
         * @private
         */
        function _endApplication(avoidNewPage) {
            appFilesReady = false;
            wrapperWindowRendered = false;
            if (application) {
                application.methods.end();
                application = null;
                appStarted = false;
                log.triggerEvent(log.events.APP_ENDED);
            }
            wrapperWindow = null;

            events.trigger({
                appName: name,
                eventName: "windowClosed",
                global: true
            });
            if (!avoidNewPage && !isRestartForStepUpInProgress && !isApplicationRestartingInWaitingState) {
                lpTag.taglets.lpUnifiedWindow.reinitByWindowClose = true;
                lpTag.newPage(document.URL);
            }
        }

        function _finishApp(){
            _endApplication();
            _dispose();
        }

        function _isAppDisposed() {
            return util.getPropertyFromObject(application, "methods.isDisposed") && application.methods.isDisposed();
        }

        function _isAppNotDisposed() {
            return util.getPropertyFromObject(application, "methods.isDisposed") && !application.methods.isDisposed();
        }

        function _convertPreChatToObject(arr) {
            var msg = 'msg', i = 0, obj = {};
            arr.forEach(function(str){
                obj[msg + (++i)] = str;
            });

            return obj;
        }

        function _removeAcrValuesIfExist(engConf){
            var acrCheck = util.getPropertyFromObject(engConf,'connector.configuration.acrValues');
            if(typeof acrCheck != 'undefined') {
                delete engConf.connector.configuration.acrValues;
            }
            return engConf;
        }

        function _getAllConnectors(callback) {
            var domain = isFetchEnabled ? conf.acCdnDomainConsumerSdk : conf.acCdnDomain;
            var url = "https://" + domain + "/api/account/" + conf.accountId + "/configuration/le-connectors/all-connectors";
            var transport = isFetchEnabled ? lpTag.taglets.fetch : lpTag.taglets.jsonp;
            transport.issueCall({
                url: url,
                timeout: 5000,
                retries: 0,
                credentials: isFetchEnabled ? 'omit' : undefined,
                cache: (isFetchEnabled && fetchCacheMode) ? fetchCacheMode : undefined,
                success: function (response) {
                    var connectors = isFetchEnabled ? (response && response.body) : response;
                    callback(connectors);
                },
                error: function () {
                    log.error("_getAllConnectors - ERROR FROM SERVER", name);
                    callback();
                }
            });
        }

        function _loadStyles() {
            var element, deviceFamilyName = deviceDetector.getDeviceFamilyName().toLowerCase();
            if (!!conf.enableStrictCspMode) {
                element = document.createElement('link');
                element.setAttribute('rel', 'stylesheet');
                element.setAttribute('id', 'lpStyle');
                element.setAttribute('href', conf.codeRepository + "/resources/css/" + deviceFamilyName + "EmbeddedStyle.css" + cacheBusterVer);
            } else {
                element = document.createElement("script");
                element.setAttribute("charset", "utf-8");
                element.setAttribute("id", "lpStylesLoader");
                element.setAttribute("src", conf.codeRepository + "/resources/js/" + deviceFamilyName + "EmbeddedStyle.js" + cacheBusterVer);
            }
            element.addEventListener('load', function () {
                stylesLoaded = true;
            }, false);
            document.getElementsByTagName('head').item(0).appendChild(element);
            stylesAttached = true;
        }

        function _loadInitialStyles() {
            var element;
            element = document.createElement('link');
            element.setAttribute('rel', 'stylesheet');
            element.setAttribute('id', 'lpInitialStyles');
            element.setAttribute('href', conf.codeRepository + "/resources/css/initialStyles.css" + cacheBusterVer);
            document.querySelector('head').appendChild(element);
            initialStylesAttached = true;
        }

        function _resetIfStepUp() {
            if (conf.isStepUpEnabled){
                if (conf.isSPAStepUpEnabled) {
                    log.info('resetIfStepUp: checking if step up needed', name);
                    _runStepUpIfNeeded();
                } else {
                    _updateStepUpCheckedStatus(false);
                }
            }
        }

        function _runStepUpIfNeeded () {
            if ((_stepUpIdentities() || conf.wasAuthConnectorAppliedForStepUp) && application) {
                events.trigger({
                    appName: "*",
                    eventName: "getChatState",
                    data: {
                        gotChatStateCallback: _gotChatState
                    }
                });
            } else {
                _updateStepUpCheckedStatus(false);
            }
        }

        /**
         * Callback of getChatState event. Gets called only on SPAs. Restarts the application to run existing
         * stepup flow if it is "chatting" state. Or restarts the application to step up by replacing unauth connector
         * with auth if it is "waiting" state
         * @param startData - start data that gets delivered from inside of the application and contains current
         * chat state and engagement configuration
         * @private
         */
        function _gotChatState (startData) {
            var isMessaging = startData.engConf && startData.engConf.async;
            if (startData.state === "chatting" && isMessaging && !conf.wasAuthConnectorAppliedForStepUp) {
                log.info("_gotChatState: Stepping up on SPA", name);
                lpTag.stepUpShouldStart = true;
                isRestartForStepUpInProgress = true;
                artificialClick = true;
                _restartApplication(startData.engConf, true);
                isRestartForStepUpInProgress = false;
            }
            if (isStepUpDuringWaitingStateEnabled && startData.state === "waiting" && isMessaging) {
                if (_stepUpIdentities() && !conf.wasAuthConnectorAppliedForStepUp) {
                    log.info("_gotChatState: Stepping up on SPA in waiting state", name);
                    isApplicationRestartingInWaitingState = true;
                    artificialClick = true;
                    _restartApplication(startData.engConf, true);
                }
                if (!_stepUpIdentities() && conf.wasAuthConnectorAppliedForStepUp) {
                    log.info("_gotChatState: Consumer logged out. Restarting the window to show auth error", name);
                    isApplicationRestartingInWaitingState = true;
                    artificialClick = true;
                    _restartApplication(startData.engConf, true);
                }
            }
        }

        /**
         * Checks if we have enough identities on the page to run Step Up
         * @returns {boolean} - true when current length of the
         * identities matches with a desired length for step up
         * @private
         */
        function _stepUpIdentities () {
            var identitiesLength = lpTag.identities && lpTag.identities.length;
            var lengthToStepUp = lpTag && lpTag.taglets && lpTag.taglets.lp_sms_client_api ? 3 : 2;
            return identitiesLength === lengthToStepUp;
        }

        /**
         * Fetches all available connectors for account and gets auth one from received connectors
         * @param configs - configuration store with all configs we operate with in UW. Only engagement config
         * from there is used in this function.
         * @param callback - callback method to call when auth connector is set into engagement config
         * @private
         */
        function _getConnectorsAndApplyAuth (configs, callback) {
            _getAllConnectors(function (connectors) {
                var authConnector;
                if (connectors && connectors.length) {
                    authConnector = _getAuthConnector(connectors, "auth");
                }
                if (authConnector && configs.uiState.engConf) {
                    configs.uiState.engConf.connector = authConnector;
                    conf.wasAuthConnectorAppliedForStepUp = true;
                    _setWaitingStateStepUpData({
                        wasAuthConnectorAppliedForStepUp: true,
                        isConvoSteppedUp: conf.isConvoSteppedUp
                    });
                }
                callback();
            });
        }

        /**
         * Searches for auth connector
         * @param connectors - array of connectors
         * @returns {*} - if found, auth connector configuration object
         * @private
         */
        function _getAuthConnector(connectors) {
            var authConnectors = connectors.filter(function (connector) {
               return _isAuthConnector(connector);
            });
            if (authConnectors && authConnectors.length) {
                return authConnectors[0];
            }
        }

        /**
         * Detects if passed connector is auth
         * @param connector - configuration object to check if it is auth
         * @returns {boolean} - true if connector is auth
         * @private
         */
        function _isAuthConnector(connector) {
            var config = connector && connector.configuration;
            var unAuthJsMethod = "lpTag.taglets.unAuthMessaging.lpUnauthFunction";
            var unAuthJsContext = "lpTag.taglets.unAuthMessaging";
            return config && config.jsContext !== unAuthJsContext && config.jsMethodName !== unAuthJsMethod;
        }

        /**
         * Gets from secure storage a state of data needed for StepUp when in waiting state
         * @param successCb
         * @param errorCb
         * @private
         */
        function _getWaitingStateStepUpData (successCb, errorCb) {
            secureStorage.getValue({
                    key: CONSTS.stepUpInWaitingState.storageKey,
                    site: lpTag.site,
                    app: APP,
                    success: function (data) {
                        successCb(data);
                    },
                    error: function () {
                        errorCb();
                    },
                    appName: CONSTS.stepUpInWaitingState.appName,
                    domain: conf.secureStorageLocation,
                    firstParty: true
                }
            );
        }

        /**
         * Sets to secure storage a state of data needed for StepUp when in waiting state
         * @param data - data to persist
         * @private
         */
        function _setWaitingStateStepUpData (data) {
            secureStorage.setValue({
                key: CONSTS.stepUpInWaitingState.storageKey,
                site: lpTag.site,
                app: APP,
                value: data,
                success: function (data) {
                    log.info("_setWaitingStateStepUpData: Data for StepUp in waiting state successfully set - " + JSON.stringify(data), APP);
                },
                errorTimeout: function () {
                    log.error("_setWaitingStateStepUpData: Error to set data for StepUp in waiting state", APP);
                },
                appName: CONSTS.stepUpInWaitingState.appName,
                domain: conf.secureStorageLocation,
                firstParty: true
            });
        }

        function _isPreloadDisabled () {
            return !!conf.disableResourcesPreloading ;
        }

        /**
         * Once UW completes step up checks we need to notify subscribers that this process finished with a flag
         * that defines if it is stepup or not
         * @param {boolean} isStepUp
         * @private
         */
        function _updateStepUpCheckedStatus (isStepUp) {
            lpTag.taglets.lpUnifiedWindow.stepUpChecked = {
                isStepUp: isStepUp
            };
            lpTag.events.trigger({
                eventName: "STEPUP_CHECKED",
                appName: "*",
                data: {
                    isStepUp: isStepUp
                }
            });
        }

        /**
         * Detects if SMS clicked as a choice of multi channel engagement
         * @param engConf
         * @returns {boolean}
         * @private
         */
        function _isMultichannelSMS(engConf) {
            var targets = engConf && engConf.externalTargets;
            var deflectionProps;
            if (targets && targets[EXTERNAL_TARGET_ID.SMS]) {
                deflectionProps = targets[EXTERNAL_TARGET_ID.SMS].deflectionTargetProperties;
                if (deflectionProps && deflectionProps.tapToText) {
                    return true;
                }
            }
            return false;
        }

        return {
            v: v,
            name: name,
            init: init,
            reinit: reinit,
            onBeforeNavigation: onBeforeNavigation,
            startFlow: startFlow,
            clicked: clicked,
            inspect: inspect
        };
    }();
}catch(e){lpTag.handleGeneralError("lpUnifiedWindow",e);}try{window.lpTag=lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.SMT=lpTag.taglets.SMT||function(){function a(){}var t="SMT",g="2.21.0";return{v:g,name:t,init:a}}();}catch(e){lpTag.handleGeneralError("SMT",e);}try{!function(){var e,t=this&&this.__assign||function(){t=Object.assign||function(e){for(var t,s=1,a=arguments.length;a>s;s++){t=arguments[s];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e};return t.apply(this,arguments)};!function(e){var t=["style"],s=function(){function e(e){var t=e.classMap,s=e.prefix;this.name="lp_css_customization";this.version="1.1";this._classMap=t;this._prefix=s;this._userAgentMap=this._createUserAgentMap(this._prefix);this._config={}}e.prototype.inspect=function(){return this._config};e.prototype._createUserAgentMap=function(e){return{mobile:e+"_mobile",desktop:e+"_desktop",tablet:e+"_tablet","default":e+"_default"}};e.prototype._createDesignOption=function(e){var t=e[0],s=e[1],a=e[2],n=void 0===a?!1:a,i=[];if("object"==typeof s){for(var r in s)if(this._userAgentMap[r]){var l=this.getProp(s,r+".value","");l&&i.push({cssClass:t,style:l,userAgent:r,isEngagement:n})}}else s&&i.push({cssClass:t,style:s,userAgent:"default",isEngagement:n});return i};e.prototype.getProp=function(e,t,s){return lpTag.taglets.lpUtil.getPropertyFromObject(e,t,s)};e.prototype._getClassName=function(e){var t=e[0],s=e[1],a=t.split("_"),n=a[0],i=this._classMap[n];if(i){if(i.isEngagement){var r="LPM"+i.className;if(s){var l=this.getProp(i,"types."+s+".className","");l&&(r=r+".LPM"+l)}return r}var o=""+this._prefix+i.className;if(!s){var m=a[1]?"_"+a[1]:"";return""+o+m}var c=s.split("_"),u=this.getProp(i,"elements."+c[0]+".className","");if(u)return o+"__"+u+(c[1]?"_"+c[1]:"")}return""};e.prototype.convertConfiguration=function(e){var t={};lpTag.taglets.lp_global_utils.convertConfig(e,t);this._config=t;return t.lp_css_customization||{}};e.prototype.transformConfig=function(e){var s=[];for(var a in e)if(e.hasOwnProperty(a)){var n=this._getClassName.call(this,[a]),i=this._classMap[a]&&this._classMap[a].isEngagement,r=this._createDesignOption([n,e[a].style,i]);n&&r&&s.push.apply(s,r);for(var l in e[a])if(e[a].hasOwnProperty(l)&&-1===t.indexOf(l)){var o=this._getClassName.call(this,[a,l]),m=this._createDesignOption([o,e[a][l].style,i]);o&&m&&s.push.apply(s,m)}}return s};e.prototype.appendToDom=function(e,t,s,a){for(var n="",i=lpTag.taglets.lpUnifiedWindow.inspect().conf||{},r=i.wrapperElementId||"lpChat",l=i.imagesRepository||"",o=0,m=e;o<m.length;o++){var c=m[o];if(c.isEngagement)n+="div[id^=LPM]."+c.cssClass+"{"+c.style+"}";else{var u="default"!==c.userAgent?".lpc_"+c.userAgent:"";n+="#"+r+" "+u+"."+c.cssClass+"{"+c.style+"}"}}for(var p=0,g=s;p<g.length;p++){var d=g[p];n+=this.addWrapperToStyle(d,"#"+r,!1)}for(var N=0,h=a;N<h.length;N++){var f=h[N],y=f.engagementSelector||'[id^="LPMcontainer"]';n+=this.addWrapperToStyle(f.style,y,!0)}n&&t&&(n=this.replacePath(n,l,"{{ImageRepository}}"));n&&lpTag.taglets.lpUtil.addStyleTag(n)};e.prototype.appendExternalStylesheetToDom=function(e){var t=lpTag.taglets.lpUnifiedWindow.inspect().conf||{},s=t.codeRepository+"/resources/css/";if(e&&e.length>0)for(var a=0,n=e;a<n.length;a++){var i=n[a];i=this.replacePath(i,s,"{{CSSRepository}}");if(!(i.length<4)){var r=document.createElement("link");r.setAttribute("rel","stylesheet");r.setAttribute("type","text/css");r.setAttribute("href",i);document.getElementsByTagName("head")[0].appendChild(r)}}};e.prototype.addWrapperToStyle=function(e,t,s){var a=e;if(t){var n=e.match(/(^.+?){/);if(!n||!n.length)return a;n=n[1].split(",");for(var i=0;i<n.length;i++)n[i]=s===!0?""+t+n[i].trim():t+" "+n[i].trim();return e.replace(/^.+?{/,n.join(", ")+"{")}return a};e.prototype.replacePath=function(e,t,s){return e.replace(new RegExp(s,"g"),t)};e.prototype.init=function(e){var t=this.convertConfiguration.call(this,e),s=this.transformConfig.call(this,t),a=t.customWindowCSS&&t.customWindowCSS.length,n=t.customEngagementCSS&&t.customEngagementCSS.length,i=t.enableImageReplacement&&"true"==t.enableImageReplacement?!0:!1;this.appendExternalStylesheetToDom(t.externalStylesheets);this.appendToDom(s,i,a?t.customWindowCSS:[],n?t.customEngagementCSS:[])};return e}();e.Taglet=s}(e||(e={}));window.lpTag=window.lpTag||{};window.lpTag.taglets=window.lpTag.taglets||{};window.lpTag.taglets.lp_css_customization=window.lpTag.taglets.lp_css_customization||function(){var s={closeButton:{className:"close-button"},closeButtonAsset:{className:"close-button-asset"},text:{className:"text"},textWrapper:{className:"text-wrapper"},icon:{className:"icon"},iconAsset:{className:"icon-asset"}},a={imageWrapper:{className:"image-wrapper"},image:{className:"image"}},n={engagement:{className:"container",isEngagement:!0,types:{slider:{className:"slider"},sticky:{className:"sticky"},overlay:{className:"overlay"},embedded:{className:"embedded"},toaster:{className:"slider"}}},window:{className:"window",elements:{}},maximizedHeader:{className:"maximized-header",elements:t(t({},s),{sliderButton:{className:"slider-button"},sliderButtonAsset:{className:"slider-button-asset"},minimizeButton:{className:"minimize-button"},minimizeButtonAsset:{className:"minimize-button-asset"},menuButton:{className:"menu-button"},menuButtonAsset:{className:"menu-button-asset"}})},minimizedHeader:{className:"minimized-header",elements:t(t({},s),{maximizeButton:{className:"maximize-button"},maximizeButtonAsset:{className:"maximize-button-asset"},notificationCounter:{className:"notification-counter"}})},body:{className:"body",elements:{}},layout:{className:"layout",elements:{}},bannerImage:{className:"banner-image-area",elements:t(t({},a),{link:{className:"link"}})},heroImage:{className:"hero-image-area",elements:t({},a)},historySpinner:{className:"history-spinner",elements:{}},transcript:{className:"transcript",elements:{}},messageArea:{className:"message-area",elements:{timestamp:{className:"timestamp"},avatar:{className:"avatar"},indicator:{className:"indicator"}}},message:{className:"message",elements:{text:{className:"text"}}},messageTail:{className:"message-tail",elements:{border:"border"}},typingIndication:{className:"type-indication",elements:{}},actionMenu:{className:"menu",elements:{item:{className:"item"},banner:{className:"banner"}}},composer:{className:"composer",elements:{textArea:{className:"text-area"},textAreaWrapper:{className:"text-area-wrapper"},menuButton:{className:"menu-button"},menuButtonAsset:{className:"menu-button-asset"},sendButton:{className:"send-button"},sendButtonAsset:{className:"send-button-asset"},fileAttachmentButton:{className:"file-attachment-button"},fileAttachmentButtonAsset:{className:"file-attachment-button-asset"},emojiButton:{className:"emoji-button"},emojiButtonAsset:{className:"emoji-button-asset"}}},slider:{className:"slider",elements:{body:{className:"body"}}},sliderHeader:{className:"slider-header",elements:{minimizeButton:{className:"minimize-button"},minimizeButtonAsset:{className:"minimize-button-asset"},refreshButton:{className:"refresh-button"},refreshButtonAsset:{className:"refresh-button-asset"},text:{className:"text"}}},confirmationDialog:{className:"confirmation-dialog",elements:{confirmButton:{className:"confirm-button"},cancelButton:{className:"cancel-button"}}},card:{className:"card",elements:{button:{className:"button"},image:{className:"image"},map:{className:"map"},text:{className:"text"}}},surveyAreaWrapper:{className:"survey-area-wrapper",elements:{}},surveyArea:{className:"survey-area",elements:{questionWrapper:{className:"question-wrapper"},questionLabel:{className:"question-label"},questionContent:{className:"question-content"},header:{className:"header"},disclaimer:{className:"disclaimer"},previousButton:{className:"previous-button"},cancelButton:{className:"cancel-button"},nextButton:{className:"next-button"},submitButton:{className:"submit-button"},closeButton:{className:"close-button"}}}};return new e.Taglet({classMap:n,prefix:"lpc_"})}()}();}catch(e){lpTag.handleGeneralError("lp_css_customization",e);}try{"use strict";var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o};window.lpTag=window.lpTag||{};window.lpTag.taglets=window.lpTag.taglets||{};window.lpTag.taglets.hooks=window.lpTag.taglets.hooks||function(o){function n(){u={};k={};"undefined"!=typeof o.hooks&&o.hooks.length&&t(o.hooks);e()}function e(){o.hooks=o.taglets.hooks}function t(o){o=Array.isArray(o)?o:[o];o.forEach(function(o){if(c(o)){u[o.name]=u[o.name]||[];u[o.name].push(o.callback);o.isAsync&&(k[o.name]=o.callback)}})}function a(o){o=Array.isArray(o)?o:[o];o.forEach(function(o){c(o)&&(k[o.name]=o.callback)})}function c(n){if(!n){o.log("Hook is not defined","ERROR","hooks");return!1}if("string"!=typeof n.name){o.log("Hook name '"+n.name+"' is not a string","ERROR","hooks");return!1}if("function"!=typeof n.callback){o.log("Hook callback for '"+n.name+"' is not a function","ERROR","hooks");return!1}o.log("Hook callback for '"+n.name+"' was added successfully","INFO","hooks");return!0}function i(n){if(n&&n.name){var e=u[n.name]||[];e.forEach(function(e){if("function"==typeof e)try{var t=e(n);if("object"===("undefined"==typeof t?"undefined":_typeof(t))){n=t;o.log("Hook '"+n.name+"' returned data successfully","INFO","hooks")}else o.log("Hook '"+n.name+"' callback didn't return an object","ERROR","hooks")}catch(a){o.log("Hook callback threw an exception: "+a.message,"ERROR","hooks")}})}return n}function s(n,e,t){if(n&&n.name&&"function"==typeof e&&"function"==typeof t){var a=k[n.name];if("function"==typeof a)try{a(n,e,t);o.log("Hook '"+n.name+"' called with asynchronous callback","INFO","hooks")}catch(c){o.log("Hook callback threw an exception: "+c.message,"ERROR","hooks");t(n,c)}}else;}function f(o){return k[o]?!0:!1}var l="hooks",r="0.0.2",u={},k={};return{version:r,name:l,init:n,push:t,exec:i,pushAsync:a,execAsync:s,isHookAsync:f}}(window.lpTag);}catch(e){lpTag.handleGeneralError("hooks",e);}try{window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.lp_SMT=lpTag.taglets.lp_SMT||function(){function e(e){if(e)for(var t=0;t<e.length;t++){var n=e[t].value;"string"==typeof n&&""!==n&&("["===n.charAt(0)||"{"===n.charAt(0))&&("undefined"!=typeof JSON&&JSON.parse?n=JSON.parse(n):s("unable to parse JSON, no JSON object on page"));b[e[t].id]=n}else l("No cfg were given on init")}function t(){b.active=!0;if(lpTag.taglets.lp_monitoringSDK.inspect().conf.baseUrl===lpTag.getDomain("ALL")){b.active=!1;s("Monitoring set to inactive! smt domain was not found")}lpTag.events.trigger(E,"MONITORING_STATE",{active:b.active});R=lpTag.events.bind("lp_monitoringSDK","SP_SENT",o);O(_.sp)}function n(){clearTimeout(d);lpTag.events.unbind(R);N&&lpTag.events.unbind(N);b.active=!1}function i(t){clearTimeout(d);lpTag.events.unbind(R);N&&lpTag.events.unbind(N);e(t)}function a(){return b.active}function o(){lpTag.isDom?O(_.pl):N=lpTag.events.bind("LPT","DOM_READY",function(){O(_.pl)})}function r(e,t){window.lpTag&&lpTag.log&&lpTag.log(e,t,E)}function s(e){r(e,"ERROR")}function g(e){r(e,"DEBUG")}function l(e){r(e,"INFO")}function p(e){lpTag.events.trigger(E,"MONITORING_REQUEST_SUCCESS",e);l("success call made by smt with the following result: "+("string"!=typeof e?JSON.stringify(e):e))}function c(e){lpTag.events.trigger(E,"MONITORING_REQUEST_ERROR",e);s("error returned to smt callback onError: "+("string"!=typeof e?JSON.stringify(e):e))}function u(e){return e.status===y.ok&&!e.error}function T(e){S(e);v();if(b.keepAliveFreq&&b.active){if(e.reqType===_.pl||e.reqType===_.ip){d=setTimeout(function(){O(_.ip)},1e3*b.keepAliveFreq);g("Next request to be issued in "+b.keepAliveFreq+"sec")}}else lpTag.taglets.lp_monitoringSDK.stop();f(u(e)?p:c,e,"Client onSuccess callback returned an error: ")}function f(e,t,n){try{e(t)}catch(i){s(n+JSON.stringify(i.message))}}function v(){b.active||lpTag.events.trigger(E,"MONITORING_STATE",{active:b.active})}function S(e){if(e.smtConf){for(var t in e.smtConf)b[t]=e.smtConf[t];delete e.smtConf}}function O(e){if(b.active){lpTag.taglets.lp_monitoringSDK[e](function(t){t.status=y.ok;t.reqType=e;T(t)},function(t){t.status=y.err;t.reqType=e;T(t)});g("Sending"+e+"request")}else{lpTag.events.trigger(E,"MONITORING_REQUEST_ERROR",{message:"Monitoring is set to inactive, not sending any requests",status:"ERROR",reqType:e});l("Monitoring is set to inactive, not sending any requests")}}var d,R,N,m="3.4.0",E="lp_SMT",_={sp:"startPage",pl:"pageLoaded",ip:"inPage"},y={err:"ERROR",ok:"OK"},b={keepAliveFreq:10,active:!0};return{v:m,name:E,inspect:function(){return b},init:e,start:t,reinit:i,restart:t,stop:n,isActive:a}}();}catch(e){lpTag.handleGeneralError("lp_SMT",e);}try{window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.authenticator=lpTag.taglets.authenticator||function(){function t(){lpTag.log("authenticator init called","DEBUG","authenticator")}function e(t,e,i){return t.type===f.OAUTH_IMPLICIT||t.type===f.OAUTH_CODE?n(t,e,i):a(t,e,i)}function n(t,e,n){var a,r,l=o(n),u=i(e,l);t=t||{configuration:{clientId:lpTag.site}};var c={callback:u,clientId:t.configuration.clientId};lpTag.log("_getOAuthSSOKey: "+s,"DEBUG","authenticator");if(t.type&&t.type===f.OAUTH_IMPLICIT&&"lpTag.taglets.unAuthMessaging"===t.configuration.jsContext&&"lpTag.taglets.unAuthMessaging.lpUnauthFunction"===t.configuration.jsMethodName&&lpTag.taglets.unAuthMessaging&&lpTag.taglets.unAuthMessaging.jsMethodExtended)lpTag.taglets.lpUtil.runCallbackByObject(t.configuration,c,l);else if(t.code_challenge){a=lpTag.taglets.lpUtil.getPropertyFromObject(window,t.configuration.jsContext);r=lpTag.taglets.lpUtil.getPropertyFromObject(window,t.configuration.jsMethodName);r.call(a,c.callback,t.code_challenge)}else lpTag.taglets.lpUtil.runCallbackByObject(t.configuration,c.callback,l)}function a(t,e,n){lpTag.log("_getServer2ServerSSOKey"+s,"DEBUG","authenticator");lpTag.taglets.xhr.issueCall({url:t.configuration.genKeyUrl,method:"GET",query:{rt:"json"},retries:p.retries,timeout:p.timeout,success:r(e),error:o(n)})}function i(t,e){return function(n,a){var i=null===a||"undefined"==typeof a;if(i&&n){var o,r;if("object"==typeof n){o=n.ssoKey;r=n.redirect_uri}else o=n;t({ssoKey:o,redirect_uri:r})}else e()}}function o(t){return function(e){c=!0;"function"==typeof t&&t(e)}}function r(t){return function(e){t(e.body||{})}}function l(){return c?!0:!1}function u(){var t={name:s,ssoKeyGenTransport:{timeout:p.timeout,retries:p.retries}};return t}var c,g="0.3.0",s="authenticator",p={timeout:3e4,retries:3,successResponseCode:201},f={S2S:0,OAUTH_IMPLICIT:1,OAUTH_CODE:2};return{v:g,init:t,getSSOKey:e,isErroneous:l,inspect:u}}();}catch(e){lpTag.handleGeneralError("authenticator",e);}try{window.lpTag.taglets.lp_global_utils=function(){function e(){}function n(e,n){if("undefined"!=typeof n){if(e)for(var a=0;a<e.length;a++){var t=e[a].value;if("string"==typeof t&&""!==t)if("true"===t)t=!0;else if("false"===t)t=!1;else if("["===t.charAt(0)||"{"===t.charAt(0))try{"undefined"!=typeof JSON&&JSON.parse?t=JSON.parse(t):lpTag.log("unable to parse JSON, no JSON object on page ","ERROR",l)}catch(i){lpTag.log("unable to parse JSON:"+i,"ERROR",l)}n[e[a].id]=t}}else lpTag.log("_config is passed as undefined","ERROR",l)}function a(e){return e.replace(/^\s+|\s+$/g,"")}var t=1.4,l="lp_global_utils";return{v:t,name:l,init:e,convertConfig:n,trim:a}}();}catch(e){lpTag.handleGeneralError("lp_global_utils",e);}try{function _typeof(e){"@babel/helpers - typeof";return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function ownKeys(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,a)}return n}function _objectSpread(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?ownKeys(Object(n),!0).forEach(function(t){_defineProperty(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):ownKeys(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function _defineProperty(e,t,n){return(t=_toPropertyKey(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function _toPropertyKey(e){var t=_toPrimitive(e,"string");return"symbol"==_typeof(t)?t:t+""}function _toPrimitive(e,t){if("object"!=_typeof(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var a=n.call(e,t||"default");if("object"!=_typeof(a))return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}window.lpTag=window.lpTag||{};window.lpTag.taglets=window.lpTag.taglets||{};window.lpTag.taglets.unAuthMessaging=window.lpTag.taglets.unAuthMessaging||function(){function e(e,t,n){window.lpTag&&window.lpTag.log&&window.lpTag.log("".concat(n,": ").concat(e),t,pe)}function t(t){if(t){var n=t.split(".");if(n.length>=2)try{return JSON.parse(window.atob(n[1]))}catch(a){e("error parsing jwt","ERROR","getPayloadFromJWT")}}return{}}function n(e){return t(e).sub}function a(e){if(e&&e.aud){if(0===e.aud.indexOf("acc:")){var t=e.aud.substring(4);return"undefined"===t?"":t}if("undefined"!==e.aud)return e.aud}return""}function r(e){return a(t(e))}function o(e){var n=t(e);return n&&n.exp?n.exp:0}function i(e,t){if(lpTag.sdes&&e&&e.length>0&&Se!==e&&!lpTag.identitiesSupport){Se=e;lpTag.sdes.push({type:he.names.sdeType,id:e,account:t})}}function c(e,t){t&&i(t,e);if(Ee){var n={iss:"LivePerson",acr:"0"};e&&(n.account=e);t&&(n.sub=t);Ce.push(n);if(De<=Ce.length){Ee(Ce);Ee=null}}}function s(e){return e===be.accountId?he.names.secureStorageKey:"".concat(he.names.secureStorageKey,"_").concat(e)}function u(e,t,n){var a=s(t||be.convOwnerAccountId);window.lpTag.taglets.lpSecureStorage.getValue({key:a,site:be.accountId,app:pe,success:function(t){var a=o(n),r=o(t);e(r>=a?t:n)},error:function(){e(n)},appName:pe,domain:be.secureStorageLocation,firstParty:!1})}function l(e,t,n){var a=s(n||be.convOwnerAccountId);window.lpTag.taglets.lpSecureStorage.getValue({key:a,site:be.accountId,app:pe,success:function(t){var a,r=lpTag.taglets.lpSecureStorage;"function"==typeof r.isFirstPartyStorageFeatureEnabled&&(a=r.isFirstPartyStorageFeatureEnabled());t&&a?u(e,n,t):e(t)},error:function(){De-=1;t()},appName:pe,domain:be.secureStorageLocation,firstParty:!0})}function d(e,t,n){if(e){var a=Object.keys(e);De=a.length;Ce=[];a.forEach(function(e){l(t,n,e)})}else{De=1;l(t,n)}}function p(e,t){window.lpTag.taglets.lpSecureStorage.getValue({key:he.names.storedAccountIdentitiesDictionaryKey,site:be.accountId,app:pe,success:function(n){d(n,e,t)},error:t,appName:pe,domain:be.secureStorageLocation,firstParty:!0})}function f(e){var t=_objectSpread({},e);if(be.useCaptcha){t.data=e.data||{};t.data.recaptcha={};t.data.recaptcha[he.names.captchaResponse]=window.grecaptcha&&window.grecaptcha.getResponse()}return t}function g(e){var t=Ae?window.lpTag.taglets.fetch:window.lpTag.taglets.postmessage,n=f(e);t.issueCall(n)}function h(e){window.lpTag.taglets.postmessage.configure({frames:{url:he.endPoints.postmessageConfigureFrameURL({domain:e})}})}function w(t){e(t,"ERROR","handleError");if(be.success){be.success(null,t);delete be.success}}function m(e){for(var t,n=e.search,a={},r=n.substr(1).split("&"),o=0;o<r.length;o+=1)if(r[o].indexOf("=")>-1){t=r[o].split("=");if(2===t.length)try{var i=decodeURIComponent(t[0]);a[i]=decodeURIComponent(t[1])}catch(c){w("Unable to parse params from UW config")}}return a}function y(e){var t={};if(e){var n=document.createElement("a");n.href=e;t=m(n)}return t}function v(e){var t;if(e.state)try{t=JSON.parse(e.state);if(t.lpUnifiedWindowConfig)return t.lpUnifiedWindowConfig;t=null}catch(n){t=null}!t&&e.redirect_uri&&(t=y(e.redirect_uri));if(t&&t.lpUnifiedWindowConfig)switch(_typeof(t.lpUnifiedWindowConfig)){case"string":try{t=JSON.parse(t.lpUnifiedWindowConfig)}catch(n){w("Couldn't parse unified window config")}break;case"object":t=t.lpUnifiedWindowConfig}return t}function T(t){if(t&&t.constructor===Array)try{ue.convertConfig(t,be)}catch(n){e("Failed to parse taglet configuration: ".concat(n.message),"ERROR","convertTagletConfig")}else t&&(be=ue.cloneExtend(be,t,!0))}function I(e){if(Oe)e();else{Oe=!0;var t={debug:!1};t[pe]={site:be.accountId,env:!0,app:pe,url:be.secureStorageLocation,chosenStorageHandler:e,firstParty:!0};window.lpTag.taglets.lpSecureStorage.configure(t)}}function S(){window.lpTag.redirect=window.lpTag.redirect||function(e){window.location.href=e}}function O(e){var t=window.lpTag.taglets.lpSecureStorage.v;return"https://".concat(e,"/le_secure_storage/").concat(t?"".concat(t,"/"):"")}function R(e){var t=lpTag&&lpTag.csds&&lpTag.csds.getDomain(he.names.csdsIDP),n=lpTag&&lpTag.csds&&lpTag.csds.getDomain(he.names.leCdnDomain);n=n?O(n):!1;if(e){be.useCaptcha=e.useCaptcha;be.env=e.env||he.envType.PRODUCTION;be.success=e.success;be.error=w;be.state=e.state;be.IDPDomain=e.IDPDomain||t;be.accountId=lpTag&&lpTag.site||e.accountId;be.secureStorageLocation=n||window.lpTag.taglets.lpSecureStorage.sessionStorageStaticDomain;be.redirect_uri=e.redirect_uri;be.isExternal=e.isExternal;be.language=e.language||he.defaultLanguage;be.convOwnerAccountId=e.convOwnerAccountId||be.accountId}return be.success&&(be.IDPDomain||be.isExternal)&&be.accountId&&be.secureStorageLocation}function b(e,t){var n=t||{};n[e]=s(e);window.lpTag.taglets.lpSecureStorage.setValue({key:he.names.storedAccountIdentitiesDictionaryKey,site:be.accountId,app:pe,value:n,success:function(){},error:function(){},appName:pe,domain:be.secureStorageLocation,firstParty:!0})}function E(e){window.lpTag.taglets.lpSecureStorage.getValue({key:he.names.storedAccountIdentitiesDictionaryKey,site:be.accountId,app:pe,success:function(t){b(e,t)},error:function(){b(e,{})},appName:pe,domain:be.secureStorageLocation,firstParty:!0})}function D(e,t){var n=s(e),a=(new Date).getTime();Pe&&Pe.setSessionData(n,a);window.lpTag.taglets.lpSecureStorage.setValue({key:n,site:be.accountId,app:pe,value:t,success:function(){ve[e]=we.READY},error:function(){ve[e]=we.NONE},appName:pe,domain:be.secureStorageLocation,ttl:Te,firstParty:!0});E(e)}function C(e){var n=e&&e.body&&e.body.token;if(n){var r=t(n),o=a(r);le=n;D(o,n);c(o,r.sub);if(be.success&&o===be.convOwnerAccountId){be.success(n);delete be.success}}else{ve[be.convOwnerAccountId]=we.NONE;be.error("Couldn't get JWT from ".concat(be.IDPDomain))}}function N(){ve[be.convOwnerAccountId]=we.PENDING;var e=function(e){ve[be.convOwnerAccountId]=we.NONE;be&&be.error&&be.error(e)},t={url:he.endPoints.unAuthJWT(be),method:"POST",error:e,success:C};if(Ae){t.headers=t.headers||{};t.headers["Content-Type"]="application/json"}else h(be.IDPDomain);g(t)}function P(e){Ie=he.refreshJwtRetryAttempts;var n=e&&e.body&&e.body.token;if(n){var r=t(n),o=a(r);le=n;e.usingJWTFromSecureStorage||D(o,n);c(o,r.sub);if(be.success){be.success(n);delete be.success}}else N()}function A(t,n,a){if(0>=Ie){e("The amount of token refresh attempts has reached its limit, requesting a fresh token","INFO","retryJWTRefresh");Ie=he.refreshJwtRetryAttempts;N()}else{var r=a&&a.body&&a.body.internalErrorCode;if(me.SHOULD_REQUEST_NEW_TOKEN_ERRORS.indexOf(r)>-1){Ie=he.refreshJwtRetryAttempts;N()}else{Ie-=1;e("Retrying to refresh the token #".concat(he.refreshJwtRetryAttempts-Ie),"INFO","retryJWTRefresh");setTimeout(function(){ve[t]=we.RETRY;j(n)},1e3)}}}function U(e){return ve[e]!==we.PENDING}function _(e){return ve[e]!==we.PENDING&&ve[e]!==we.NONE}function j(t){var n=r(t);n||e("jwtAccountId is invalid","ERROR","refreshJWT");var a=!0,i=parseInt(be.jwtRefreshMilliseconds,10);if(i){var c=s(n),u=Pe?Pe.getSessionData(c)||1:1;a=(new Date).getTime()-u>=i}else a=Date.now()>=1e3*o(t);e("Is JWT refresh needed?: ".concat(a),"INFO","refreshJWT");if(U(n)&&a){ve[n]=we.PENDING;setTimeout(function(){U(n)||(ve[n]=we.NONE)},1e4);var l={url:he.endPoints.unAuthJWT({IDPDomain:be.IDPDomain,convOwnerAccountId:n,accountId:lpTag&&lpTag.site}),method:"POST",data:{id_token:t},error:A.bind(this,n,t),success:P};if(Ae){l.headers=l.headers||{};l.headers["Content-Type"]="application/json"}else h(be.IDPDomain);g(l)}else U(n)&&!a&&P({body:{token:t},usingJWTFromSecureStorage:!0})}function k(e,t,n,a){var r=ye[t];if(!U(n)&&r){var o=t+1;setTimeout(function(){return k(e,o)},r)}else a?l(function(e){return a(e)},N,n):l(function(e){return P({body:{token:e}})},N,n)}function J(e){if(e){if("string"!=typeof e)N();else if(e){var t=r(e);U(t)?j(e):k(e,0,t)}}else N()}function L(e){var t=W(window.location.href).lpjwt||m(window.location).lpjwt;t&&(e=t);if(e){var n=r(e);U(n)?j(e):k(e,0,n)}else c()}function W(e){function t(e){return e.replace(/[^a-zA-Z0-9._-]/g,"")}try{var n=new URL(e),a=n.hash.substring(1),r=new URLSearchParams(a),o={};r.forEach(function(e,n){var a=t(n),r=t(e);o[a]=r});return o}catch(i){return{}}}function x(){var e=W(window.location.href).lpjwt||m(window.location).lpjwt;e?j(e):_(be.convOwnerAccountId)?l(J,N):k(null,0,be.convOwnerAccountId,j)}function F(t){e("The selected storage is ".concat(t,"."),"INFO","initGetAllJwtsFromSecureStorage");t&&(Re=!0);Ee&&Re&&p(L,c.bind(this,null))}function K(e){F(e||"NONE")}function M(t){Ee=function(n){t(n);e("Identity callback called with payload: ".concat(JSON.stringify(n||{}),"."),"INFO","verifyIdentity")};F()}function B(t){ue=lpTag.taglets.lpUtil;Se="";De=1;Ce=[];lpTag.identities=lpTag.identities||[];lpTag.identities.push(M);T(t);R({});var n="function"==typeof lpTag.getEnv&&lpTag.getEnv();Ae=void 0!==be.isFetchEnabled?JSON.parse(be.isFetchEnabled):"alpha"===n;de=be.fetchCacheMode;ve[be.convOwnerAccountId]=we.INIT;I(K);e("Initialized with configuration ".concat(JSON.stringify(be||{})),"INFO","init")}function G(e){if(e&&R({success:e.callback||e,convOwnerAccountId:e.clientId})){Se="";x()}}function z(e,t){return e.filter(function(e){return e.service===t})}function V(){return be.env===he.envType.DEV||be.env===he.envType.QA?he.domains.csdsQA:he.domains.csdsGA}function H(){var e=V(),t=Ae?window.lpTag.taglets.fetch:window.lpTag.taglets.jsonp,n={url:he.endPoints.csds({csdsDomain:e,accountId:be.accountId}),method:"GET",credentials:Ae?"omit":void 0,cache:Ae&&de?de:void 0,error:window.lpTag.taglets.unAuthMessaging.lpUnauthCsds,success:window.lpTag.taglets.unAuthMessaging.lpUnauthCsds};t.issueCall(n)}function Q(e){return e&&e.engConf&&e.engConf.lang||he.defaultLanguage}function Y(){var e=window.grecaptcha&&"function"==typeof window.grecaptcha.getResponse&&window.grecaptcha.getResponse();if(e&&e.length>0){be[he.names.captchaResponse]=e;H()}}function q(){if(be.useCaptcha){var e=document.getElementById("captchaContainer"),t=document.getElementById("reCaptchaSubmit");e&&(e.style.display="flex");t&&(t.onclick=Y)}}function Z(e){var t=e,n=document.getElementById("reCaptchaTitle"),a=document.getElementById("reCaptchaSubmit"),r=document.getElementById("reCaptchaCancel");window.translations[t]||(t="en-US");if(n&&r&&a){n.innerText=window.translations[t].message_us;a.innerText=window.translations[t].next;r.innerText=window.translations[t].close}}function X(e){return!(!e||!e.useRecaptcha)}function $(t,n){try{if(!t||0===t.length)return!1;var a=0!==t.indexOf("https://")?"https://".concat(t):t,r=new URL(a).hostname.split(".").slice(-2).join(".");if((n||[]).indexOf(r)<0){e("Configured url '".concat(t,"' is not in whitelist."),"INFO","isBaseDomainSafe");return!1}}catch(o){e("Error checking if configured url '".concat(t,"' is in whitelist. Error message: ").concat(o.message),"ERROR","isBaseDomainSafe");return!1}return!0}function ee(){document&&document.body&&"function"==typeof document.body.insertAdjacentText&&document.body.insertAdjacentText("beforebegin","ERROR: Invalid redirect URI")}function te(e,t){if(e&&!t){if(!$(be.redirect_uri,he.lpBaseDomainWhitelist)&&!be.redirect_uri.startsWith("https://".concat(be.leCdnDomain))){w("Invalid redirect URI");ee();return}var n;if(be.state)try{n=he.endPoints.externalStandardAuth2({uri:be.redirect_uri,jwt:e,state:encodeURIComponent(be.state)})}catch(a){w("Couldn't redirect to correct URI")}else n=he.endPoints.external({uri:be.redirect_uri,jwt:e});window.lpTag.redirect(n)}}function ne(t){e("The selected storage is ".concat(t,"."),"INFO","startExternalFlow");t&&(Re=!0);be&&be.accountId&&x()}function ae(e){return e&&e.env||he.envType.PRODUCTION}function re(e){Se="";S();window.lpCaptchaOnloadCallback=window.lpTag.taglets.unAuthMessaging.captchaOnloadCallback;var t=m(e||window.location);if(t.redirect_uri&&t.client_id){var n={},a=v(t),r=Q(a);n.accountId=t.client_id;n.redirect_uri=t.redirect_uri;n.state=t.state;n.success=te;n.isExternal=!0;n.useCaptcha=X(a);n.language=r;n.env=ae(a);if(n.accountId&&R(n)){if(be.useCaptcha){q();Z(r)}else H();return!0}}return!1}function oe(e){var t=Ae?e&&e.body:e,n=t&&t.ResultSet&&t.ResultSet.lpData;if(n){var a=z(n.baseURIs,he.names.csdsIDP),r=z(n.baseURIs,he.names.leCdnDomain);if(a.length>0&&r.length>0){be.IDPDomain=a[0].baseURI;be.leCdnDomain=r[0].baseURI;be.secureStorageLocation=O(r[0].baseURI);I(ne)}}else w("Couldn't get site map from csds. site: ".concat(be.accountId))}function ie(){if(be.useCaptcha&&window.grecaptcha&&"function"==typeof window.grecaptcha.render){var e=he.languageMapping[he.defaultLanguage];be.language&&he.languageMapping[be.language]&&(e=he.languageMapping[be.language]);window.grecaptcha.render("reCaptcha",{sitekey:he.captchaSiteKey,theme:"light",hl:e})}}function ce(){return le}function se(){return n(le)}var ue,le,de,pe="unAuthMessaging",fe="1.22.1-release_1430945775",ge=!0,he={endPoints:{unAuthJWT:function(e){var t=e.IDPDomain,n=e.accountId,a=e.convOwnerAccountId;return"https://".concat(t,"/api/account/").concat(a||n,"/anonymous/authorize")},externalStandardAuth2:function(e){var t=e.uri,n=e.state,a=e.jwt;return"".concat(t,"?state=").concat(n,"#id_token=").concat(a)},external:function(e){var t=e.uri,n=e.jwt;return"".concat(t,"#id_token=").concat(n)},postmessageConfigureFrameURL:function(e){var t=e.domain;return"https://".concat(t,"/postmessage/postmessage.min.html")},csds:function(e){var t=e.csdsDomain,n=e.accountId,a=e.convOwnerAccountId;return"https://".concat(t,"/csdr/account/").concat(a||n,"/service/baseURI.lpCsds?version=1.0")}},names:{secureStorageKey:"-unAuthJWT",storedAccountIdentitiesDictionaryKey:"-unAuthJWTAccounts",sdeType:"lpConsumer",captchaResponse:"gRecaptchaResponse",csdsIDP:"idp",leCdnDomain:"leCdnDomain"},domains:{csdsGA:"api.liveperson.net",csdsQA:"hc1n.dev.lprnd.net"},lpBaseDomainWhitelist:["lpsnmedia.net","liveperson.net","liveperson.com","lprnd.net"],captchaSiteKey:"6LdCazcUAAAAACpzhC0F6mj-SpyDQkcqXvg6ymaJ",languageMapping:JSON.parse('{"ar-AE":"ar","bg-BG":"bg","cs-CZ":"cs","Cy-sr-SP":"sr","da-DK":"da","de-DE":"de","el-GR":"el","en-UK":"en-GB","en-US":"en","es-419":"es-419","es-ES":"es","et-EE":"et","fi-FI":"fi","fr-CA":"fr-CA","fr-FR":"fr","he-IL":"iw","hi-IN":"hi","hr-HR":"hr","hu-HU":"hu","id-ID":"id","it-IT":"it","ja-JP":"ja","ko-KR":"ko","lt-LT":"lt","lv-LV":"lv","ms-MY":"ms","nb-NO":"no","nl-NL":"nl","pl-PL":"pl","pt-BR":"pt-BR","pt-PT":"pt-PT","ro-RO":"ro","ru-RU":"ru","sk-SK":"sk","sl-SI":"sl","sv-SE":"sv","th-TH":"th","tr-TR":"tr","uk-UA":"uk","vi-VN":"vi","zh-CN":"zh-CN","zh-HK":"zh-HK","zh-TW":"zh-TW"}'),defaultLanguage:"en-US",envType:{ALPHA:"alpha",QA:"qa",PRODUCTION:"prod",DEV:"dev"},refreshJwtRetryAttempts:60},we={READY:"READY",PENDING:"PENDING",NONE:"NONE",INIT:"INIT",RETRY:"RETRY"},me={SHOULD_REQUEST_NEW_TOKEN_ERRORS:["9002","9007","9008","9009","9011","9012","9014","9015","1001","1003","1004","1005","1006","1007","1008","1009","1010","1011","1012","1013","1024","1025","1026","1037","1038","1049","2001","2002","2004","2005","2006","2007","2008","2009","3001","3002","3003"]},ye=[10,50,100,300,1e3,5e3],ve={},Te=31536e6,Ie=he.refreshJwtRetryAttempts,Se="",Oe=!1,Re=!1,be={},Ee=null,De=1,Ce=[],Ne=lpTag,Pe=Ne.storageMethods,Ae=!1;return{version:fe,name:pe,lpUnauthFunction:G,lpUnauthExternal:re,lpUnauthCsds:oe,captchaOnloadCallback:ie,init:B,jsMethodExtended:ge,getJwt:ce,getSub:se}}();}catch(e){lpTag.handleGeneralError("unAuthMessaging",e);}try{window.lpTag=window.lpTag||{};lpTag.taglets=lpTag.taglets||{};lpTag.taglets.jsLoader=lpTag.taglets.jsLoader||function(e){function t(e){var t=[],n=[],a=!1;for(var r in e)if("string"==typeof e[r]||e[r].url)if(e[r].dependency){var l=o(e,e[r].dependency);l.length>0&&(t=t.concat(l))}else"string"==typeof e[r]||"string"==typeof e[r].url?a=!0:n.push(e[r]);else"string"!=typeof e[r]&&n.push(r);return{missingKeys:t,invalidUrls:n,requestValid:0===t.length&&0===n.length&&a}}function n(){lpTag.log("JSLoader was initialised","DEBUG",v)}function a(e){T+=1;var n="";if(e&&e.loadObj){var a=t(e.loadObj);if(a.requestValid){e.startTime=new Date;for(var r in e.loadObj)if(e.loadObj[r]!==!0&&!e.loadObj[r].dependency){n=e.loadObj[r].url||e.loadObj[r];f(n,e.context,i(r,e))}}else j(e.error,e.context||null,a)}}function r(){return{version:S,name:v,errors:m,downloads:E,configsCount:T}}function o(e,t){var n=[];t=t.constructor===Array?t:[t];for(var a=0;a<t.length;a++)e[t[a]]||n.push(t[a]);return n}function l(e,t,n){m+=1;n.loadError=n.loadError||[];n.loadError.push({key:e,url:t});return!0}function d(e,t,n){E+=1;if("object"==typeof t.loadObj[e]){var a=t.loadObj[e];j(n&&a.error?a.error:a.success,a.context||null,n?{error:!0,data:a}:{data:a})}t.loadObj[e]=!0}function c(e){var t=!0;for(var n in e.loadObj)if(e.loadObj.hasOwnProperty(n)&&e.loadObj[n]!==!0){t=!1;break}return t}function i(e,t){return function(n,a){d(e,t,a);a&&l(e,n,t);u(e,t);c(t)&&s(t,!!t.loadError)}}function s(e,t){e.endTime=new Date;setTimeout(function(){j(t?e.error:e.success,e.context,t?e.loadError:e);e=null},10)}function u(e,t){var n;for(var a in t.loadObj)if("object"==typeof t.loadObj[a]){t.loadObj[a].dependency=t.loadObj[a].dependency&&t.loadObj[a].dependency.constructor===Array?t.loadObj[a].dependency:[t.loadObj[a].dependency];n=[];for(var r=0;r<t.loadObj[a].dependency.length;r++)t.loadObj[a].dependency[r]!==e&&n.push(t.loadObj[a].dependency[r]);if(n.length!==t.loadObj[a].dependency.length){t.loadObj[a].dependency=n;0===n.length&&f(t.loadObj[a].url,t.loadObj[a].context,i(a,t))}}}function f(e,t,n){if(w[e])w[e].state===R.LOADING?g(n,w[e].callbackQueue):w[e].state===R.SUCCESS&&j(n,t,[e]);else{w[e]=p(R.LOADING);g(n,w[e].callbackQueue);b(e,{success:function(){w[e].state=R.SUCCESS;O.call(this,e,t,w[e].callbackQueue)},error:function(){w[e].state=R.ERROR;y.call(this,e,t,w[e].callbackQueue)}})}}function p(e,t){return{state:e,callbackQueue:t||[]}}function b(e,t){var n=document.createElement("script");n.setAttribute("type","text/javascript");n.setAttribute("charset","UTF-8");n.onreadystatechange=n.onload=t.success;n.onerror=t.error;n.setAttribute("src",e);(document.head||document.getElementsByTagName("head")[0]).appendChild(n)}function O(t,n,a){var r=!1;this.readyState?e.opera||"loaded"!==this.readyState&&"complete"!==this.readyState||(r=!0):r=!0;if(r){h(t,n,a,!1);this.onerror=this.onload=this.onreadystatechange=null}}function y(e,t,n){h(e,t,n,!0);this.onerror=this.onload=this.onreadystatechange=null}function g(e,t){t&&-1===t.indexOf(e)&&t.push(e)}function h(e,t,n,a){for(var r;n.length;){r=n.pop();j(r,t,e,a)}}function j(t,n){n=n||e;if("function"==typeof t){var a=Array.prototype.slice.call(arguments,2);try{return t.apply(n,a)}catch(r){lpTag.log("Failed to execute callback exc= "+r.message,"ERROR",v)}}}var v="jsLoader",S="1.0.1",E=0,m=0,T=0,R={LOADING:"LOADING",SUCCESS:"SUCCESS",ERROR:"ERROR"},w={};return{v:S,init:n,loadJS:a,validateLoadObj:t,inspect:r}}(window);}catch(e){lpTag.handleGeneralError("jsLoader",e);}